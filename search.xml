<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自定义 Gii 模板]]></title>
    <url>%2F2018%2F05%2F23%2Fyii-gii%2F</url>
    <content type="text"><![CDATA[开发是需要用到 gii,但是 gii 并不是完全符合自己的开发需求,所以需要对他做一点改造 这里先拿 basic 版举例, advance版同理 1.修改配置文件 web.php12345678910111213141516171819202122232425262728// file path: @app/config/web.phpif (YII_ENV_DEV) &#123; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'debug'; $config['modules']['debug'] = [ 'class' =&gt; 'yii\debug\Module', ]; $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'yii\gii\Module', // 这里把原来的 model generator 给覆盖成自己的 'generators' =&gt; [ 'model' =&gt; [ // 自定义的模板生成器 'class' =&gt; 'app\common\gii\model\Generator', //设置我们自己的模板 'templates' =&gt; [ //模板名 =&gt; 模板路径 'default' =&gt; '@app/common/gii/model/default', 'original' =&gt; '@app/common/gii/model/original_tpl', ] ] ], ];&#125; 现在在配置中指定了两种model 生成模板了 2.设置自定义的 Geneartor 和 template现在进@app/vendor/yiisoft/yii2-gii/src/generators/model把这个目录拷贝到 @app/common/gii/这里,位置随意, 只要保证 config 中能找到这个路径就行,现在我们就在 @app/common/gii/model这里操作 因为 Generator 继承的 \yii\gii\Generator, 需要实现两个方法, 一个是 getName() 另一个是 generate(), 我们主要修改的就是 generate(),12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// file path: @app/common/gii/model/Generatornamespace app\common\gii\model;use Yii;use yii\db\ActiveQuery;use yii\db\ActiveRecord;use yii\db\Connection;use yii\db\Schema;use yii\db\TableSchema;use yii\gii\CodeFile;use yii\helpers\Inflector;use yii\base\NotSupportedException;class Generator extends \yii\gii\Generator&#123; /** some code ..... */ /** * &#123;@inheritdoc&#125; */ public function generate() &#123; $files = []; $relations = $this-&gt;generateRelations(); $db = $this-&gt;getDbConnection(); foreach ($this-&gt;getTableNames() as $index =&gt; $tableName) &#123; // model : $modelClassName = $this-&gt;generateClassName($tableName); $queryClassName = ($this-&gt;generateQuery) ? $this-&gt;generateQueryClassName($modelClassName) : false; $tableSchema = $db-&gt;getTableSchema($tableName); $params = [ &apos;tableName&apos; =&gt; $tableName, &apos;className&apos; =&gt; $modelClassName, &apos;queryClassName&apos; =&gt; $queryClassName, &apos;tableSchema&apos; =&gt; $tableSchema, &apos;properties&apos; =&gt; $this-&gt;generateProperties($tableSchema), &apos;labels&apos; =&gt; $this-&gt;generateLabels($tableSchema), // 这是新增的 &apos;constMap&apos; =&gt; $this-&gt;generateConstMap($tableSchema), &apos;rules&apos; =&gt; $this-&gt;generateRules($tableSchema), &apos;relations&apos; =&gt; isset($relations[$tableName]) ? $relations[$tableName] : [], ]; // 同一个库中只生成一个 Model.php 之后的 model 都要继承这个 model if ($index == 0) &#123; $files[] = new CodeFile( Yii::getAlias(&apos;@&apos; . str_replace(&apos;\\&apos;, &apos;/&apos;, $this-&gt;ns)) . &apos;/Model.php&apos;, $this-&gt;render(&apos;cModel.php&apos;, $params) ); &#125; $files[] = new CodeFile( Yii::getAlias(&apos;@&apos; . str_replace(&apos;\\&apos;, &apos;/&apos;, $this-&gt;ns)) . &apos;/&apos; . $modelClassName . &apos;.php&apos;, $this-&gt;render(&apos;model.php&apos;, $params) ); &#125; return $files; &#125; protected function generateConstMap($table)&#123; // some code &#125; /** some code ..... */&#125; 在generate() 这个方法里的 $params 这里就是给模板准备参数, new CodeFile这里就是生成指定的模板 现在我们在模板中搞一下 3.设置 model 模板在@app/common/gii/model目录下有一个default目录,就是默认的 template,咱们在config.php中设置了12345'templates' =&gt; [ //模板名 =&gt; 模板路径 'default' =&gt; '@app/common/gii/model/default', 'original' =&gt; '@app/common/gii/model/original_tpl', ] 这两个, 把 default/ 复制一份叫 original_tpl/ 这在 gii 页面端选模板的时候能看到这写别名,如果是console模式的话只能使用default模板了 1234567891011121314151617181920212223242526272829303132// path: @app/common/gii/default/model.php&lt;?php/** * This is the template for generating the model class of a specified table. *//* @var $this yii\web\View *//* @var $generator yii\gii\generators\model\Generator *//* @var $tableName string full table name *//* @var $className string class name *//* @var $queryClassName string query class name *//* @var $tableSchema yii\db\TableSchema *//* @var $properties array list of properties (property =&gt; [type, name. comment]) *//* @var $labels string[] list of attribute labels (name =&gt; label) *//* @var $rules string[] list of validation rules *//* @var $relations array list of relations (name =&gt; relation declaration) *//* @var $constMap string[] list of attribute labels (name =&gt; label) */echo "&lt;?php\n";?&gt;namespace &lt;?= $generator-&gt;ns ?&gt;;use Yii;/** * This is the model class for table "&lt;?= $generator-&gt;generateTableName($tableName) ?&gt;". *&lt;?php foreach ($properties as $property =&gt; $data): ?&gt;...底下一些乱七八糟的代码.... 这里就看着办吧,就是正常的渲染模板 因为在generate()中还设置了一个1234567// 同一个库中只生成一个 Model.php 之后的 model 都要继承这个 modelif ($index == 0) &#123; $files[] = new CodeFile( Yii::getAlias('@' . str_replace('\\', '/', $this-&gt;ns)) . '/Model.php', $this-&gt;render('cModel.php', $params) );&#125; 新增了一个cModel.php,这个是我自己的业务需求, 同库的 model 全部继承这个 model, 这里只是设置了一下getDb()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/** * This is the template for generating the model class of a specified table. *//* @var $this yii\web\View *//* @var $generator yii\gii\generators\model\Generator *//* @var $tableName string full table name *//* @var $className string class name *//* @var $queryClassName string query class name *//* @var $tableSchema yii\db\TableSchema *//* @var $properties array list of properties (property =&gt; [type, name. comment]) *//* @var $labels string[] list of attribute labels (name =&gt; label) *//* @var $rules string[] list of validation rules *//* @var $relations array list of relations (name =&gt; relation declaration) *//* @var $constMap string[] list of attribute labels (name =&gt; label) */$date = date('Y/m/d H:i');$date = explode(' ', $date);$model = &lt;&lt;&lt;str&lt;?php/** * Created by Gii. * TemplatePath: @app\common\gii\model\default\cModel.php * Date: &#123;$date[0]&#125; * Time: &#123;$date[1]&#125; */namespace &#123;$generator-&gt;ns&#125;;use yii\db\ActiveRecord;use Yii;/** * 同文件夹下都要继承一下这个 model,目前是用来改库的链接地址 * Class Model * @package app\modules\v1\models\passport */class Model extends ActiveRecord&#123; /** * 重写表所对应的数据库链接信息 (如果函数不存在则默认为 db 的配置) * @return \yii\db\Connection */ public static function getDb() &#123; return Yii::\$app-&gt;get('&#123;$generator-&gt;db&#125;'); &#125;&#125;str;echo $model;?&gt; 这样依赖 gii 的模板自定义就算是完事了 4. console 模式下的 gii照例首先需要设置console.php的配置 12345678910111213141516//path @app/console.phpif (YII_ENV_DEV) &#123; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'app\common\gii\Module', 'generators' =&gt; [ 'model' =&gt; [ // 自定义的模板生成器 'class' =&gt; 'app\common\gii\model\Generator', //设置我们自己的模板 console 默认就是 default 模板 'templates' =&gt; [] ] ], ];&#125; generators 和 之前的配置一样,区别就是 module 下的 class 设置成自己的 Module 这里把@app/vendor/yiisoft/yii2-gii/src/Module.php复制一份到@app/common/gii/Module.php 改一下命名空间并且继承\yii\gii\Module 毕竟咱们是定制的, 这个代码不能在 vendor 中改,不然以后你再装新的 composer 包的时候会非常麻烦 12345678910111213141516171819202122232425// path: @app/common/gii/Module.php/**代码块*/ public function bootstrap($app) &#123; if ($app instanceof \yii\web\Application) &#123; $app-&gt;getUrlManager()-&gt;addRules([ ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id, 'route' =&gt; $this-&gt;id . '/default/index'], ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id . '/&lt;id:\w+&gt;', 'route' =&gt; $this-&gt;id . '/default/view'], ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id . '/&lt;controller:[\w\-]+&gt;/&lt;action:[\w\-]+&gt;', 'route' =&gt; $this-&gt;id . '/&lt;controller&gt;/&lt;action&gt;'], ], false); &#125; elseif ($app instanceof \yii\console\Application) &#123; $app-&gt;controllerMap[$this-&gt;id] = [ // 这里改成自己定制的 consoleController 'class' =&gt; 'app\common\gii\console\GenerateController', 'generators' =&gt; array_merge($this-&gt;coreGenerators(), $this-&gt;generators), 'module' =&gt; $this, ]; &#125; &#125;/**代码块*/ 只用把 console 的 GenerateController 指向咱们自定义的控制器, 复制目录@app/vendor/yiisoft/yii2-gii/src/console/ 到 @app/common/gii/console/, 这时我们就能对 gii console 模式下的代码进行调整了 可能在@app/common/gii/console/GenerateController.php中的代码让你摸不到头脑, 这里是在 actions()来着注册 router, 具体的 action 实现则是在 class 中指定了 1234567891011121314151617181920// path: @app/common/gii/console/GenerateController.php public function actions() &#123; $actions = []; foreach ($this-&gt;generators as $name =&gt; $generator) &#123; $actions[$name] = [ 'class' =&gt; 'yii\gii\console\GenerateAction', 'generator' =&gt; $generator, ]; // 依赖model generator 重新定义一个 gii 命令 if($name == 'model') &#123; $actions['all'] = [ 'class' =&gt; 'app\common\gii\console\GenerateAllAction', 'generator' =&gt; $generator, ]; &#125; &#125; return $actions; &#125; 因为所有的 Generator 都实现了 getName() 和 generate()这两个方法,action 也是只使用了这两个方法,可以自己翻下代码,这里就不详细讲了]]></content>
      <categories>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>gii</tag>
        <tag>yii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十进制与二进制,八进制,十六进制的换算]]></title>
    <url>%2F2018%2F05%2F23%2Fconversion-calculation%2F</url>
    <content type="text"><![CDATA[复习一下二进制,八进制,十六进制之间的互相转换和怎么用十进制去转换它们 首先做一个定义： B(Binary)表示二进制，O(Octal)表示八进制，D(Decimal)或不加表示十进制，H(Hexadecimal)表示十六进制，比如：(101011)B=(53)O=(43)D=(2B)H 十进制转换成二进制除二取余法二进制说白了就是 0 和 1 啊，在十进制的时候就是2的次方 以十进制的(43)D为例：123456743/2=21%121/2=10%110/2=5 %05 /2=2 %12 /2=1 %01 /2=0 %1以上把余数倒着排就是二进制的结果了，即101011 阶段相减法（适合低次方的速算）每次都减去最大的值，还是拿(42)D举例：42-32-8-2-1=0， 对应以下的表格为： 64 32 16 8 4 2 1 2^6 2^5 2^4 2^3 2^2 2^1 2^0 0 1 0 1 0 1 1 结果就是： 101011 十进制转二进制以 (101011)B 举例：11*2^0 + 1*2^1 + 1*2^3 + 1*2^5 = 43 十进制转八进制和十六进制都是用的除8或16取余法，不做赘述了，有点区别就是16进制的9以后就是abcd…代替的这等式就自己进行一下验算好了: (101011)B=(53)O=(43)D=(2B)H 二进制转八进制、十六进制先复习一个等式: 2^0 * 2^1 * 2^2 = 2^3， 那么二进制转八进制就是将二进制的数三个为一组合并一下：1101|011 =&gt; 53 同理， 二进制转16进制就是按四个为一组合并一下：10010|1011 =&gt; 2b 十六进制和八进制之间转换都是先转换成二进制，然后再转成想要的进制]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Rabbitmq实现的延时队列(golang版)]]></title>
    <url>%2F2018%2F05%2F14%2Fgo-rabbitmq-delay-queue%2F</url>
    <content type="text"><![CDATA[虽然 rabbitmq 没有延时队列的功能,但是稍微变动一下也是可以实现的 实现延时队列的基本要素 存在一个倒计时机制:Time To Live(TTL) 当到达时间点的时候会触发一个发送消息的事件:Dead Letter Exchanges（DLX） $~~$基于第一点,我利用的是消息存在过期时间这一特性, 消息一旦过期就会变成dead letter,可以让单独的消息过期,也可以设置整个队列消息的过期时间而rabbitmq会有限取两个值的最小值 $~~$基于第二点,是用到了rabbitmq的过期消息处理机制:. x-dead-letter-exchange 将过期的消息发送到指定的 exchange 中. x-dead-letter-routing-key 将过期的消息发送到自定的 route当中 在这里例子当中,我使用的是 过期消息+转发指定exchange 在 golang 中的实现首先是消费者comsumer.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package mainimport ( "log" "github.com/streadway/amqp")func failOnError(err error, msg string) &#123; if err != nil &#123; log.Fatalf("%s: %s", msg, err) &#125;&#125;func main() &#123; // 建立链接 conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/") failOnError(err, "Failed to connect to RabbitMQ") defer conn.Close() ch, err := conn.Channel() failOnError(err, "Failed to open a channel") defer ch.Close() // 声明一个主要使用的 exchange err = ch.ExchangeDeclare( "logs", // name "fanout", // type true, // durable false, // auto-deleted false, // internal false, // no-wait nil, // arguments ) failOnError(err, "Failed to declare an exchange") // 声明一个常规的队列, 其实这个也没必要声明,因为 exchange 会默认绑定一个队列 q, err := ch.QueueDeclare( "test_logs", // name false, // durable false, // delete when unused true, // exclusive false, // no-wait nil, // arguments ) failOnError(err, "Failed to declare a queue") /** * 注意,这里是重点!!!!! * 声明一个延时队列, ß我们的延时消息就是要发送到这里 */ _, errDelay := ch.QueueDeclare( "test_delay", // name false, // durable false, // delete when unused true, // exclusive false, // no-wait amqp.Table&#123; // 当消息过期时把消息发送到 logs 这个 exchange "x-dead-letter-exchange":"logs", &#125;, // arguments ) failOnError(errDelay, "Failed to declare a delay_queue") err = ch.QueueBind( q.Name, // queue name, 这里指的是 test_logs "", // routing key "logs", // exchange false, nil) failOnError(err, "Failed to bind a queue") // 这里监听的是 test_logs msgs, err := ch.Consume( q.Name, // queue name, 这里指的是 test_logs "", // consumer true, // auto-ack false, // exclusive false, // no-local false, // no-wait nil, // args ) failOnError(err, "Failed to register a consumer") forever := make(chan bool) go func() &#123; for d := range msgs &#123; log.Printf(" [x] %s", d.Body) &#125; &#125;() log.Printf(" [*] Waiting for logs. To exit press CTRL+C") &lt;-forever&#125; 然后是生产者productor.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( "log" "os" "strings" "github.com/streadway/amqp")func failOnError(err error, msg string) &#123; if err != nil &#123; log.Fatalf("%s: %s", msg, err) &#125;&#125;func main() &#123; conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/") failOnError(err, "Failed to connect to RabbitMQ") defer conn.Close() ch, err := conn.Channel() failOnError(err, "Failed to open a channel") defer ch.Close() body := bodyFrom(os.Args) // 将消息发送到延时队列上 err = ch.Publish( "", // exchange 这里为空则不选择 exchange "test_delay", // routing key false, // mandatory false, // immediate amqp.Publishing&#123; ContentType: "text/plain", Body: []byte(body), Expiration: "5000", // 设置五秒的过期时间 &#125;) failOnError(err, "Failed to publish a message") log.Printf(" [x] Sent %s", body)&#125;func bodyFrom(args []string) string &#123; var s string if (len(args) &lt; 2) || os.Args[1] == "" &#123; s = "hello" &#125; else &#123; s = strings.Join(args[1:], " ") &#125; return s&#125; 运行一下:12go run comsumer.gogo run productor.go $~~$具体看代码和注释就行, 这里的关键点就是将要延时的消息发送到过期队列当中, 然后监听的是过期队列转发到的 exchange 下的队列正常情况就是始终监听一个队列,然后把过期消息发送到延时队列中,当消息到达时间后就把消息发到正在监听的队列 一个自己写的mq工具]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关 Restful 借口规范踩到的坑]]></title>
    <url>%2F2018%2F05%2F09%2Fphp-restful%2F</url>
    <content type="text"><![CDATA[使用 restful 接口规范开发时我碰到的几个槽点… restful提供了一种接口规范,本意是让路由变得更加易懂,不过既然是规则那么就有束缚,想在项目中采用这个的同学们可以参考一下 路由嵌套太要命$~~$如果存在这种city/3/zoo/2/animal/1这样的查询路由你怎么说? 多层嵌套在我看来反而不如?city=3&amp;zoo=2&amp;animal=1这种 query 来的方便直接,尤其是在后台的开发中这种目录结构会让人痛不欲生,而且很多情况下我们进行列表展示的时候数据不是从一个表里取出来的,有时甚至需要跨业务或者调第三方的进行组合,这种情况下路由是不是要很长? restful路由里需要显示出要操控的资源,这资源种类一多url 就会变得长长长,反而不如像select/animal-list这样来的简单直接 权限问题$~~$这是由于上个问题引申出来的, 像city/{cid}/zoo/{zid}/animal/{aid}这种路由规则的权限怎么去维护? 而且 rbac 在国内的应用来说很是常见,我们目前的解决方案也是12345$route = [ 'select/animal' =&gt; 'city/&#123;cid&#125;/zoo/&#123;zid&#125;/animal/&#123;aid&#125;', //.....]; 这样给这类的路由出一个给机器看的路由,长期下来如果当前开发人员走了后续接手的程序员会很绝望 路由规则让人头秃$~~$restful的路由命名核心就是将动词转换成名词,这个就看你的词汇量能不能跟上业务了,最典型的就是用户登录注册,user/login和user/register这种明显不符合啊,如果用session/{id}这种路由又显得怪怪的 如果出现文件类型接口的怎么办?$~~$举个例子就是如果我有导出 excel 或者生成二维码的需求,那么这个路由算是文档操作里面的还是业务资源底下的?这一类的操作大部分都是查的居多,增删改几乎没有,这种接口都是单独写路由规则的.还有一点,我们这边采取的前后端分离通常都是 application/json 格式传输数据,当碰到文件上传的时候还是老老实实的用multipart/form-data,请求方式要单独写,php56的还会提示$HTTP_RAW_POST_DATA即将被php://input替换 回归到参数提取的问题$~~$还是查找这一块,路由很受限,举个例子:我需要查当前某个动物园的动物种类,按名字首字母降序排序,那么我应该是GET /zoo/3/animal?sort=-1&amp;slabel=name, 需要组成这个路由首先要前端兄弟把指定的 id 给拼出来,然后其他的参数拼到后面,或者其他的参数放到header里面,那么后台兄弟就要先把路由中的参数给剔出来,然后再去某个地方把剩余的参数给拿到…累不累? 查询条件多的情况下是不是还和原来一样,而且还多了提取url中参数的操作? 理论上在查询的时候是可以指定显示字段的$~~$GET /zoo?field=name,id,desc 查询的路由把暴露字段的权利开放给了调用方,那么如果有人操作不规范或者直接就是是坏,每次请求我都取全量字段内容,那么我的带宽不要钱啊?mysql 的 I/O 也是压力啊 总结$~~$restful接口在猛一看很美好,但是需要结合自己实际业务是不是适配这套规则,不要强行为了restful而restful, 一些小而美的工具可以用这种规范,中大型的业务真的要慎重考虑]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php开发过程中不常碰到的error]]></title>
    <url>%2F2018%2F04%2F26%2Fphp-unsual-mistakes%2F</url>
    <content type="text"><![CDATA[这里做一些备注,以防再次碰到 url 当中的参数有 &amp;timestamp=1234567890这样的字段会被转义成xtamp=1234567890这个不仅存在于页面解析当中,当使用 curl 请求时拼接的参数有这种格式的也会发生转义解决方法有两个: 把 timestamp 这个参数放在 urlQuery 的最前面, ?timestamp=1234567890 这样避免出现 &amp;time发生转义的情况 将&amp;用&amp;amp;来代替 Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.出现这句话通常说明你在用的 php 版本是5.6.而且在php&lt;=5.6的时候,进行 application/json格式的 post 提交会把数据放在$HTTP_RAW_POST_DATA这个系统变量里面,在php&gt;=7的时候这个变量被移除了,统统归总到php://input这里解决方法: 根据系统提示的走: Although that indeed would be technically impossible (as $HTTP_RAW_POST_DATA is populated in the bootstrapping phase of the PHP process) allow one to override the setting by means of calling ini_set. 要确保自己的系统中没有使用 HTTP_RAW_POST_DATA这个变量,直接在php.ini里面禁掉它的设置,但是容易出现系统中又打开的情况(在框架中很常见) 改一下自己的提交方式, 使用 application/form-data或者application/x-www-form-urlencoded这种格式的提交, 然后在后端接收数据的时候再转成自己需要的格式(通常是数组) 参考资料 Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’这种情况出现在平时运行的好好的, 但是突然换 cli 模式后这个配置就出问题了,原因在当 host=localhost时走的是 unix:socket 链接, 当host=127.0.0.1走的是 tcp 链接,这在php-fpm和php-cli中有点区别,尤其是本地没有安装 mysql 的时候解决方法有三种: 将本地链接配置统一成 127.0.0.1 查看 MySQL 中的user表, host=localhost和host=127.0.0.1是不是用的同一个账号密码 配置php.ini文件中的pdo_mysql.default_socket= 写上完整的 socket 路径以上三种方法都可以试一下参考资料 常驻内存时发生的事情这个是 phper 很少碰到但是很常见的情况, 比如用 swoole 启动了一个常驻进程的服务, 那么就一定要小心使用静态变量,在同步模式下会发生变量污染, 还有就是 redis,mysql 这类的链接,你会发现长时间静置以后就会出现一些摸不着头脑的问题, 这种情况不妨想一下是不是 server 端回收了这个 socket,因此在 client 端怎么都写入不进去. 还有就是 php 在读取消息的时候,出现消息过长的情况,那么就要考虑EOF终止符的问题了… 单次 http 每一次请求都是全新的代码, 不用自己考虑 gc 的问题, 但是在常驻内存的时候,这些就是一个个的大坑了 mysql has gone away产生这个错误的主要原因是 mysql server 端断开了链接, client 端还拿着这个句柄去请求,解决方式有两种: show global variables like &#39;%timeout&#39;; 查看 wait_timeout 的时长,适当的调长一点, 这种方法治标不治本,而且有隐患 使用 mysql 之前需要 mysql_ping() 一下, 如果出现断开的错误就启动重连机制]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 开发过程中一些不错的工具(不定期更新)]]></title>
    <url>%2F2018%2F03%2F26%2Fgolang-awesome-tools%2F</url>
    <content type="text"><![CDATA[就是平时用到的一些工具 fswatch用于监听目录文件的修改,一旦发生修改将自动执行系统指令,比如保存后自动 go run 之类的, 这个使用 go 写的 codeskyblue/fswatch 还有个跨平台的命令行工具,同样的名字 start 更多 emcrisostomo/fswatch 不过图方便用 go 这个就行 bee属于 beego 的附属开发工具, bee run [project-name] 的执行效果也是自动监听文件改动执行编译命令, 感觉不如fswatch方便,当然用 beego 开发的另说astaxie/beego govendor是 go 开发的包管理工具, 虽然依赖的package都在 gopath当中,但是代码换一个环境就要重新go get一堆东西实在不方便,而且还有一个值得吐槽的依赖包版本问题govendor工具就是解决这类的问题,通过 hash 来保证开发和线上使用的依赖库一样kardianos/govendor Gin一个很不错的 web 开发框架,github 上已经有 14711个 star(截止到18/02/05), 和 Martini的api 很像,但是更快,适合用来做 restful 的 APIgin-gonic/gin mux一个独立的路由包, 支持 restful,轻量,而且支持go的net/http 的接口gorilla/mux beego国人开发的go web框架, 特点是大而全,方便入门,和 php 的框架思路很像,有不少人在吐槽它的笨重, 如果公司想转成 go 做 web 业务它是一个不错的选择,因为它能快速出东西啊,个人感觉有点头疼的是源码很多很多…astaxie/beego beego-log如果不想全部引用 beego 的内容,可以引进它的模块啊,它的 log 模块就是一个很不错的选择beego-log 的中文档 kafka-go和 kafka 相关的库很少,不过我个人使用的话这个库已经能满足我的需求, 我这里也有一个demo示例segmentio/kafka-go go-redis/redisredis 的依赖包还是很简单的,这里推荐一个 star 不少的库go-redis/redis amqp如果用 rabbitmq 就肯定用这个拉,官方出品的肯定有保证啊,可惜 kafka 还没出官方包amqp]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-Volume]]></title>
    <url>%2F2018%2F02%2F13%2Fdocker-volume%2F</url>
    <content type="text"><![CDATA[这里有一个使用 wordpress 的 docker-compose.yml的示例:1234567891011121314151617181920212223242526272829version: '3'services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: gaofeifiy MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress ports: - 33060:3306 wordpress: depends_on: - db image: wordpress:latest ports: - "8080:80" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpressvolumes: db_data: 其中有一点奇怪的地方就是在db的数据挂载当中,是这么写的:123456789... db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql....volumes: db_data: 这是docker-compose version2 起开始的新语法,目的就是方便多个服务之间公用同一个卷12volumes: db_data: 这种写法就是声明一个命名卷, 通过docker volume ls 可以列出来宿主机上的所有挂载的卷,而且这些卷不会因为容器被删除而删除,为的就是方便数据和服务分离 可以通过命令docker inspect wordpress_db_data 来查看卷的配置,这里wordpress_db_data就是我们刚才声明的那个卷的名字123456789101112131415➜ wordpress git:(master) ✗ docker inspect wordpress_db_data[ &#123; "CreatedAt": "2018-02-13T04:29:29Z", "Driver": "local", "Labels": &#123; "com.docker.compose.project": "wordpress", "com.docker.compose.volume": "db_data" &#125;, "Mountpoint": "/var/lib/docker/volumes/wordpress_db_data/_data", "Name": "wordpress_db_data", "Options": &#123;&#125;, "Scope": "local" &#125;] 不过他的mountpoint的路径并不是宿主机上的路径,而依然是属于docker的路径,在macOS系统当中可以执行 123screen ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty# ls -ltrh /var/lib/docker/volumes 在 macOS 中并不能看到实体文件,而是进入linuxkit中,所有的资源也是在那里,这在win和mac会出现,在 linuxOS中就是正常的/var/lib/docker路径可以查看卷的列表, 参考资料1 参考资料2 清除本地的卷可以执行docker volume prune 官方文档]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>volume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-compose.yml 常用命令]]></title>
    <url>%2F2018%2F02%2F12%2Fdocker-compose-yml%2F</url>
    <content type="text"><![CDATA[常用命令备注 build 构建(重构)服务容器格式为: docker-compose build [options] [service...] --force-rm 删除构建时的临时容器 --no-cache 构建不使用 cache --pull 始终尝试 pull 最新的镜像 up (这个才是最常用的)docker-compose up [options] [service...] 直接输出docker-compose up就是将执行目录下的docker-compose.yml里的服务都自动构建,重新创建,并启动起来,同时将不同的容器关联起来,默认保持前台运行,同时也会输出各容器的输出日志 docker-compose up -d 将后台执行,在生产环境中使用 -d 保持后台运行 --no-color 不以颜色区分日志输出 --no-deps 不启动服务关联的容器 --force-recreate 强制重新创建容器 --no-recreate 若容器已经存在,则不再构建, 与上者不同时使用 --no-build 不自动构建缺失的镜像 -t , --timeout TIMEOUT 停止容器时候的超时,默认10s config 检测配置文件格式如果正确则显示配置文件内容,如果错误则显示错误原因 down 停止up启动的游戏exec 进入指定的容器images 列出 compose 中包含的镜像kill 发送信号停止容器docker-compose kill [options] [service...]比如 docker kill -s web logs 日志docker-compose logs [options] [service...]不同容器输出的日志颜色不同,不想有颜色就添加参数--no-color pause 暂停一个服务pull 拉取所需的镜像docker-compose pull [options] [service...] version 输出 compose 的版本一个简单的示例,具体代码参考 这里 123456789version: '3'services: web: # 一个 service 的名字 build: . # 指出 Dockerfile 所在文件夹的路径, 而且每个 service 中必须有 build 或者 image ports: # 将容器内的接口绑定到宿主机上 - "5000:5000" redis: image: "redis:alpine" # 这就是使用的远程镜像 下面列出来几个常用的参数命令: build 通过 Dockerfile 来构建镜像,可以指定Dockerfile路径以及context的路径, 可以用arg指定构建时的参数 比如: 123456web: build: context: ./dir dockerfile: ./other-dir arg: buildno: 1 image 根据提供的镜像名拉取镜像 command 覆盖容器启动后的默认命令比如: 1command: echo "hello world" container_name 指定 service 容器的名字,如果没设置的话就是 容器_序号 这样, 比如 web_1,db_1 这样的 1container_name: web-container devices 指定设备映射关系 12devices: - "/dev/ttyUSB1:/dev/ttyUSB0" depends_on 指定容器依赖关系,会优先构建依赖的容器,比如: 123456789101112version: '3'services: web: build: . depends_on: - db - redis redis: image: redis db: image: mysql 会先构建 db,redis再构建web dns 自定义 dns 服务列表 123dns: - 8.8.8.8 - 114.114.114.114 env_file 从文件中提取环境变量,同变量名的会被最后的变量覆盖 12345env_file: .envenv_file: - .env1 - .env2 格式必须是可以被 #注释的12PRO_ENV=productAPP_NAME=hahaha environment 设置环境变量,可以是KEY=VALUE 也可以只给出变量名,这将调取 docker 宿主机的环境变量 1234567environment: ROCK_ENV: 'development' SESSION_SECRET:environment: - ROCK_ENV=development - SESSION_SECRET port 将端口暴露到宿主机上对于表示布尔值的变量建议添加引号,防止 yaml 解析的时候产生歧义,比如:y|yes|TRYE|true|ON|on 这一类的 volumes 将宿主机的目录路径和容器中的路径挂载,可以设置访问模式,比如: 1234volumes: - /var/lib/mysql # 同路径挂载 - cache/:/tmp/cache - ~/configs:/etc/configs:/ro # 支持相对路径, 支持访问模式 读取变量: compose会读取宿主机的环境变量和当前目录下的.env文件中的变量 比如: 1234version: '3'services: db: image: "mongodb:($MONGO_VERSION) 这在启动的时候就会根据环境变量来调整要拉取的镜像]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Go 进行 Jwt 验证]]></title>
    <url>%2F2018%2F01%2F22%2Fgo-jwt%2F</url>
    <content type="text"><![CDATA[对于使用负载均衡的服务器来说,使用 JWT(JSON WEB TOKEN) 是一个更优的选择,session受到单台服务器的限制,一个用户登录过后就只能分配到这一台服务器上,这和负载均衡的初衷不一致啊,而 jwt 就解决了这类的痛点 使用 JWT 的场景 身份验证 用户在登录过后服务器会用 jwt 返回用户可访问的资源,比如权限什么的 传递信息 通过 jwt 的header和signature可以保证payload没有被篡改,保证信息的安全 JWT 的结构JWT 是由header,payload,signature三部分组成的,咱们先用例子说话 header12345&#123; "alg": "HS256", "typ": "JWT"&#125;// base64编码的字符串`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9` 这里规定了加密算法,hash256 payload 123456&#123; "sub": "1234567890", "name": "John Doe", "admin": true&#125;// base64编码的字符串`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9` 这里的内容没有强制要求,因为 paylaod 就是为了承载内容而存在的,不过想用规范的话也可以参考下面的 iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 signature是用 header + payload + secret组合起来加密的,公式是: 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 这里 secret就是自己定义的一个随机字符串,这一个过程只能发生在 server 端,会随机生成一个 hash 值 这样组合起来之后就是一个完整的 jwt 了:1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.4c9540f793ab33b13670169bdf444c1eb1c37047f18e861981e14e34587b1e04 这里有一个用 go 加密和验证 jwt 的 demo 总结选择 jwt 最大的理由: 内容有公钥私钥,可以保证内容的合法性 token 中可以包含很多信息 不过 jwt 不保证的安全问题: 因为header,paylaod是 base64编码,相当于明文可见的,因此不能在payload中放入敏感信息 并不能保证数据传输时会不会被盗用,这一点和 sessionID 一样,因此不要迷信它有多高的安全性.. 为了安全还是要上 https 相关推荐:jwt.io]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>json</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于跨域请求的二三事]]></title>
    <url>%2F2018%2F01%2F16%2Fhttp-cross-domain-etc%2F</url>
    <content type="text"><![CDATA[在前后端分离开发时跨域经常是一个不可回避的问题,这里介绍一个比较简单的办法,前端 vue.js,后端 go 首先要区分简单请求和复杂请求这里阮一峰有详细讲解过一个: 跨域资源共享 CORS 详解 如果你有一种太长不看的想法,就听我给你简单说一下: 简单路由: 指的就是你平时表单提交,ajax 提交,使用GET,POST,HEAD,http 头信息里面没有杂七杂八的东西的请求 复杂请求: 就是除了简单请求之外的请求,比如你在 http 头里有自定义的字段,或者你使用像DELETE,PATCH这样的方法 你会发现复杂请求最明显的变化就是浏览器每次去请求接口的时候会发送两次,这里第一次发送的必定是一个请求方法为OPTIONS的,第二个才是你写的方法,我截图里的就是POST, 第二张截图之所以被判定为复杂请求就是因为我加了一个X-TOKEN这个header,而如果第一次的OPTIONS方法的请求如果失败了也就不会发送第二条信息了,至于为什么,我只能说这是规定 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。——HTTP访问控制（CORS） 对于简单请求和复杂请求的处理(后端)既然叫简单请求处理起来也很简单,下面已经列出代码, 关键就是设置Access-Control-Allow这一些参数就行,复杂请求就是添加一个针对OPTIONS的处理方式,通常情况返回一个空字符串就行至于跨域验证之类的就是八仙过海各显神通了各家有个家的处理方法12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( "flag" "fmt" "net" "net/http")type httpServer struct &#123;&#125;func (s *httpServer) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; // Stop here if its Preflighted OPTIONS request if origin := r.Header.Get("Origin"); origin != "" &#123; w.Header().Set("Access-Control-Allow-Origin", "*") // 限制请求方的域 * 就是不限制 w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE") // 限制请求方式 w.Header().Set("Access-Control-Allow-Headers","Action, Module") //有使用自定义头 需要这个,Action, Module是例子 w.Header().Set("Access-Control-Allow-Headers", "Content-Type,Authorization,X-Token") //允许的header的类型 &#125; // if r.Method == "OPTIONS" &#123; // 针对复杂请求时做出的处理 // return // &#125; w.Write([]byte("hello"))&#125;func main() &#123; addr := flag.String("http-address", "", "") flag.Parse() var h httpServer httpListener, err := net.Listen("tcp", *addr) server := http.Server&#123;Handler: &amp;h,&#125; server.Serve(httpListener) fmt.Println("finish ", err)&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 在 Vue-Cli 中使用 Svg 做 Icon]]></title>
    <url>%2F2017%2F12%2F26%2Fvue-svg-icon%2F</url>
    <content type="text"><![CDATA[之前都是用的image sprite或者使用的 Font Awesome这类的开源库现在咱们已经走进了现代浏览器的年代(ie9+),可以玩点新鲜的东西了,svg svg 有几个好处: 矢量图,不失真 可以受CSS样式影响,就像一个文本 http请求低了 相关阅读: 未来必热：SVG Sprite技术介绍 而对我来说最直观的好处就是可以让设计师给你出一个 svg,而不是自己眼都挑花了去找一个合适的图标:) 做一个 svg-icon 组件在 vue-cli 生成的 vue 脚手架中添加组件1234567891011121314151617181920212223242526272829303132333435363738// path: @/components/SvgIcon/index.vue&lt;template&gt; &lt;svg class="svg-icon" aria-hidden="true"&gt; &lt;use :xlink:href="iconName"&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'icon-svg', props: &#123; iconClass: &#123; type: String, required: true &#125; &#125;, computed: &#123; iconName() &#123; return `#icon-$&#123;this.iconClass&#125;` &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt;作者：花裤衩链接：https://juejin.im/post/59bb864b5188257e7a427c09来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 使用:12345678910111213//引入svg组件import IconSvg from &apos;@/components/IconSvg&apos;//全局注册icon-svgVue.component(&apos;icon-svg&apos;, IconSvg)//在代码中使用&lt;icon-svg icon-class=&quot;password&quot; /&gt;作者：花裤衩链接：https://juejin.im/post/59bb864b5188257e7a427c09来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 现在组件有了,svg 去哪里搞? 使用 svg-sprite-loader这个工具可以把多个 svg 打包成 svg-sprite 为了把 icon 使用的 svg 和其他地方使用的 svg 区分开,我们需要对webpack.base.conf.js中的内容重新设置一下:12345678910111213141516171819202122//path: app-project/build/webpack.base.conf.js ... // [新增]当引用图标 svg 的时候引入指定目录下的文件 &#123; test: /\.svg$/, loader: 'svg-sprite-loader', include: [resolve('src/icons')], options: &#123; symbolId: 'icon-[name]' &#125; &#125;, // [修改]这里 exclude 来忽略常规的 svg 引入 &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', exclude: [resolve('src/icons')], // 这一步必不可少 options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, ... 接下来需要使用 webpack 的require.context函数 require.context(“./test”, false, /.test.js$/);这行代码就会去 test 文件夹（不包含子目录）下面的找所有文件名以 .test.js 结尾的文件能被 require 的文件。更直白的说就是 我们可以通过正则匹配引入相应的文件模块。 为了拆卸方便就把这些都放在了icons目录下123456789101112// path: app-project/src/icons.index.jsimport Vue from 'vue'import SvgIcon from '@/components/SvgIcon'// svg组件// 全局注册组件Vue.component('svg-icon', SvgIcon)// 定义一个加载目录的函数const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context('./svg', false, /\.svg$/)// 加载目录下的所有 svg 文件requireAll(req) 然后只需要在 main.js 文件中引入这个组件就可以了1234// path: app-project/src/main.js...import './icons' // 引入图标文件... 具体代码可以参考 这个地址链接 压缩 svg 内容这里推荐一个比较好用的工具: svgo SVG精简压缩工具svgo简介和初体验 最后这是我抄的 花裤衩的 手摸手，带你优雅的使用 icon,观摩别人的代码给自己带来了很多收获]]></content>
      <categories>
        <category>精选转载</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Chrome 浏览器会强制跳转到 Https 的问题]]></title>
    <url>%2F2017%2F12%2F19%2Fchrome-redirection-https%2F</url>
    <content type="text"><![CDATA[我在本地使用的是 *.app 的域名开发的,某一天发现使用谷歌的时候会强制跳转到 https,改成http都不管用 询问了一下万能的404网站,查询的结果大多是: chrome浏览器地址栏输入：chrome://net-internals/#hsts在该页面中搜索：Query HSTS/PKP domain在其下方的 Domain 后面的输入框中输入自己无法访问的域名，比如：domain.app，点击Query进行查询，如果有类似下面的结果，说明该域名后缀无法使用http前缀。 这样式儿的结果,结果试了以后没有解决都我目前的问题,后来根据这篇文章的描述 Chrome 于 V63 版本起会将 .dev 域名强制转换为 HTTPS说 .dev 的域名就是会强制跳转,看来我用的.app的域名估计也是同样的问题,解决方法也简单.根据 Don’t Use .dev For Development建议使用1234.localhost.invalid.text.example 作为本地开发的模拟域名,如果用的不爽的话,换火狐啊 :)]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sense-HAT Api 文档]]></title>
    <url>%2F2017%2F11%2F30%2FRaspberry-pi3-sense-HAT-api%2F</url>
    <content type="text"><![CDATA[从官方给的 api 文档中硬翻的… LED 模型set_rotation 设置翻转角度这个函数可以设置 led 的旋转角度 参数 类型 可选参数 描述 r Integer 0,90,180,270 0指的是树莓派 HDMI 接口向下的方向 redraw Boolean TRUE,FALSE 默认为 TRUE 示例:12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/pythonimport sysimport timefrom sense_hat import SenseHatX = (255, 0, 0)O = (255, 255, 255)question_mark = [ O, O, O, X, X, O, O, O, O, O, X, O, O, X, O, O, O, O, O, O, O, X, O, O, O, O, O, O, X, O, O, O, O, O, O, X, O, O, O, O, O, O, O, X, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, X, O, O, O, O]sense = SenseHat()sense.set_pixels(question_mark)sense.set_pixel(0, 0, 255, 0, 0)sense.set_pixel(0, 7, 0, 255, 0)sense.set_pixel(7, 0, 0, 0, 255)sense.set_pixel(7, 7, 255, 0, 255)def close_light(): black = [ [0,0,0] ] * 64 sense.set_pixels(black)try: while True: for r in [0, 90, 180, 270]: sense.set_rotation(r) time.sleep(0.3)except KeyboardInterrupt: close_light() print &quot;Good bye&quot; set_pixels 批量设置像素点改变64颗 led 的显示颜色 参数 类型 可选参数 描述 pixel_list List [[R, G, B] * 64] 需要提供 list 长度为64的二维数组, (r,g,b)为三原色的色值 示例参考上一个示例 get_pixels 获取当前像素点数组 返回类型 描述 List 将当前的 led 屏上显示的图像转换成list 示例:12345678910111213141516171819202122#!/usr/bin/pythonfrom sense_hat import SenseHatX = (255, 0, 0)O = (0, 0, 0)question_mark = [ O, X, O, O, O, O, X, O, O, O, X, O, O, X, O, O, O, X, X, X, X, X, X, O, X, X, O, X, X, O, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, O, X, O, O, O, O, X, O, X, O, O, O, O, O, O, X]sense = SenseHat()sense.set_pixels(question_mark)out_list = sense.get_pixels()print out_list 提示:之所以有这个函数是因为传入set_pixels的像素值有时会发生变化,sense HAT 是将每个像素指定为8 位数 (0-255) 但是如果传入 led 的 frameBuffer 中的时候,颜色的位数会转成 RGB565(5位红色,6位绿色和5位蓝色)执行转换的时候可以看到二进制转换时发生的精度损失get_pixels 就是显示像素在缓冲区内结束时的值 set_pixel 设置单点像素颜色通过 x-y 坐标系来定位像素位置,以 HDMI 接口面向的位置为下 参数 类型 可选参数 描述 x Integer 0-7 0为左 7为右 y Integer 0-7 0为上 7为下 当只有三个参数的时候 pixel Tuple / List 0-255 (r, g, b) 数值 当有五个参数的时候 r Integer 0-255 红 g Integer 0-255 绿 b Integer 0-255 蓝 示例:123456789101112131415161718from sense_hat import SenseHatsense = SenseHat()# examples using (x, y, r, g, b)sense.set_pixel(0, 0, 255, 0, 0)sense.set_pixel(0, 7, 0, 255, 0)sense.set_pixel(7, 0, 0, 0, 255)sense.set_pixel(7, 7, 255, 0, 255)red = (255, 0, 0)green = (0, 255, 0)blue = (0, 0, 255)# examples using (x, y, pixel)sense.set_pixel(0, 0, red)sense.set_pixel(0, 0, green)sense.set_pixel(0, 0, blue) get_pixel 获取指定位置的颜色同 get_pixels 不过是单体版的 参数 类型 可选参数 描述 x Integer 0-7 0为左 7为右 y Integer 0-7 0为上 7为下 返回类型 描述 List [R,G,B] 组成的数组 示例:1234from sense_hat import SenseHatsense = SenseHat()top_left_pixel = sense.get_pixel(0, 0) load_image 加载图像到矩阵中加载一个图像文件，将其转换为RGB格式，并在LED矩阵上显示。图像的大小必须是8×8像素。 参数 类型 可选参数 描述 file_path String ... 有效的图片路径 redraw Boolean TRUE/FALSE 是否重绘已加载的图像文件在LED矩阵上。默认值为True 示例:1234from sense_hat import SenseHatsense = SenseHat()sense.load_image(&quot;space_invader.png&quot;) 返回类型 描述 List [[R,G,B] * 64] 组成的数组 1234from sense_hat import SenseHatsense = SenseHat()invader_pixels = sense.load_image(&quot;space_invader.png&quot;, redraw=False) clear 让 led 屏变成纯色,默认是关闭 参数 类型 可选参数 描述 当只有一个参数的时候 pixel Tuple / List 0-255 (r, g, b) 数值,默认为[0,0,0] 当有三个参数的时候 r Integer 0-255 红 g Integer 0-255 绿 b Integer 0-255 蓝 示例:123456789101112from sense_hat import SenseHatfrom time import sleepsense = SenseHat()red = (255, 0, 0)sense.clear() # no arguments defaults to offsleep(1)sense.clear(red) # passing in an RGB tuplesleep(1)sense.clear(255, 255, 255) # passing in r, g and b values of a colour show_message 屏幕显示单个文字就是街头广告灯的那种 led 滚屏啦! 参数 类型 可选参数 描述 text_string String ... 将要滚屏的字母 scroll_speed Float 任意浮点数 滚屏速度,默认 0.1 text_colour List [R,G,B]] 文字颜色,默认[255,255,255] back_colour List [R,G,B]] 背景颜色,默认[0,0,0] 示例: 1234from sense_hat import SenseHatsense = SenseHat()sense.show_message(&quot;One small step for Pi!&quot;, text_colour=[255, 0, 0]) show_letter 单屏显示字母 参数 类型 可选参数 描述 s String ... 将要显示的字母 text_colour List [R,G,B]] 文字颜色,默认[255,255,255] back_colour List [R,G,B]] 背景颜色,默认[0,0,0] 示例:123456789101112#!/usr/bin/pythonimport timefrom sense_hat import SenseHatsense = SenseHat()letters = &quot;ABCDEFGHIJKLMNOPQRSTUVWSYZ&quot;for i in letters: sense.show_letter(str(i)) time.sleep(1) low_light 调低亮度如果觉得亮度有点刺眼的话可以开低亮度模式12345678import timefrom sense_hat import SenseHatsense = SenseHat()sense.clear(255, 255, 255)sense.low_light = Truetime.sleep(2)sense.low_light = False 1234567891011121314151617181920212223#!/usr/bin/pythonimport timefrom sense_hat import SenseHatsense = SenseHat()sense.clear(255, 127, 0)sense.set_pixels(question_mark)print(sense.gamma)time.sleep(2)old = sense.gammasense.gamma = old[::-1]print(sense.gamma)time.sleep(2)sense.low_light = Trueprint(sense.gamma)time.sleep(2)sense.low_light = False gammaFor advanced users. Most users will just need the low_light Boolean property above. The Sense HAT python API uses 8 bit (0 to 255) colours for R, G, B. When these are written to the Linux frame buffer they’re bit shifted into RGB 5 6 5. The driver then converts them to RGB 5 5 5 before it passes them over to the ATTiny88 AVR for writing to the LEDs.The gamma property allows you to specify a gamma lookup table for the final 5 bits of colour used. The lookup table is a list of 32 numbers that must be between 0 and 31. The value of the incoming 5 bit colour is used to index the lookup table and the value found at that position is then written to the LEDs. 对于高级用户。大多数用户只需要上面的low_light布尔属性。这个感觉帽python API使用8位(0到255)的颜色为R,G,b。当这些被写入Linux框架缓冲区时，它们被位转换为RGB 5 6 5。然后，驱动程序将它们转换为RGB 5 5 5，然后将其传递给ATTiny88 AVR以写入led。gamma属性允许您为使用的最后5位颜色指定一个伽马查找表。查找表是32个数字的列表，它们必须在0到31之间。传入的5位颜色的值用于索引查找表，然后将该位置上发现的值写入led。—来自有道词典,因为暂时不知道用在哪里 类型 可选参数 描述 List 长度为32的元组或列表，包含0到31之间的整数 最后的5位颜色的查找表 示例:123456789101112131415161718import timefrom sense_hat import SenseHatsense = SenseHat()sense.clear(255, 127, 0)print(sense.gamma)time.sleep(2)sense.gamma = sense.gamma[::-1]print(sense.gamma)time.sleep(2)sense.low_light = Trueprint(sense.gamma)time.sleep(2)sense.low_light = False gamma_reset一个函数将gamma查找表重置为默认值，理想情况下，如果您已经对它进行了处理，并希望将它恢复到默认状态。示例:123456789import timefrom sense_hat import SenseHatsense = SenseHat()sense.clear(255, 127, 0)time.sleep(2)sense.gamma = [0] * 32 # Will turn the LED matrix offtime.sleep(2)sense.gamma_reset() 环境感应器get_humidity 湿度 返回类型 描述 Float 湿度的百分数 示例:123456789#!/usr/bin/pythonfrom sense_hat import SenseHatsense = SenseHat()humidity = sense.get_humidity()print(&quot;Humidity: %s %%rH&quot; % humidity) #Humidity: 13.8048038483 %rH# 同样效果print(sense.humidity) #14.9011135101 get_temperature 温度返回值也是浮点数示例:12345678910#!/usr/bin/pythonfrom sense_hat import SenseHatsense = SenseHat()temp = sense.get_temperature()print(&quot;Temperature: %s C&quot; % temp) # Temperature: 33.0 C# alternativesprint(sense.temp) # 33.0print(sense.temperature) # 33.0 get_temperature_from_humidity 温度从湿度传感器获取当前温度(摄氏度)。示例:12345from sense_hat import SenseHatsense = SenseHat()temp = sense.get_temperature_from_humidity()print(&quot;Temperature: %s C&quot; % temp) get_temperature_from_pressure 温度从压力传感器获取温度12345from sense_hat import SenseHatsense = SenseHat()temp = sense.get_temperature_from_pressure()print(&quot;Temperature: %s C&quot; % temp) get_pressure 压力获取压力参数 ps: 1Bar=0.1MPa=1000mba=1000hpa=100*7.5mmhg=75mmhg=1个大气压 返回类型 描述 Float 单位为Millibars 示例:12345678from sense_hat import SenseHatsense = SenseHat()pressure = sense.get_pressure()print(&quot;Pressure: %s Millibars&quot; % pressure) #Pressure: 1024.56738281 Millibars# 同理print(sense.pressure) # 1024.56738281 IMU Sensor 惯性测量单元IMU(inertial measurement unit)传感器是三个传感器的组合，每个传感器分别有x、y和z轴。由于这个原因，它被认为是一个9自由度的传感器。 陀螺仪(Gyroscope) 加速度计(Accelerometer) 指南针(Magnetometer)这个API允许你在任何组合中使用这些传感器来测量方向或单独的传感器。 set_imu_config支持或禁用陀螺仪、加速度计和/或磁强计 参数 类型 可选参数 描述 compass_enabled Boolean TRUE,FALSE 是否启用指南针 gyro_enabled Boolean TRUE,FALSE 是否启用陀螺仪 accel_enabled Boolean TRUE,FALSE 是否启用加速度计 示例:1234from sense_hat import SenseHatsense = SenseHat()sense.set_imu_config(False, True, False) # 只开启陀螺仪 get_orientation_radians获取当前方向弧度,依据飞行器轴参数的 pitch, roll 和 yaw.理解传说中的roll、yaw、pitch欧拉角 返回类型 描述 Dictionary 由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴弧度 示例:12345678from sense_hat import SenseHatsense = SenseHat()orientation_rad = sense.get_orientation_radians()print(&quot;p: &#123;pitch&#125;, r: &#123;roll&#125;, y: &#123;yaw&#125;&quot;.format(**orientation_rad)) # p: 0.0906969159842, r: -0.218863099813, y: 2.87161874771# alternativesprint(sense.orientation_radians) # &#123;&apos;yaw&apos;: 2.933598041534424, &apos;roll&apos;: -0.20759552717208862, &apos;pitch&apos;: 0.09733205288648605&#125; get_orientation_degrees以俯仰、翻滚和偏航的飞机主轴得到当前的方向。 返回类型 描述 Dictionary 由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴角度 示例:12345from sense_hat import SenseHatsense = SenseHat()orientation = sense.get_orientation_degrees()print(&quot;p: &#123;pitch&#125;, r: &#123;roll&#125;, y: &#123;yaw&#125;&quot;.format(**orientation)) # p: 359.368855623, r: 359.958133745, y: 24.4292643968 get_orientation作用同get_orientation_degrees 123456from sense_hat import SenseHatsense = SenseHat()orientation = sense.get_orientation()print(sense.orientation) # &#123;&apos;yaw&apos;: 20.334569404489745, &apos;roll&apos;: 0.02406978340326997, &apos;pitch&apos;: 359.2895215347403&#125; get_compass调用罗盘时会预先调用set_imu_config禁止掉重力计和加速度计的功能 12345678from sense_hat import SenseHatsense = SenseHat()north = sense.get_compass()print(&quot;North: %s&quot; % north) # North: 351.031626941# alternativesprint(sense.compass) # 351.031626941 get_compass_raw获取原始x、y和z轴的磁强计数据。 返回类型 描述 Dictionary 字典对象索引的字符串x,y和z。表示磁场强度的值浮动轴的microteslas(µT)。 12345678from sense_hat import SenseHatsense = SenseHat()raw = sense.get_compass_raw()print(&quot;x: &#123;x&#125;, y: &#123;y&#125;, z: &#123;z&#125;&quot;.format(**raw)) # x: 3.14855718613, y: 0.269534498453, z: -0.743863344193# alternativesprint(sense.compass_raw) # &#123;&apos;y&apos;: 0.4851621091365814, &apos;x&apos;: 5.667402744293213, &apos;z&apos;: -1.338953971862793&#125; get_gyroscope调用set_imu_config来禁用磁强计和加速计，然后只从陀螺仪获取当前方向。 返回类型 描述 Dictionary 由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴角度 123456789from sense_hat import SenseHatsense = SenseHat()gyro_only = sense.get_gyroscope()print(&quot;p: &#123;pitch&#125;, r: &#123;roll&#125;, y: &#123;yaw&#125;&quot;.format(**gyro_only))# alternativesprint(sense.gyro) # &#123;&apos;yaw&apos;: 0.0604013305118731, &apos;roll&apos;: 359.9494321175156, &apos;pitch&apos;: 359.9567423509234&#125;print(sense.gyroscope) # &#123;&apos;yaw&apos;: 0.0604013305118731, &apos;roll&apos;: 359.9494321175156, &apos;pitch&apos;: 359.9567423509234&#125; get_gyroscope_raw获取原始x、y和z轴的陀螺仪数据。 返回类型 描述 Dictionary 一个由字符串x、y和z索引的字典对象。这些值是按每秒弧度表示轴的旋转强度的浮点数。 1234567891011121314from sense_hat import SenseHatsense = SenseHat()raw = sense.get_gyroscope_raw()print(&quot;x: &#123;x&#125;, y: &#123;y&#125;, z: &#123;z&#125;&quot;.format(**raw))# alternativesprint(sense.gyro_raw)print(sense.gyroscope_raw)# x: 1.03765261173, y: 2.46352291107, z: 0.185390725732# &#123;&apos;y&apos;: 1.5728815793991089, &apos;x&apos;: 0.34309887886047363, &apos;z&apos;: 0.2984008193016052&#125;# &#123;&apos;y&apos;: 0.8343454599380493, &apos;x&apos;: 0.163504496216774, &apos;z&apos;: 0.4767734408378601&#125; get_accelerometer调用set_imu_config来禁用磁力仪和陀螺仪，然后从加速度计得到当前的方向。 返回类型 描述 Dictionary 由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴角度 1234567891011121314from sense_hat import SenseHatsense = SenseHat()accel_only = sense.get_accelerometer()print(&quot;p: &#123;pitch&#125;, r: &#123;roll&#125;, y: &#123;yaw&#125;&quot;.format(**accel_only))# alternativesprint(sense.accel)print(sense.accelerometer)# p: 3.76471788135, r: 10.0814548376, y: 0.0# &#123;&apos;yaw&apos;: 4.5454772552392335e-07, &apos;roll&apos;: 10.082596332952239, &apos;pitch&apos;: 3.7639588765826475&#125;# &#123;&apos;yaw&apos;: 4.5454772552392335e-07, &apos;roll&apos;: 10.082596332952239, &apos;pitch&apos;: 3.7639588765826475&#125; get_accelerometer_raw获取原始x、y和z轴加速度计数据。 返回类型 描述 Dictionary 一个由字符串x、y和z索引的字典对象。这些值代表了在Gs中轴的加速度强度。 12345678910111213from sense_hat import SenseHatsense = SenseHat()raw = sense.get_accelerometer_raw()print(&quot;x: &#123;x&#125;, y: &#123;y&#125;, z: &#123;z&#125;&quot;.format(**raw))# alternativesprint(sense.accel_raw)print(sense.accelerometer_raw)# x: -0.0634367614985, y: 0.172625526786, z: 0.974787354469# &#123;&apos;y&apos;: 0.1738394945859909, &apos;x&apos;: -0.06516461074352264, &apos;z&apos;: 0.9757621884346008&#125;# &#123;&apos;y&apos;: 0.17286831140518188, &apos;x&apos;: -0.06565827876329422, &apos;z&apos;: 0.9735689163208008&#125; Joystick 操纵杆操纵事件描述操纵杆事件的元组。包含三个命名参数: 时间戳—事件发生的时间，作为秒数(与内置时间函数相同的格式) 方向-操纵杆移动的方向，作为一个字符串(“向上”，“向下”，“左”，“右”，“中间”) 动作—发生的动作，作为一个字符串(“按压”，“释放”，“持有”) 这个tuple类型被一些joystick方法使用，要么作为返回类型，要么是参数的类型。 wait_for_event在发生joystick事件之前阻止执行，然后返回一个表示发生的事件的InputEvent。123456789from sense_hat import SenseHatfrom time import sleepsense = SenseHat()event = sense.stick.wait_for_event()print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction))sleep(0.1)event = sense.stick.wait_for_event()print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction)) 在上面的例子中，如果你将操纵杆简单地推到一个单一的方向，你就会看到两个事件输出:一个被压的动作和一个释放的动作。可选的emptybuffer可以用于在等待新事件之前刷新任何未决事件。试试下面的脚本，看看有什么不同:123456789from sense_hat import SenseHatfrom time import sleepsense = SenseHat()event = sense.stick.wait_for_event()print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction))sleep(0.1)event = sense.stick.wait_for_event(emptybuffer=True)print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction)) get_events返回自最后一次调用get_events或wait_for_event之后发生的所有事件的InputEvent tuple的列表。123456from sense_hat import SenseHatsense = SenseHat()while True: for event in sense.stick.get_events(): print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction)) direction_up, direction_left, direction_right, direction_down, direction_middle, direction_any这些属性可以被分配一个函数，当操纵杆按在相关的方向(或者在direction_any的任何方向上)时，它就会被调用。分配的函数要么不接受参数，要么必须接受一个参数，该参数将传递给相关的InputEvent。1234567891011121314151617181920212223242526272829303132333435363738394041from sense_hat import SenseHat, ACTION_PRESSED, ACTION_HELD, ACTION_RELEASEDfrom signal import pausex = 3y = 3sense = SenseHat()def clamp(value, min_value=0, max_value=7): return min(max_value, max(min_value, value))def pushed_up(event): global y if event.action != ACTION_RELEASED: y = clamp(y - 1)def pushed_down(event): global y if event.action != ACTION_RELEASED: y = clamp(y + 1)def pushed_left(event): global x if event.action != ACTION_RELEASED: x = clamp(x - 1)def pushed_right(event): global x if event.action != ACTION_RELEASED: x = clamp(x + 1)def refresh(): sense.clear() sense.set_pixel(x, y, 255, 255, 255)sense.stick.direction_up = pushed_upsense.stick.direction_down = pushed_downsense.stick.direction_left = pushed_leftsense.stick.direction_right = pushed_rightsense.stick.direction_any = refreshrefresh()pause() 相关资料 博客原文api 原文树莓派+senseHAT 的一个入门项目来自官方的 astro-pi 简介]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派3安装 Sense HAT]]></title>
    <url>%2F2017%2F11%2F29%2FRaspberry-pi3-install-sense-HAT%2F</url>
    <content type="text"><![CDATA[因为感觉各种感应器的 GPIO 有点乱,干脆买了一个官方提供的集成板来玩,这样看着也整体一些… 英文不错的同学出门右转: 官方提供的一个说明一个 sense-hat 的接口文档各感应模块的针脚示意图 更新系统(Rasbian)1$ sudo apt update &amp;&amp; sudo apt upgrade -y 可能得等一大会儿…. 安装扩展模块12$ sudo apt-get install sense-hat$ sudo reboot 运行一个 demo, 官方提供的一些 demo 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/pythonimport timefrom sense_hat import SenseHatsense = SenseHat()r = 255g = 0b = 0msleep = lambda x: time.sleep(x / 1000.0)def next_colour(): global r global g global b if (r == 255 and g &lt; 255 and b == 0): g += 1 if (g == 255 and r &gt; 0 and b == 0): r -= 1 if (g == 255 and b &lt; 255 and r == 0): b += 1 if (b == 255 and g &gt; 0 and r == 0): g -= 1 if (b == 255 and r &lt; 255 and g == 0): r += 1 if (r == 255 and b &gt; 0 and g == 0): b -= 1while True: sense.clear([r, g, b]) msleep(2) next_colour() 如果运行是出现下列报错的话:1234567Traceback (most recent call last): File &quot;demo1.py&quot;, line 38, in &lt;module&gt; sense.clear([r, g, b]) File &quot;/usr/lib/python2.7/dist-packages/sense_hat/sense_hat.py&quot;, line 413, in clear self.set_pixels([colour] * 64) File &quot;/usr/lib/python2.7/dist-packages/sense_hat/sense_hat.py&quot;, line 294, in set_pixels f.seek(map[index // 8][index % 8] * 2) # row, column 还是比较好解决的,更改配置就行12345$ sudo vi /boot/config.txt//找到 dtoverlay 这一行修改成dtoverlay=rpi-sense//然后 wq 退出$ sudo reboot 这是我第一次安装时碰到的问题 解决方案来源]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派的一些报错问题]]></title>
    <url>%2F2017%2F11%2F28%2FRaspberry-pi3-local-lang%2F</url>
    <content type="text"><![CDATA[树莓派出现本地语言出现问题123456789101112perl: warning: Setting locale failed.perl: warning: Please check that your locale settings: LANGUAGE = "en_US.UTF-8", LC_ALL = "en_US.UTF-8", LC_CTYPE = "zh_CN.UTF-8", LANG = "en_US.UTF-8" are supported and installed on your system.perl: warning: Falling back to the standard locale ("C").locale: Cannot set LC_CTYPE to default locale: No such file or directorylocale: Cannot set LC_MESSAGES to default locale: No such file or directorylocale: Cannot set LC_ALL to default locale: No such file or directory/usr/sbin/dpkg-reconfigure must be run as root 解决方法其实已经给出运行命令:1sudo dpkg-reconfigure locales 设置 utf8 就行]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派上安装 Golang]]></title>
    <url>%2F2017%2F11%2F22%2FRaspberry-Pi3-golang-env%2F</url>
    <content type="text"><![CDATA[树莓派上需要进行编译安装,不过很简单,而且 golang 官方也有 arm 平台的编译包,在树莓派上一定要选linux-armv61这个版本啊 golang 各版本的下载列表 $ 开头的都是在命令行中输入123456789101112131415$ wget https://redirector.gvt1.com/edgedl/go/go1.9.2.linux-armv6l.tar.gz$ tar -C /usr/local -zvxf go1.8.3.linux-armv6l.tar.gz$cd / &amp;&amp; mkdir -p /data/www/go$ sudo vim /etc/profile# 在文件末尾添加如下内容export PATH=$PATH:/usr/local/go/bin# 添加如下设置项export GOROOT=/usr/local/goexport GOPATH=/data/www/goexport PATH=$GOROOT/bin:$PATH//保存退出后让环境变量立即生效$ source /etc/profile$ go version]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用树莓派3搞一个信号灯输出]]></title>
    <url>%2F2017%2F11%2F21%2FRaspberry-Pi3-traffic-light%2F</url>
    <content type="text"><![CDATA[通过一个python脚本跑一个监控 cpu 的交通信号灯,运行环境是官方的系统 Raspbian 执行脚本有编程基础的同学就直接上手好了: 123456789101112131415161718192021222324252627282930313233343536373839#! /usr/bin/env python# to use with Pi Traffic Lightimport RPi.GPIO as GPIOimport psutilGREEN = 13YELLOW = 19RED = 26# Pin Setup:GPIO.setmode(GPIO.BCM) # Broadcom pin-numbering scheme.GPIO.setwarnings(False)GPIO.setup(GREEN, GPIO.OUT)GPIO.setup(YELLOW, GPIO.OUT)GPIO.setup(RED, GPIO.OUT)try: while (1): cpu_pc = psutil.cpu_percent(interval=2) print 'CPU: %d%%' % (cpu_pc) if cpu_pc &lt;= 50: GPIO.output(RED, False) GPIO.output(YELLOW, False) GPIO.output(GREEN, True) if 50 &lt; cpu_pc &lt; 90: GPIO.output(GREEN, False) GPIO.output(RED, False) GPIO.output(YELLOW, True) if cpu_pc &gt;=90 : GPIO.output(GREEN, False) GPIO.output(YELLOW, False) GPIO.output(RED, True)except KeyboardInterrupt: print "Good bye" GPIO.output(GREEN, False) GPIO.output(YELLOW, False) GPIO.output(RED, False) GPIO.cleanup() 如果出现提示****line 5, in &lt;module&gt; import psutil***** 提示缺少psutil模块,就按照下面的方法安装: 代码原文 123wget https://pypi.python.org/packages/source/p/psutil/psutil-3.2.2.tar.gzcd psutil-3.2.2python setup.py install 如果报错检查 gcc,python-devel 是否安装(官方系统的话会把这些环境默认安装好,不用管的) 针脚怎么插?软件方面的搞定了,接下来需要搞明白怎么配置硬件了,这是树莓派系列的针脚图(咱们这是3代,最右边的那个):我又从网上找的一张实物图这是我淘来的信号灯这两个都是针脚型的,但是我有一个40针脚的扁平线可以用来对接,按照信号灯指定的端口插就行 插好以后就直接运行脚本就行比如这个脚本叫做 traffic.py,就运行1$ python ./traffic.py 就能看到效果 代码都做了什么? 引入需要用到的模块, RPi.GPIO针脚输出,psutil用于系统监控 12345#! /usr/bin/env python# to use with Pi Traffic Lightimport RPi.GPIO as GPIOimport psutil 定义三个灯输出的针脚 123GREEN = 13YELLOW = 19RED = 26 对指定的针脚进行设置 123456# Pin Setup:GPIO.setmode(GPIO.BCM) GPIO.setwarnings(False)GPIO.setup(GREEN, GPIO.OUT)GPIO.setup(YELLOW, GPIO.OUT)GPIO.setup(RED, GPIO.OUT) 这里的 GPIO.setmode(GPIO.BCM)就是指定了输出模式为按照信道编号,就是上图中的GPIO2,GPIO3...这类如果GPIO.setmode(GPIO.BOARD)就是Pin No.1 =&gt; GPIO1,使用物理针脚的编号作为输出信道 GPIO.setwarnings(False) 关闭warning 提示 GPIO.setup(GREEN, GPIO.OUT) 将对应的信道设置为输出信道 通过 while 循环检索 cpu 的使用情况并输出,且根据所占百分比显示相应的灯 123456789101112131415while (1): cpu_pc = psutil.cpu_percent(interval=2) print 'CPU: %d%%' % (cpu_pc) if cpu_pc &lt;= 50: GPIO.output(RED, False) GPIO.output(YELLOW, False) GPIO.output(GREEN, True) if 50 &lt; cpu_pc &lt; 90: GPIO.output(GREEN, False) GPIO.output(RED, False) GPIO.output(YELLOW, True) if cpu_pc &gt;=90 : GPIO.output(GREEN, False) GPIO.output(YELLOW, False) GPIO.output(RED, True) GPIO.output(GREEN, False)和GPIO.output(GREEN, True)猜都能猜到是控制输出的啦 对于程序退出的操作:把灯全关了,再调用GPIO.cleanup()释放资源 12345678910try: // some code....except KeyboardInterrupt: print "Good bye" GPIO.output(GREEN, False) GPIO.output(YELLOW, False) GPIO.output(RED, False) GPIO.cleanup() 总结这个 demo 只是对 GPIO 的输出进行展示,还没涉及到信号输入,接下来如果有空的话我会做一个输入的 demo 相关-极客大讲堂：手把手教你用树莓派控制红绿灯]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 烧录树莓派系统(新手版)]]></title>
    <url>%2F2017%2F11%2F21%2FRaspberry-Pi3-install%2F</url>
    <content type="text"><![CDATA[怎么在 mac 上给 TF 卡烧录一个树莓派系统(为什么没有 win 的?因为 win 上的烧录软件很好用啊!混蛋!) 下载树莓派镜像首先需要下载个系统镜像 官方镜像列表 RASPBIAN :这是树莓派为自己定制的系统,基于 Debian,原生支持最好,新手强烈推荐桌面版的 UBUNTU MATE :ubuntu 的 mate 版本,习惯使用 ubuntu 的选这个 SNAPPY UBUNTU CORE :仅包含 ubuntu 16.04 内核的版本,如果做 IoT 的据说用这个很不错,但是如果做网络服务器不咋好用其他的比如 WIN10 的这种有需要的自取 格式化 TF 卡先用读卡机器插到 mac 上,用系统自带的 磁盘工具 格式化一下 tf 卡,选择抹掉,格式为MS-DOS(FAT),名字随便,写完系统就没用了 打开 终端 使用df名称查看当前已挂载的卷1234567$ dfFilesystem 512-blocks Used Available Capacity iused ifree %iused Mounted on/dev/disk1 233269248 218788512 13968736 94% 27412562 1746092 94% /devfs 374 374 0 100% 648 0 100% /devmap -hosts 0 0 0 100% 0 0 100% /netmap auto_home 0 0 0 100% 0 0 100% /home/dev/disk2s1 31100416 4992 31095424 1% 0 0 100% /Volumes/Pi 基本商最后一行就是你的 tf 卡,/Volumes/Pi 这个 Pi 就是刚才格式化 tf 卡的时候输入的名字 使用diskutil unmount卸载12$ diskutil unmount /dev/disk2s1Volume Pi on disk2s1 unmounted diskutil list 确认设备,这里是 16G 的卡12345$ diskutil list/dev/disk2 #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *15.9 GB disk2 1: DOS_FAT_32 Pi 15.9 GB disk2s1 进入你下载好镜像文件的目录下,使用 dd 命令将镜像写入 PS /dev/disk2s1是分区，/dev/disk2是块设备，/dev/rdisk2是原始字符设备 1234$ dd bs=4m if=2017-09-07-raspbian-stretch.img of=/dev/rdisk2781+1 records in781+1 records out3276800000 bytes transferred in 194.134151 secs (16879050 bytes/sec) if后是镜像的地址,如果是当前目录地址的话直接输入文件名就行, of就是要写入的设备,执行的时候会感觉卡一会,大概30s,正常现象这时候这张 tf 卡就算是烧录好系统了,插到派上启动就行 这个时候你需要鼠标,键盘,有 hdmi 的显示器,插上 pi 就能启动了,可以在左上角菜单中preference中进行各种设置了,在界面可以很方便的设置 wifi使用网线插入路由器的话,可以在路由器的管理界面中找到设备名,默认设备名为raspberry进行 ssh 链接,用户命是 pi,密码 raspberry,或者你自己设置的1ssh pi@192.168.66.207 转载原文]]></content>
      <categories>
        <category>精选转载</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Json移除非法 Utf8字符串]]></title>
    <url>%2F2017%2F11%2F08%2Fphp-json-error%2F</url>
    <content type="text"><![CDATA[当 json_decode 解析为 null 的时候怎么处理 当 json 中出现非法 utf8 时怎么处理 失败时返回NULL当返回 null 的时候,可以用json_last_error()根据返回码来判断 如果 php 版本过低的话将会出现错误码反馈不全的问题,返回值是JSON_ERROR_NONE (0)这是示例:123456789101112131415161718 // $json = '&#123;"a":1,"b":2,"c":3,"d":4,"e":5, "name":"Corwien"&#125;';$json = '&#123;"a":1,"b":2,"c":3,"d":4,"e":5, "name":&#125;'; //错误的json格式$result = json_decode($json, true); if(!$result) &#123; //error handle ,错误处理 $ret = json_last_error(); print_r($ret); //打印为： 4,查错误信息表，可知是语法错误 &#125; json_last_error错误msg对照表：0 = JSON_ERROR_NONE1 = JSON_ERROR_DEPTH2 = JSON_ERROR_STATE_MISMATCH3 = JSON_ERROR_CTRL_CHAR4 = JSON_ERROR_SYNTAX5 = JSON_ERROR_UTF8 如何处理json中的非法utf8字符如果出现 JSON_ERROR_SYNTAX 这个错误码的时候,常见的要么是其中的双引号单引号问题,要么是出现了 /r/n之类的结尾问题,还有一种比较烦的情况就是错误的 utf8编码 解决问题:1234567891011//reject overly long 2 byte sequences, as well as characters above U+10000 and replace with ?$some_string = preg_replace('/[\x00-\x08\x10\x0B\x0C\x0E-\x19\x7F]'. '|[\x00-\x7F][\x80-\xBF]+'. '|([\xC0\xC1]|[\xF0-\xFF])[\x80-\xBF]*'. '|[\xC2-\xDF]((?![\x80-\xBF])|[\x80-\xBF]&#123;2,&#125;)'. '|[\xE0-\xEF](([\x80-\xBF](?![\x80-\xBF]))|(?![\x80-\xBF]&#123;2&#125;)|[\x80-\xBF]&#123;3,&#125;)/S', '?', $some_string );//reject overly long 3 byte sequences and UTF-16 surrogates and replace with ?$some_string = preg_replace('/\xE0[\x80-\x9F][\x80-\xBF]'. '|\xED[\xA0-\xBF][\x80-\xBF]/S','?', $some_string ); 原文utf8代码]]></content>
      <categories>
        <category>精选转载</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js Promise 对象]]></title>
    <url>%2F2017%2F10%2F31%2Fjs-promise%2F</url>
    <content type="text"><![CDATA[我们本次要了解一下 es6 中的 Promise 对象 then()在 ES6 中函数有一个很明显的区别就是一些异步函数中不再是使用回调函数callback(),而是then()方法来进行回调后的处理,这里then()就是我们今天要说的Promise()对象所包含的方法举个例子:使用回调函数:1234567891011121314151617181920function successCallback(result) &#123; console.log("It succeeded with " + result);&#125;function failureCallback(error) &#123; console.log("It failed with " + error);&#125;function doSomething(success,error)&#123; let num = Math.random() * 10; console.log('result is :' + num); if(num &gt; 5)&#123; success('yes'); &#125;else&#123; error('no') &#125;&#125;doSomething(successCallback, failureCallback); 使用 Promise 对象:12345678910111213141516171819202122function successCallback(result) &#123; console.log("It succeeded with " + result);&#125;function failureCallback(error) &#123; console.log("It failed with " + error);&#125;function doSomething(standard)&#123; return new Promise((resolve,reject) =&gt; &#123; let num = Math.random() * 10; console.log('result is :' + num); if(num &gt; standard)&#123; resolve('yes'); &#125;else&#123; reject('no') &#125; &#125;)&#125;doSomething(5).then(successCallback).catch(failureCallback); resolve 和 reject 这两个函数是系统提供的内置函数,负责改变Promise的状态这样的写法和之前没什么大变化,但是代码的表达方式更清晰了,而不是在一层层的 callback 中寻找执行的节点, then()方法也可以有第二个参数,第二个参数代表着失败时要执行的函数,以上面的例子来说:1doSomething(5).then(successCallback,failureCallback); 这样写也是没差,但是使用 catch() 我感觉是一种更优的选择,原因我后面再说 这里是一个图片异步加载的例子:1234567891011121314151617181920212223242526272829303132333435&lt;div id="content"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; let url = 'http://wx3.sinaimg.cn/thumb150/9ccb8305ly1fd09eeednzg208q07wh0l.gif'; loadImageAsync(url).then(function(res)&#123; let content = document.getElementById('content'); content.appendChild(res); &#125;).catch(function(error)&#123; let content = document.getElementById('content'); content.innerHTML = error; &#125;); function loadImageAsync(url)&#123; return new Promise(function(resolve,reject)&#123; var image = new Image(); image.onload = function()&#123; console.log('图片已加载'); resolve(image); &#125; image.onerror = function()&#123; console.log('图片加载失败'); reject(new Error('load image :' + url + ' false')) &#125; console.log('加载图片'); image.src = url; &#125;) &#125;&lt;/script&gt; 接下来是一个实现了 ajax 请求的例子:12345678910111213141516171819202122232425262728293031323334353637//这里.then()中可以返回一个全新的 Promise 对象,从而可以链式调用getMethod("/test.json").then(function(response)&#123; console.log("收到json1",response); return getMethod("/test.json");&#125;).then(function(response)&#123; console.log("收到json2",response);&#125;).catch(function(error)&#123; console.error("请求错误",error);&#125;);function getMethod(url)&#123; var promise = new Promise(function(resolve,reject)&#123; var client = new XMLHttpRequest(); client.open("GET",url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept","application/json"); client.send(); function handler()&#123; if(this.readyState !== 4)&#123; return; &#125; if(this.status === 200)&#123; resolve(this.response); &#125;else&#123; reject(new Error(this.statusText)); &#125; &#125; &#125;) return promise&#125; axios也是支持 promise 的 API,它的解耦做的很不错,看它的源码也给我带来了很大的收获 当运行完这三个例子以后现在可以对 Promise 对象有一个大体的印象: Promise 中有两个自带的函数resolve和reject,分别代表该对象成功和失败两个结果需要处理的状态 在 Promise 中,只有三种状态Pending,Resolved,Rejected,而且同一时间只会出于一种状态中 Promise 中的状态改变不可逆,一旦发生就不能再修改 在 Promise 中的 resolve(param) 中的参数将传到 catch(resolve[,reject])中,reject(param)同理 then()代表着 Promise 的回调处理,而且返回一个新的 promise 对象,和原来的不是同一个 catch()还是刚才 ajax 的运行例子,不过这次我们修改点东西123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var allow = false;function getMethod(url)&#123; var promise = new Promise(function(resolve,reject)&#123; if(allow)&#123; console.log('第二次执行'); allow = !allow; reject("第二次执行被拒"); &#125;else &#123; console.log('第一次执行'); allow = !allow; reject("第一次执行被拒"); &#125; var client = new XMLHttpRequest(); client.open("GET",url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept","application/json"); client.send(); function handler()&#123; if(this.readyState !== 4)&#123; return; &#125; if(this.status === 200)&#123; resolve(this.response); &#125;else&#123; reject(new Error(this.statusText)); &#125; &#125; &#125;) return promise&#125;getMethod("/test.json").then(function(response)&#123; console.log("收到json1",response); return getMethod("/test.json");&#125;).then(function(response)&#123; console.log("收到json2",response);&#125;).catch(function(error)&#123; console.log("请求错误",error);&#125;); 通过一个变量来控制是否进行 ajax 请求 从这个例子我们可以看出来reject抛出的错误是有冒泡性质的,可以统一通过最后的.catch()一起捕获,这也是为什么我刚才说不推荐在then(reslve,reject)中使用错误的回调处理,集中在最后的catch()中进行处理这样也让代码看起来更直白一点]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Vultr来搭建梯子]]></title>
    <url>%2F2017%2F09%2F20%2Fvultr-shadowsocks%2F</url>
    <content type="text"><![CDATA[因为坑爹的GFW某些问题,导致一些浏览器的默认搜索长期404,为了解决这个问题之前试过lantern也试过一些 vpn,但是都不好用啊,vpn 要面对商家跑路的危险(和去理发店找 tony 老师办卡一样),lantern虽然好用但是免费版有流量限制,只能自己动手丰衣足食了 首先选一个国外的服务器国内的服务厂商就不用想了,哪怕是有国外的服务器也是死贵死贵的,然后如果没有办过 aws 的话,这个是最佳 选择,因为初次注册并绑定信用卡就能免费使用一年的 vps,用来做 shadowsocks 服务器完全没问题啊!具体开那个服务器其实都是那一套流程了,现在进入主题:买一个 vultr服务器. 我认为 vultr 的优势 国外服务器,可以做翻墙用 价格便宜,每月最低2.5$,丰俭由人,计价方式是按小时计费哟! 如果是个人使用有用不完的流量(1T+) 主要是我还想用它做网站服务器,配置和价格比国内有强 去官网注册一个账户就可以开始选择服务器了,配置选东京服务器&gt;centos7&gt;1cpu&amp;1GMery&amp;1TBandwidth,点完这三项就什么都不用点了, deploy now 这时应该是有一个ip,一个密码了,可以登录服务器了如果你是 windows 环境,下载一个 xshell如果你是 macOS 就用终端或者 item2接下来的操作两个平台都是一样的,就是用 ssh 去链接远程服务器比如你的 ip 是120.0.0.11ssh root@120.0.0.1 回车后输入密码就能登录上去了 在服务器搭建 shadowsocks 最简单的就是通过脚本搭建,按以下命令 1234567891011# 下载脚本wget -O ss.sh http://zhangdanyang.com/file/ss.sh# 执行脚本bash ss.sh# 设置端口号并回车，直接回车是设置为1225Please enter PORT(1225 default):# 设置密码并回车，直接回车是设置为123456Please enter PASSWORD(123456 default):# 等待一会……就完成了（初次执行约2-5min） 脚本源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#! /bin/bash# log路径export log_path=/etc/ss.log# 设置端口号echo -n -e &apos;\033[36mPlease enter PORT(1225 default): \033[0m&apos;# echo -n &quot;please enter port(1225 default):&quot;read portif [ ! -n &quot;$port&quot; ];then echo &quot;port will be set to 1225&quot; port=1225else echo &quot;port will be set to $port&quot;fi# 设置密码echo -n -e &apos;\033[36mPlease enter PASSWORD(123456 default): \033[0m&apos;# echo -n &quot;please enter password(123456 default):&quot;read pwdif [ ! -n &quot;$pwd&quot; ];then echo &quot;password will be set to 123456&quot; pwd=123456else echo &quot;password will be set to $pwd&quot;fi# 写shadowsocks.json配置文件cat&gt;/etc/shadowsocks.json&lt;&lt;EOF&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:$port, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;$pwd&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125;EOF# 安装 shadowsocks 防火墙等ret=`yum install -y m2crypto python-setuptools &gt;&gt; $&#123;log_path&#125; 2&gt;&amp;1`ret=`easy_install pip &gt;&gt; $&#123;log_path&#125; 2&gt;&amp;1`ret=`pip install shadowsocks &gt;&gt; $&#123;log_path&#125; 2&gt;&amp;1`ret=`yum install -y firewalld &gt;&gt; $&#123;log_path&#125; 2&gt;&amp;1`ret=`systemctl start firewalld &gt;&gt; $&#123;log_path&#125; 2&gt;&amp;1`# 开启端口ret=`firewall-cmd --permanent --zone=public --add-port=22/tcp &gt;&gt; $&#123;log_path&#125; 2&gt;&amp;1`ret=`firewall-cmd --permanent --zone=public --add-port=$port/tcp &gt;&gt; $&#123;log_path&#125; 2&gt;&amp;1`ret=`firewall-cmd --reload &gt;&gt; $&#123;log_path&#125; 2&gt;&amp;1`# 如果有相同功能的进程则杀死ps -ef|grep ssserver|grep shadowsocks|awk &apos;&#123; print $2 &#125;&apos;|xargs kill -9nohup /usr/bin/ssserver -c /etc/shadowsocks.json &amp;# 成功if [ $? -eq 0 ];thenclearcat&lt;&lt;EOF***************Congratulation!*************Shadowsocks installed successfully!PORT: $portPASSWORD: $pwdMETHOD: aes-256-cfb***************JUST ENJOY IT!**************EOF# 失败elseclearcat&lt;&lt;EOF************Failed,retry please!***********cat /etc/ss.log to get something you need…************Failed,retry please!***********EOFfi 需要记住 端口号 和 密码 一会儿会用到 如果是用脚本搭建的就没必要看这一部分了,直接看客户端部分就行手动搭建 shadowsocks1234# 安装 pip 工具且安装 shadowsocks$ yum install m2crypto python-setuptools$ easy_install pip$ pip install shadowsocks 编辑启动配置文件1$ vi /etc/shadowsocks.json 文件内容如下12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:443, //对外的端口 &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;123456&quot;,//你的链接密码 &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 如果是多端口配置123456789101112&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: &#123; &quot;443&quot;: &quot;443&quot;, &quot;8888&quot;: &quot;8888&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 配置防火墙,centos7默认的防火墙是 firewalld 和 centos6的 iptables 稍有区别1234# 安装防火墙$ yum install firewalld# 启动防火墙$ systemctl start firewalld 开启对应的端口1234# 端口号是你自己设置的端口(上文中的配置,443端口)$ firewall-cmd --permanent --zone=public --add-port=443/tcp# 新增防火墙规则后一定要执行,这一步很重要$ firewall-cmd --reload 启动 shadowsocks 服务123$ ssserver -c /etc/shadowsocks.json//如果改成常驻后台的模式$ nohup ssserver -c /etc/shadowsocks.json &amp; 将它设置成开机自启动1vi /etc/systemd/system/shadowsocks.service 输入内容123456789[Unit]Description=Shadowsocks[Service]TimeoutStartSec=0ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json[Install]WantedBy=multi-user.target 添加进服务中12345$ systemctl enable shadowsocks//启动服务(如果执行过之前的流程的话就不用执行这一步,因为已经启动了)$ systemctl start shadowsocks//查看启动状态$ systemctl status shadowsocks -l 如果启动没问题和防火墙没问题那么服务器这块就没问题了 通过客户端连接远程 ss 服务下载一个 shadowsocks 客户端下载 各个平台版本列表 软件下载安装后,点击 服务器&gt;服务器设定,地址就是你的服务器 ip,后面的端口是 shadowsocks.json中设置的 server_port,也就是脚本设置时的第一个参数密码是配置文件中的密码,加密方式如果用的脚本就是默认 aes-256-cfb 如果是独立安装就参考shadowsocks.json中的method设置好点选这个服务器再打开 shadowsocks 就好 后记我用的是 mac,之前也是用同样的程序链接的 aws 的服务,后来到期后改用的 vultr,结果搭建的服务器在 mac 上连接不上了,但是同样的地址用手机就能连上!折腾了半天发现是电脑中有之前的配置缓存,索性我就把当前的shadowsocks 删了重装一下,用 cleanMyMac 给它卸载干净,卸载的时候就能发现它究竟有哪些配置存在统统删掉删掉,再重装一下就一切正常了 以上代码出处]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 elementUI 中的 Intput 框的Enter 事件]]></title>
    <url>%2F2017%2F09%2F15%2Felementui-form-event%2F</url>
    <content type="text"><![CDATA[在文档中没有出现相关的说明,但是在实际使用中确实需要用到,怎么办呢? 这里有一个示例:1234567891011121314151617181920&lt;el-form:inline="true":model="price_form":rules="price_rules"ref="priceForm"@submit.native.preventv-if="scope.row.edit_deposit"&gt; &lt;el-row style="margin-top: 22px;"&gt; &lt;el-form-item label-width="0" prop="price"&gt; &lt;el-input placeholder="请输入价格" :icon="price_loading ? 'loading' : 'edit' " v-model="price_form.price" @keyup.native.enter="storePrice" :on-icon-click="storePrice"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-row&gt;&lt;/el-form&gt; 这里需要在input 中加入 `@keyup.native.enter=””事件,只加这个还不完整,因为回车的时候会 出现表单默认提交的情况,有些时候是我们不需要的,因此,需要在el-form中添加@submit.native.prevent`来阻止 form 的默认提交行为 资料来源]]></content>
      <categories>
        <category>elementUI</category>
      </categories>
      <tags>
        <tag>elementUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 做一枚全栈工程师]]></title>
    <url>%2F2017%2F08%2F22%2Fbe-a-fullstack-engineer%2F</url>
    <content type="text"><![CDATA[这篇热门文章在 2017 年 6 月更新过，引入了更多新技术。 如果一个全栈工程师能够根据原型实现一个完整的MVP（minimum viable product，至少可行的产品），我们通常会认为他十八般武艺样样精通，而且有足够的理由来证明这一点。为了给全栈工程师一个最新鲜的定义，我们首先来关注一下全栈工程师以前是搞什么的。 以前的全栈工程师很久以前，大约在 2000 年(在互联网的次元里，17年可以说是一个非常长的时间了)，一个全栈工程师必须掌握下面的本领： 用 Adobe 公司的 Photoshop 或者 Fireworks 工具设计出一个网页 将设计稿变成 HTML, CSS 还有热点图(额，还记得那些吗？) 写一些基本的 PHP 4.0 脚本(非面向对象的 PHP 即将成为历史)来处理服务端逻辑 保存所有的动态数据到 MySQL 中，也可能会做一些小优化 用 FTP 上传所有代码、数据库什么的到一台服务器，然后就可以领取报酬啦 注意我们在这里只讨论 PHP —— 一个全栈 Flash 或者 Coldfusion (一种 Web 服务器) 开发者可能有不同的工作方式(但是也仅仅是细微的差别)。 在那个单纯的时代，生活是如此的美好。个人开发者一抓一大把，而且程序猿工作完还有大把的时间陪伴自己的家人。 那现在呢？ 现在的全栈工程师需要自带什么技能呢最近，我们也会产生这些恐慌——为什么工程师的生活会变成这样？ 为了在这个牛逼的市场里获得成功，我们这些开发者——通常都是完美主义者——应经常把“如果你想做正确的事”当做自己的座右铭，并经常质问自己。这会强迫我们自己集中精力在一处，而且必须学习所有东西，所以做一个全栈工程师往往要学会以下技能： 服务管理/运维一个开发者必须了解基础的服务器管理知识。包括当不限于以下知识： 通过终端或其他没有用户界面的环境来远程连接服务器 会写基本的 shell 脚本 服务器上的用户和群组管理 管理像 Apache 和 Nginx 这样的服务器程序来提供应用 防火墙管理和权限管理 安装和更新软件 图片来自GIPHY 除了这些基础技能，开发者必须懂得怎样去创建一个好的、健康的、分离的开发环境，在 Docker 或者像 Vagrant 这样的虚拟机环境中。 如果上面所有的技术你都不熟悉，那我必须给你推荐一本超棒的书，点这里购买。 开发者必须对版本控制系统非常熟练，为了让开发有靠谱的生产备份和可分享、可协同的代码库，这些代码库能够根据时间来跟踪代码变化。现在已经没有开发者的工作流是完全离开版本控制的了。我们有一个非常棒的关于版本控制的视频教程，点这里购买。 云和实际管理或者虚拟服务器不同，一个开发者也许要知道云主机平台，比如Heroku, Google Cloud, Azure, AWS等等。 图片来自GIPHY 有一点必须说明的是，平台和工具更多的是为了炒作而不是其实用性。尽管有很多平台和工具的实用性并不如宣传的那么好，但是了解这些大家都在谈论的服务，从长远来看会很有用——客户可能会随时要求更换服务提供商。幸运的是，我们拥有这些云主机部署权威指南。 后端在后端，除了要懂选择什么语言以外，比如 PHP 和众多的框架 and CMSes，一个全栈开发者必须熟悉： Web 服务器，比如 Nginx 和 Apache ，和运维紧密相关 不幸的是，NodeJS 已经可以将 JS、CSS 和其他资源文件编译成静态可以方便缓存的文件了。幸运的是，也有办法避免学习 NodeJS，用PHP也是可以的 像Composer这样的 PHP 包管理工具在现代化的开发环境中已经离不开了 好的API 设计，自从大部分新型网页都基于 API 而且仅仅为前端服务（下面会详细描述） ElasticSearch (introduction here) 这样的搜索引擎对于网站性能的提高是非常重要的 cronjobs 和后端的工作，使用Gearman 或者 Crunz 这类的库 了解缓存， Varnish, Redis 等牛B的工具可以分片存储数据，这样可以将一个项目部署的多个主机上 数据库数据库是一个单独的部分，因为除了很好地掌握我们基本上不会有结构变化的关系数据库(MySQL 或者 PostgreSQL)的数据模式之外，一个全栈工程师应该对非关系型数据库有所了解，如MongoDB, Redis, 或 Cassandra ，更不用说像 Neo4j 这样的图形数据库了。 不幸的是，这些都是服务器上的东西，都在全栈工程师的控制下。也有几个类似 Mongo 的远程解决方案，像RestDB或者 Google-owned Firebase 等。 前端说到前端，真的很蛋疼。 图片来自GIPHY 想知道一个正常的前端知识图谱是怎么样的，可以在JavaScript 版块看 这篇绝世好文 。但是作为一个全栈工程师，你需要了解 NodeJS and NPM Yarn 预处理器和编译器(如Babel)，用来编译 Typescript, ES6, LESS, SCSS, SaSS 构建工具，如 Grunt 和 Gulp 框架，如 VueJS、React、Angular 模块打包工具，如 Webpack、Browserify、Rollup 设计在设计方面，全栈开发者需要了解怎样在一个产品变成真正可用的 HTML 、CSS 代码之前，画一个 原型图 。然后就可以去用 JS 写交互、后端也可以用假数据来模拟生产环境。只有这个关键的原型图完成，用户体验设计和接口设计就绪，真正的开发才能开始。这本身就是一项艰巨的任务，需要一套特殊的工具： Photoshop 和 Illustrator 或者一些开源的工具比如 Gimp / Inkscape。访问 Design channel 来了解更多这样的工具。 一个牛B的、快速的编辑器，比如 Atom 或 Sublime Text (这儿有十种好用的 sublime插件) 像 Subtlepatterns 的背景选择器和颜色选择器能够搭配一些颜色 CSS 的栅格系统 上面所说的前端所需要了解的所有知识和 JS 数据模拟 将原型图发表到网上供大家浏览并给于反馈，Ngrok 就非常好用 日志系统为了高效监控应用的健康度，全栈开发者必须能够追踪错误，找到错误日志然后从中提取出有用的信息。全栈开发者也需要从日志中预测一些趋势，比如 CPU 或者 I/O 占用率的上涨，以防应用不知道什么时候就挂了。这部分和运维也有一些关系，但是需要一些特别的技能： 图片来自GIPHY 推荐一篇非常棒的 ELK stack 的文章，这会帮助你了解做日志系统所需要的知识。里面包括了查找日志的 ElasticSearch ，收集日志的 Logstash，把日志用非常棒的图表展现出来的的 Kibana，甚至还有提供解决方案的 Logz.io。 移动端最后，我们该说说移动端了。随着 iOS 和安卓上的的 webview 变得越来越高效，还有 PWA(渐进式web应用) 的到来，native 应用正在变得黯淡，因为他们开发起来实在是太复杂了。所以一个全栈工程师必须了解 PWA 或者 React Native，或者像NativeScript, Tabris, Cordova, Phonegap或者其他 webview 来让客户端应用调用 API 跑起来（如上一章最后说的那样）。 做一个全栈工程师值得吗？所以最后只有一个问题，值不值？ 首先，应该注意到很少的全栈工程师称得上真正的全栈，大部分全栈工程师关注了上面技术的某些方面，而不是所有的，仅仅因为不可能有那么多精力放在上面所有方面。 其次，对所有方面都了解一点也许不会让你在具体方面成为大师，但是说实在的，这会让你在更好地理解项目的流程，和项目确实都需要用到的技术。当作为乙方、开一个外包公司或者给一个迷茫的团队指一条明路方面是无价的技术。 我可能不是一个“JavaScript 巨星”，“Elasticsearch 忍者”，“MySQL 大师”，“运维狂人”，或者“移动端老司机”，我不想被奉承，但是我觉得，做一个全栈工程师让我张开了翅膀，测试不同的技术，作为自由职业者给我的客户提供与众不同的解决方案。我可以有各种各样的赚钱方式，也能拿到从服务端工作到 WordPress 插件开发等不同的订单，因为我对所有的这些都有很多了解（迟早的事）。对于我来说，做一个全栈工程师是非常值得的，对比我以前只做 Flash 的日子，我现在更喜欢我的工作，当时工作多而且工资低（没有 JavaScript）。 你呢，你是全栈还是也精于专呢？不管你是不是全栈，你觉得做的事情值吗？ 本文转载自：众成翻译译者：弈晨链接：http://www.zcfy.cc/article/3548原文：https://www.sitepoint.com/full-stack-developer/]]></content>
      <categories>
        <category>精选转载</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue的一个拖动插件]]></title>
    <url>%2F2017%2F08%2F21%2Fvue-dnd%2F</url>
    <content type="text"><![CDATA[这里介绍一个拿来即用的拖动插件这里只是一个 es5 的 demo先上代码: 简单的拖动排序示例 拖动 clone 示例 这里用上了 option 中的 group配置,group:{ name:&#39;people&#39;, pull: &#39;clone&#39;, put:false}name: 所有可互相拖动的列表必须同一个 name 下pull: true|false|’clone’ 开启|关闭|复制 拖动时的元素, 当为 true 的时候拖动会把该元素从列表中移除put: true|false|array 允许|禁止|数组中指定的值 添加到当前数组列当中这样的话当两边的option 都是 {group:{ name:&#39;people&#39;, pull: true, put:true }}的时候就运行两个列表互相拖动了如下:12345678910&lt;div class="drag"&gt; &lt;h2&gt;List 1 Draggable&lt;/h2&gt; &lt;draggable v-model="list" class="dragArea" :options="&#123;group:&#123; name:'people', pull: true, put:true &#125;&#125;"&gt; &lt;div v-for="(element, index) in list" :key="index"&gt;&#123;&#123;element.name&#125;&#125;&lt;/div&gt; &lt;/draggable&gt; &lt;h2&gt;List 2 Draggable&lt;/h2&gt; &lt;draggable v-model="list2" class="dragArea" :options="&#123;group:&#123; name:'people', pull: true, put:true &#125;&#125;"&gt; &lt;div v-for="(element, index) in list2" :key="index"&gt;&#123;&#123;element.name&#125;&#125;&lt;/div&gt; &lt;/draggable&gt;&lt;/div&gt; 更多的配置在 这里,有时间的话我就都试一下 github地址]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我还活着]]></title>
    <url>%2F2017%2F08%2F14%2Fi-am-alive%2F</url>
    <content type="text"><![CDATA[最近这两个月工作忙到飞起,等10月份再玩点儿新东西]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Js生成笛卡尔积数组]]></title>
    <url>%2F2017%2F07%2F18%2Fjs-decartes%2F</url>
    <content type="text"><![CDATA[以下转载了来自 segmentfault的一个回答 第一种 12345678910111213141516171819&lt;script type="text/javascript"&gt; var data = new Array(new Array(1, 2, 3), new Array(4, 5, 6)); var result = []; console.log(data); function descartes(arrIndex, aresult)&#123; if (arrIndex &gt;= data.length) &#123; result.push(aresult); return ; &#125; var aArr = data[arrIndex]; for (var i = 0; i &lt; aArr.length; ++i) &#123; var theResult = aresult.slice(0, aresult.length); theResult.push(aArr[i]); descartes(arrIndex + 1, theResult); &#125; &#125; descartes(0, []); console.log(result); &lt;/script&gt; 第二种 1234567891011121314function descartes()&#123; if( arguments.length &lt; 2 ) return arguments[0] || []; return [].reduce.call(arguments, function(col, set) &#123; var res = []; col.forEach(function(c) &#123;set.forEach(function(s) &#123; var t = [].concat( Array.isArray(c) ? c : [c] ); t.push(s); res.push(t); &#125;)&#125;); return res; &#125;);&#125;descartes([1,2,3],[4,5,6],[7,8,9],[10,11,12]);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>decartes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Element-Dialog]]></title>
    <url>%2F2017%2F07%2F11%2Felement-dialog%2F</url>
    <content type="text"><![CDATA[使用 elementui 的对话框示例出现问题,esc 或者点击右上的 X 没反应,目前的规避方式就是把 :visible.sync=&quot;dialogFormVisible&quot;用 v-model=&quot;dialogFormVisible&quot; 代替,如果下 1234567891011&lt;el-dialog title="批量修改" v-model="dialogFormVisible" size="tiny" close-on-press-escape="true" style="border-radius: 5px;"&gt; &lt;el-form :model="batch_form" label-position="left" :label-width="formLabelWidth"&gt; &lt;el-form-item :label="batch_form.label" &gt; &lt;el-input v-model="batch_form.value" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot="footer" class="dialog-footer"&gt; &lt;el-button @click="dialogFormVisible = false"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="batchChange()"&gt;修 改&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; 其他的部分照常]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>element-ui</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次 Hexo 报错经历]]></title>
    <url>%2F2017%2F06%2F29%2Fhexo-error-reinstall%2F</url>
    <content type="text"><![CDATA[就在今天,吾心中忽有所感,心想不如升级一发环境版本?结果就立马受到了环境的制裁…. 报错信息如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Error: The module &apos;/usr/local/lib/node_modules/hexo/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;was compiled against a different Node.js version usingNODE_MODULE_VERSION 51. This version of Node.js requiresNODE_MODULE_VERSION 57. Please try re-compiling or re-installingthe module (for instance, using `npm rebuild` or `npm install`). at Object.Module._extensions..node (module.js:598:18) at Module.load (module.js:503:32) at tryModuleLoad (module.js:466:12) at Function.Module._load (module.js:458:3) at Module.require (module.js:513:17) at require (internal/module.js:11:18) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:569:30) at Object.Module._extensions..js (module.js:580:10) at Module.load (module.js:503:32) at tryModuleLoad (module.js:466:12) at Function.Module._load (module.js:458:3) at Module.require (module.js:513:17) at require (internal/module.js:11:18) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo/node_modules/bunyan/lib/bunyan.js:79:18) at Module._compile (module.js:569:30)&#123; Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos; at Function.Module._resolveFilename (module.js:485:15) at Function.Module._load (module.js:437:25) at Module.require (module.js:513:17) at require (internal/module.js:11:18) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:569:30) at Object.Module._extensions..js (module.js:580:10) at Module.load (module.js:503:32) at tryModuleLoad (module.js:466:12) at Function.Module._load (module.js:458:3) at Module.require (module.js:513:17) at require (internal/module.js:11:18) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo/node_modules/bunyan/lib/bunyan.js:79:18) at Module._compile (module.js:569:30) at Object.Module._extensions..js (module.js:580:10) at Module.load (module.js:503:32) code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos; at Function.Module._resolveFilename (module.js:485:15) at Function.Module._load (module.js:437:25) at Module.require (module.js:513:17) at require (internal/module.js:11:18) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:569:30) at Object.Module._extensions..js (module.js:580:10) at Module.load (module.js:503:32) at tryModuleLoad (module.js:466:12) at Function.Module._load (module.js:458:3) at Module.require (module.js:513:17) at require (internal/module.js:11:18) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo/node_modules/bunyan/lib/bunyan.js:79:18) at Module._compile (module.js:569:30) at Object.Module._extensions..js (module.js:580:10) at Module.load (module.js:503:32) code: &apos;MODULE_NOT_FOUND&apos; &#125;(node:7992) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated. 唔…之前报过dtrace-provider的错误,翻了一下以前的记录就直接无脑的sudo npm install dtrace-provider 但是该怎么报错还是怎么报错…. 后来再粗暴点就删了package-lock.json和node_modules目录重新来了一遍npm install,结果还是不行… 有点绝望的我在想:难道我以后就不能用新版本了吗? 后来开始仔细看一下报错信息:12345Error: The module &apos;/usr/local/lib/node_modules/hexo/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;was compiled against a different Node.js version usingNODE_MODULE_VERSION 51. This version of Node.js requiresNODE_MODULE_VERSION 57. Please try re-compiling or re-installingthe module (for instance, using `npm rebuild` or `npm install`). 看到这我意识到之前全局安装的文件都没更新过!于是乎执行sudo npm install -g hexo-cli 好了,解决了]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 my.cnf 文件注释信息]]></title>
    <url>%2F2017%2F06%2F29%2Fmysql-config%2F</url>
    <content type="text"><![CDATA[MySQL配置文件my.cnf 例子最详细翻译,可以保存做笔记用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442#BEGIN CONFIG INFO#DESCR: 4GB RAM, 只使用InnoDB, ACID, 少量的连接, 队列负载大#TYPE: SYSTEM#END CONFIG INFO## 此mysql配置文件例子针对4G内存。# 主要使用INNODB#处理复杂队列并且连接数量较少的mysql服务器## 将此文件复制到/etc/my.cnf 作为全局设置,# mysql-data-dir/my.cnf 作为服务器指定设置# (@localstatedir@ for this installation) 或者放入# ~/.my.cnf 作为用户设置.## 在此配置文件中, 你可以使用所有程序支持的长选项.# 如果想获悉程序支持的所有选项# 请在程序后加上"--help"参数运行程序.## 关于独立选项更多的细节信息可以在手册内找到### 以下选项会被MySQL客户端应用读取.# 注意只有MySQL附带的客户端应用程序保证可以读取这段内容.# 如果你想你自己的MySQL应用程序获取这些值# 需要在MySQL客户端库初始化的时候指定这些选项#[client]#password = [your_password]port = @MYSQL_TCP_PORT@socket = @MYSQL_UNIX_ADDR@# *** 应用定制选项 ***## MySQL 服务端#[mysqld]# 一般配置选项port = @MYSQL_TCP_PORT@socket = @MYSQL_UNIX_ADDR@# back_log 是操作系统在监听队列中所能保持的连接数,# 队列保存了在MySQL连接管理器线程处理之前的连接.# 如果你有非常高的连接率并且出现"connection refused" 报错,# 你就应该增加此处的值.# 检查你的操作系统文档来获取这个变量的最大值.# 如果将back_log设定到比你操作系统限制更高的值,将会没有效果back_log = 50# 不在TCP/IP端口上进行监听.# 如果所有的进程都是在同一台服务器连接到本地的mysqld,# 这样设置将是增强安全的方法# 所有mysqld的连接都是通过Unix sockets 或者命名管道进行的.# 注意在windows下如果没有打开命名管道选项而只是用此项# (通过 "enable-named-pipe" 选项) 将会导致mysql服务没有任何作用!#skip-networking# MySQL 服务所允许的同时会话数的上限# 其中一个连接将被SUPER权限保留作为管理员登录.# 即便已经达到了连接数的上限.max_connections = 100# 每个客户端连接最大的错误允许数量,如果达到了此限制.# 这个客户端将会被MySQL服务阻止直到执行了"FLUSH HOSTS" 或者服务重启# 非法的密码以及其他在链接时的错误会增加此值.# 查看 "Aborted_connects" 状态来获取全局计数器.max_connect_errors = 10# 所有线程所打开表的数量.# 增加此值就增加了mysqld所需要的文件描述符的数量# 这样你需要确认在[mysqld_safe]中 "open-files-limit" 变量设置打开文件数量允许至少4096table_cache = 2048# 允许外部文件级别的锁. 打开文件锁会对性能造成负面影响# 所以只有在你在同样的文件上运行多个数据库实例时才使用此选项(注意仍会有其他约束!)# 或者你在文件层面上使用了其他一些软件依赖来锁定MyISAM表#external-locking# 服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小(当与大的BLOB字段一起工作时相当必要)# 每个连接独立的大小.大小动态增加max_allowed_packet = 16M# 在一个事务中binlog为了记录SQL状态所持有的cache大小# 如果你经常使用大的,多声明的事务,你可以增加此值来获取更大的性能.# 所有从事务来的状态都将被缓冲在binlog缓冲中然后在提交后一次性写入到binlog中# 如果事务比此值大, 会使用磁盘上的临时文件来替代.# 此缓冲在每个连接的事务第一次更新状态时被创建binlog_cache_size = 1M# 独立的内存表所允许的最大容量.# 此选项为了防止意外创建一个超大的内存表导致永尽所有的内存资源.max_heap_table_size = 64M# 排序缓冲被用来处理类似ORDER BY以及GROUP BY队列所引起的排序# 如果排序后的数据无法放入排序缓冲,# 一个用来替代的基于磁盘的合并分类会被使用# 查看 "Sort_merge_passes" 状态变量.# 在排序发生时由每个线程分配sort_buffer_size = 8M# 此缓冲被使用来优化全联合(full JOINs 不带索引的联合).# 类似的联合在极大多数情况下有非常糟糕的性能表现,# 但是将此值设大能够减轻性能影响.# 通过 "Select_full_join" 状态变量查看全联合的数量# 当全联合发生时,在每个线程中分配join_buffer_size = 8M# 我们在cache中保留多少线程用于重用# 当一个客户端断开连接后,如果cache中的线程还少于thread_cache_size,# 则客户端线程被放入cache中.# 这可以在你需要大量新连接的时候极大的减少线程创建的开销# (一般来说如果你有好的线程模型的话,这不会有明显的性能提升.)thread_cache_size = 8# 此允许应用程序给予线程系统一个提示在同一时间给予渴望被运行的线程的数量.# 此值只对于支持 thread_concurrency() 函数的系统有意义( 例如Sun Solaris).# 你可可以尝试使用 [CPU数量]*(2..4) 来作为thread_concurrency的值thread_concurrency = 8# 查询缓冲常被用来缓冲 SELECT 的结果并且在下一次同样查询的时候不再执行直接返回结果.# 打开查询缓冲可以极大的提高服务器速度, 如果你有大量的相同的查询并且很少修改表.# 查看 "Qcache_lowmem_prunes" 状态变量来检查是否当前值对于你的负载来说是否足够高.# 注意: 在你表经常变化的情况下或者如果你的查询原文每次都不同,# 查询缓冲也许引起性能下降而不是性能提升.query_cache_size = 64M# 只有小于此设定值的结果才会被缓冲# 此设置用来保护查询缓冲,防止一个极大的结果集将其他所有的查询结果都覆盖.query_cache_limit = 2M# 被全文检索索引的最小的字长.# 你也许希望减少它,如果你需要搜索更短字的时候.# 注意在你修改此值之后,# 你需要重建你的 FULLTEXT 索引ft_min_word_len = 4# 如果你的系统支持 memlock() 函数,你也许希望打开此选项用以让运行中的mysql在在内存高度紧张的时候,数据在内存中保持锁定并且防止可能被swapping out# 此选项对于性能有益#memlock# 当创建新表时作为默认使用的表类型,# 如果在创建表示没有特别执行表类型,将会使用此值default_table_type = MYISAM# 线程使用的堆大小. 此容量的内存在每次连接时被预留.# MySQL 本身常不会需要超过64K的内存# 如果你使用你自己的需要大量堆的UDF函数# 或者你的操作系统对于某些操作需要更多的堆,# 你也许需要将其设置的更高一点.thread_stack = 192K# 设定默认的事务隔离级别.可用的级别如下:# READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLEtransaction_isolation = REPEATABLE-READ# 内部(内存中)临时表的最大大小# 如果一个表增长到比此值更大,将会自动转换为基于磁盘的表.# 此限制是针对单个表的,而不是总和.tmp_table_size = 64M# 打开二进制日志功能.# 在复制(replication)配置中,作为MASTER主服务器必须打开此项# 如果你需要从你最后的备份中做基于时间点的恢复,你也同样需要二进制日志.log-bin=mysql-bin# 如果你在使用链式从服务器结构的复制模式 (A-&gt;B-&gt;C),# 你需要在服务器B上打开此项.# 此选项打开在从线程上重做过的更新的日志,# 并将其写入从服务器的二进制日志.#log_slave_updates# 打开全查询日志. 所有的由服务器接收到的查询 (甚至对于一个错误语法的查询)# 都会被记录下来. 这对于调试非常有用, 在生产环境中常常关闭此项.#log# 将警告打印输出到错误log文件. 如果你对于MySQL有任何问题# 你应该打开警告log并且仔细审查错误日志,查出可能的原因.#log_warnings# 记录慢速查询. 慢速查询是指消耗了比 "long_query_time" 定义的更多时间的查询.# 如果 log_long_format 被打开,那些没有使用索引的查询也会被记录.# 如果你经常增加新查询到已有的系统内的话. 一般来说这是一个好主意,log_slow_queries# 所有的使用了比这个时间(以秒为单位)更多的查询会被认为是慢速查询.# 不要在这里使用"1", 否则会导致所有的查询,甚至非常快的查询页被记录下来(由于MySQL 目前时间的精确度只能达到秒的级别).long_query_time = 2# 在慢速日志中记录更多的信息.# 一般此项最好打开.# 打开此项会记录使得那些没有使用索引的查询也被作为到慢速查询附加到慢速日志里log_long_format# 此目录被MySQL用来保存临时文件.例如,# 它被用来处理基于磁盘的大型排序,和内部排序一样.# 以及简单的临时表.# 如果你不创建非常大的临时文件,将其放置到 swapfs/tmpfs 文件系统上也许比较好# 另一种选择是你也可以将其放置在独立的磁盘上.# 你可以使用";"来放置多个路径# 他们会按照roud-robin方法被轮询使用.#tmpdir = /tmp# *** 复制有关的设置# 唯一的服务辨识号,数值位于 1 到 2^32-1之间.# 此值在master和slave上都需要设置.# 如果 "master-host" 没有被设置,则默认为1, 但是如果忽略此选项,MySQL不会作为master生效.server-id = 1# 复制的Slave (去掉master段的注释来使其生效)## 为了配置此主机作为复制的slave服务器,你可以选择两种方法:## 1) 使用 CHANGE MASTER TO 命令 (在我们的手册中有完整描述) -# 语法如下:## CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;,# MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ;## 你需要替换掉 &lt;host&gt;, &lt;user&gt;, &lt;password&gt; 等被尖括号包围的字段以及使用master的端口号替换&lt;port&gt; (默认3306).## 例子:## CHANGE MASTER TO MASTER_HOST='125.564.12.1', MASTER_PORT=3306,# MASTER_USER='joe', MASTER_PASSWORD='secret';## 或者## 2) 设置以下的变量. 不论如何, 在你选择这种方法的情况下, 然后第一次启动复制(甚至不成功的情况下,# 例如如果你输入错密码在master-password字段并且slave无法连接),# slave会创建一个 master.info 文件,并且之后任何对于包含在此文件内的参数的变化都会被忽略# 并且由 master.info 文件内的内容覆盖, 除非你关闭slave服务, 删除 master.info 并且重启slave 服务.# 由于这个原因,你也许不想碰一下的配置(注释掉的) 并且使用 CHANGE MASTER TO (查看上面) 来代替## 所需要的唯一id号位于 2 和 2^32 - 1之间# (并且和master不同)# 如果master-host被设置了.则默认值是2# 但是如果省略,则不会生效#server-id = 2## 复制结构中的master - 必须#master-host = &lt;hostname&gt;## 当连接到master上时slave所用来认证的用户名 - 必须#master-user = &lt;username&gt;## 当连接到master上时slave所用来认证的密码 - 必须#master-password = &lt;password&gt;## master监听的端口.# 可选 - 默认是3306#master-port = &lt;port&gt;# 使得slave只读.只有用户拥有SUPER权限和在上面的slave线程能够修改数据.# 你可以使用此项去保证没有应用程序会意外的修改slave而不是master上的数据#read_only#*** MyISAM 相关选项# 关键词缓冲的大小, 一般用来缓冲MyISAM表的索引块.# 不要将其设置大于你可用内存的30%,# 因为一部分内存同样被OS用来缓冲行数据# 甚至在你并不使用MyISAM 表的情况下, 你也需要仍旧设置起 8-64M 内存由于它同样会被内部临时磁盘表使用.key_buffer_size = 32M# 用来做MyISAM表全表扫描的缓冲大小.# 当全表扫描需要时,在对应线程中分配.read_buffer_size = 2M# 当在排序之后,从一个已经排序好的序列中读取行时,行数据将从这个缓冲中读取来防止磁盘寻道.# 如果你增高此值,可以提高很多ORDER BY的性能.# 当需要时由每个线程分配read_rnd_buffer_size = 16M# MyISAM 使用特殊的类似树的cache来使得突发插入# (这些插入是,INSERT SELECT, INSERT VALUES (), (), , 以及 LOAD DATA# INFILE) 更快. 此变量限制每个进程中缓冲树的字节数.# 设置为 0 会关闭此优化.# 为了最优化不要将此值设置大于 "key_buffer_size".# 当突发插入被检测到时此缓冲将被分配.bulk_insert_buffer_size = 64M# 此缓冲当MySQL需要在 REPAIR, OPTIMIZE, ALTER 以及 LOAD DATA INFILE 到一个空表中引起重建索引时被分配.# 这在每个线程中被分配.所以在设置大值时需要小心.myisam_sort_buffer_size = 128M# MySQL重建索引时所允许的最大临时文件的大小 (当 REPAIR, ALTER TABLE 或者 LOAD DATA INFILE).# 如果文件大小比此值更大,索引会通过键值缓冲创建(更慢)myisam_max_sort_file_size = 10G# 如果被用来更快的索引创建索引所使用临时文件大于制定的值,那就使用键值缓冲方法.# 这主要用来强制在大表中长字串键去使用慢速的键值缓冲方法来创建索引.myisam_max_extra_sort_file_size = 10G# 如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们.# 这对于拥有多个CPU以及大量内存情况的用户,是一个很好的选择.myisam_repair_threads = 1# 自动检查和修复没有适当关闭的 MyISAM 表.myisam_recover# 默认关闭 Federatedskip-federated# *** BDB 相关选项 ***# 如果你运行的MySQL服务有BDB支持但是你不准备使用的时候使用此选项. 这会节省内存并且可能加速一些事.skip-bdb# *** INNODB 相关选项 ***# 如果你的MySQL服务包含InnoDB支持但是并不打算使用的话,# 使用此选项会节省内存以及磁盘空间,并且加速某些部分#skip-innodb# 附加的内存池被InnoDB用来保存 metadata 信息# 如果InnoDB为此目的需要更多的内存,它会开始从OS这里申请内存.# 由于这个操作在大多数现代操作系统上已经足够快, 你一般不需要修改此值.# SHOW INNODB STATUS 命令会显示当先使用的数量.innodb_additional_mem_pool_size = 16M# InnoDB使用一个缓冲池来保存索引和原始数据, 不像 MyISAM.# 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.# 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%# 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.# 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,# 所以不要设置的太高.innodb_buffer_pool_size = 2G# InnoDB 将数据保存在一个或者多个数据文件中成为表空间.# 如果你只有单个逻辑驱动保存你的数据,一个单个的自增文件就足够好了.# 其他情况下.每个设备一个文件一般都是个好的选择.# 你也可以配置InnoDB来使用裸盘分区 - 请参考手册来获取更多相关内容innodb_data_file_path = ibdata1:10M:autoextend# 设置此选项如果你希望InnoDB表空间文件被保存在其他分区.# 默认保存在MySQL的datadir中.#innodb_data_home_dir = &lt;directory&gt;# 用来同步IO操作的IO线程的数量. This value is# 此值在Unix下被硬编码为4,但是在Windows磁盘I/O可能在一个大数值下表现的更好.innodb_file_io_threads = 4# 如果你发现InnoDB表空间损坏, 设置此值为一个非零值可能帮助你导出你的表.# 从1开始并且增加此值知道你能够成功的导出表.#innodb_force_recovery=1# 在InnoDb核心内的允许线程数量.# 最优值依赖于应用程序,硬件以及操作系统的调度方式.# 过高的值可能导致线程的互斥颠簸.innodb_thread_concurrency = 16# 如果设置为1 ,InnoDB会在每次提交后刷新(fsync)事务日志到磁盘上,# 这提供了完整的ACID行为.# 如果你愿意对事务安全折衷, 并且你正在运行一个小的食物, 你可以设置此值到0或者2来减少由事务日志引起的磁盘I/O# 0代表日志只大约每秒写入日志文件并且日志文件刷新到磁盘.# 2代表日志写入日志文件在每次提交后,但是日志文件只有大约每秒才会刷新到磁盘上.innodb_flush_log_at_trx_commit = 1# 加速InnoDB的关闭. 这会阻止InnoDB在关闭时做全清除以及插入缓冲合并.# 这可能极大增加关机时间, 但是取而代之的是InnoDB可能在下次启动时做这些操作.#innodb_fast_shutdown# 用来缓冲日志数据的缓冲区的大小.# 当此值快满时, InnoDB将必须刷新数据到磁盘上.# 由于基本上每秒都会刷新一次,所以没有必要将此值设置的太大(甚至对于长事务而言)innodb_log_buffer_size = 8M# 在日志组中每个日志文件的大小.# 你应该设置日志文件总合大小到你缓冲池大小的25%~100%# 来避免在日志文件覆写上不必要的缓冲池刷新行为.# 不论如何, 请注意一个大的日志文件大小会增加恢复进程所需要的时间.innodb_log_file_size = 256M# 在日志组中的文件总数.# 通常来说2~3是比较好的.innodb_log_files_in_group = 3# InnoDB的日志文件所在位置. 默认是MySQL的datadir.# 你可以将其指定到一个独立的硬盘上或者一个RAID1卷上来提高其性能#innodb_log_group_home_dir# 在InnoDB缓冲池中最大允许的脏页面的比例.# 如果达到限额, InnoDB会开始刷新他们防止他们妨碍到干净数据页面.# 这是一个软限制,不被保证绝对执行.innodb_max_dirty_pages_pct = 90# InnoDB用来刷新日志的方法.# 表空间总是使用双重写入刷新方法# 默认值是 "fdatasync", 另一个是 "O_DSYNC".#innodb_flush_method=O_DSYNC# 在被回滚前,一个InnoDB的事务应该等待一个锁被批准多久.# InnoDB在其拥有的锁表中自动检测事务死锁并且回滚事务.# 如果你使用 LOCK TABLES 指令, 或者在同样事务中使用除了InnoDB以外的其他事务安全的存储引擎# 那么一个死锁可能发生而InnoDB无法注意到.# 这种情况下这个timeout值对于解决这种问题就非常有帮助.innodb_lock_wait_timeout = 120[mysqldump]# 不要在将内存中的整个结果写入磁盘之前缓存. 在导出非常巨大的表时需要此项quickmax_allowed_packet = 16M[mysql]no-auto-rehash# 仅仅允许使用键值的 UPDATEs 和 DELETEs .#safe-updates[isamchk]key_buffer = 512Msort_buffer_size = 512Mread_buffer = 8Mwrite_buffer = 8M[myisamchk]key_buffer = 512Msort_buffer_size = 512Mread_buffer = 8Mwrite_buffer = 8M[mysqlhotcopy]interactive-timeout[mysqld_safe]# 增加每个进程的可打开文件数量.# 警告: 确认你已经将全系统限制设定的足够高!# 打开大量表需要将此值设bopen-files-limit = 8192 原文]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP标准类库系列 Iterator]]></title>
    <url>%2F2017%2F06%2F27%2Fphp-spl-iterator%2F</url>
    <content type="text"><![CDATA[迭代器,让对象可用 foreach,for,while方法 啥是 Iterator是一种 php 提供的接口标准,可以将不同的类迭代调用统一成一样的方法,打个比方(话说谁叫比方?):这是调用 mysql 时取出资源的方法1234567891011121314151617$dbms='mysql';$host='localhost';$dbName='wechat';$user='root'; $pass='123123';$dsn="$dbms:host=$host:33060;dbname=$dbName;";try &#123; $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象 foreach ($dbh-&gt;query('SELECT * from migrations;') as $row) &#123; print_r($row); &#125; $dbh = null;&#125; catch (PDOException $e) &#123; die ("Error!: " . $e-&gt;getMessage() . "&lt;br/&gt;");&#125; 而读取目录下所有文件的方法是:12345$dirPath = '/Users/gpf/Desktop';$list = opendir($dirPath);while($filename = readdir($list))&#123; echo $filename . PHP_EOL;&#125; 而读取文件内容的方法是1234567891011121314$filePath = '/Users/gpf/Desktop/test.php';$handler = @fopen($filePath,'r');if(!$handler)&#123; die('error');&#125;while(!feof($handler))&#123; $line = fgets($handler); echo $line;&#125;foreach(new SplFileObject($filePath) as $line)&#123; echo $line . PHP_EOL;&#125; 都是做的循环的事但是不统一,这就很烦躁,因为同样一件事你需要用不同的方法去实现,一个茴字要用四种写法这种情况下在 php51 之后开发组也意识到问题了,于是就出现了 SPL,就有了一个通用的 Iterator这个迭代器就是让不同的资源操作变得相同,这些接口可以自己实现,也可以用官方提供的一些迭代器比如读取文本的迭代器就可以这样获取文本内容了:12345678$filePath = '/Users/gpf/Desktop/test.php';$handler = new SplFileObject($filePath);foreach($handler as $line)&#123; echo $line . PHP_EOL;&#125;//当然也可以直接跳行查找$handler-&gt;seek(4);var_dump($handler-&gt;current()); 这样调用就显得比较统一了,那么 怎么使用 Iterator?这里参照了php 文档 和 阮一峰的博客写的一个例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class IteratorDemo implements Iterator&#123; private $attributes = []; protected $valid = FALSE; function __construct(array $array) &#123; $this-&gt;attributes = $array; &#125; function rewind() &#123; var_dump(__METHOD__); $this-&gt;valid = (FALSE !== reset($this-&gt;attributes)); &#125; function current() &#123; var_dump(__METHOD__); return current($this-&gt;attributes); &#125; function key() &#123; var_dump(__METHOD__); return key($this-&gt;attributes); &#125; //如果 next 返回 false 循环将终止 function next() &#123; var_dump(__METHOD__); $this-&gt;valid = (FALSE !== next($this-&gt;attributes)); &#125; function valid() &#123; var_dump(__METHOD__); return $this-&gt;valid; &#125;&#125;$arr = [ 'red' =&gt; 'stop', 'green' =&gt; 'run', 'yellow' =&gt; 'wait'];$demo = new IteratorDemo($arr);var_dump($demo);foreach ($demo as $key =&gt; $value)&#123; echo $key . '=&gt;' . $value . PHP_EOL;&#125; 输出:123456789101112131415161718192021222324252627282930object(IteratorDemo)#1 (2) &#123; ["attributes":"IteratorDemo":private]=&gt; array(3) &#123; ["red"]=&gt; string(4) "stop" ["green"]=&gt; string(3) "run" ["yellow"]=&gt; string(4) "wait" &#125; ["valid":protected]=&gt; bool(false)&#125;string(20) "IteratorDemo::rewind"string(19) "IteratorDemo::valid"string(21) "IteratorDemo::current"string(17) "IteratorDemo::key"red=&gt;stopstring(18) "IteratorDemo::next"string(19) "IteratorDemo::valid"string(21) "IteratorDemo::current"string(17) "IteratorDemo::key"green=&gt;runstring(18) "IteratorDemo::next"string(19) "IteratorDemo::valid"string(21) "IteratorDemo::current"string(17) "IteratorDemo::key"yellow=&gt;waitstring(18) "IteratorDemo::next"string(19) "IteratorDemo::valid" 这就实现了一个通用的 Iterator 接口,当然这是是为了实现而实现,中间可以做很多事情的,这要发挥一下想象力 在程序里经常看到 FooIterator 这类的对象,就是基于上面写的 Iterator 进行的延伸,比如刚才我们例子中用到的SplFileObject,SimpleXMLIterator,ArrayIterator这些类,都是大同小异的,不过是根据实现的迭代器添加一些更适用的方法,比如一个DirectoryIterator中就是继承了SplFileInfo的方法并且实现了 Iterator 接口,再添加了一些自己的方法,有用 idea 的可以用代码追踪看一下也是蛮有意思的 参考资料: Iterator（迭代器）接口 PHP SPL笔记]]></content>
      <categories>
        <category>php-SPL</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>SPL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP标准类库系列 arrayAccess]]></title>
    <url>%2F2017%2F06%2F26%2Fphp-spl-arrayaccess%2F</url>
    <content type="text"><![CDATA[现在很多的 php 框架模型调取属性的时候可以按照数组的方式去调用,这是因为使用了arrayAccess这个接口 什么是 SPL?SPL 是 Standard PHP Library 的缩写,是官方在 php5之后提供的一个标准类库,为 php 面向对象开发提供了良好的支持 如何使用arrayAccess 接口最好的学习就是使用啊,这是我写的一个 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?phpclass Demo implements \ArrayAccess&#123; public $name = 'demo'; protected $attributes = []; /** * Demo constructor. * @param array $attribute */ public function __construct(array $attribute = []) &#123; $this-&gt;attributes = $attribute; &#125; /** * @param mixed $offset * @return bool */ public function offsetExists($offset) &#123; return isset($this-&gt;&#123;$offset&#125;); &#125; /** * @param mixed $offset * @return mixed */ public function offsetGet($offset) &#123; return $this-&gt;&#123;$offset&#125;; &#125; /** * @param mixed $offset * @param mixed $value * @return mixed */ public function offsetSet($offset, $value) &#123; return $this-&gt;&#123;$offset&#125; = $value; &#125; /** * @param mixed $offset * @return bool */ public function offsetUnset($offset) &#123; if($this-&gt;$offset)&#123; $this-&gt;$offset = null; return true; &#125;else&#123; return false; &#125; &#125; /** * @param $name * @param $value * @return mixed */ public function __set($name, $value) &#123; return $this-&gt;attributes[$name] = $value; &#125; /** * @param $name * @return mixed|null */ public function __get($name) &#123; return array_key_exists($name,$this-&gt;attributes)? $this-&gt;attributes[$name] : null; &#125;&#125;$arr = [ 'height' =&gt; '180cm',];$demo = new Demo($arr);echo $demo-&gt;name . PHP_EOL;echo $demo['name'] . PHP_EOL;echo $demo['height'] . PHP_EOL;//删除unset($demo['height']);var_dump($demo['height']);//新增$demo['sex'] = 'man';echo $demo-&gt;sex . PHP_EOL;//修改$demo['height'] = '2333cm';echo $demo['height'] . PHP_EOL;//打印这个类var_dump($demo); 输出:1234567891011121314151617demodemo180cmNULLman2333cmobject(Demo)#1 (2) &#123; [&quot;name&quot;]=&gt; string(4) &quot;demo&quot; [&quot;attributes&quot;:protected]=&gt; array(2) &#123; [&quot;height&quot;]=&gt; string(6) &quot;2333cm&quot; [&quot;sex&quot;]=&gt; string(3) &quot;man&quot; &#125;&#125; 这里还用了__set和__get,现在一些框架的关于数据模型的类也是类似的实现思路]]></content>
      <categories>
        <category>php-SPL</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>SPL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__Callstatic]]></title>
    <url>%2F2017%2F06%2F23%2Fphp-callstatic%2F</url>
    <content type="text"><![CDATA[现在很多框架中调用方法都是Foo::bar()这种格式的,但是他们真的是静态方法吗? 这种情况在 larave 中尤其常见,但是开发过程中很明显这些有一部分不是静态的,比如你使用一个模型User,那么你每次实例化出来他都是一个全新的,互不影响,这里就用到了一个魔术方法__callStatic 举个栗子:123456789101112131415161718&lt;?phpclass Test&#123; public function __call($name, $arguments) &#123; echo 'this is __call'. PHP_EOL; &#125; public static function __callStatic($name, $arguments) &#123; echo 'this is __callStatic:'. PHP_EOL; &#125;&#125;$test = new Test();$test-&gt;hello();$test::hi();//this is __call:hello//this is __callStatic:hi 当然魔术方法也是很耗性能的一种方式,每次调用的时候后回先扫一遍class没找到方法时才会调用它,而为了代码的整洁和抽象这个方法也能给很大的帮助,在这之间去要有个权衡 下面实现的 log 类,采用的就是这种方法,将方法解耦出来,只要符合规定的接口就能调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpclass Test&#123; //获取 logger 的实体 private static $logger; public static function getLogger()&#123; return self::$logger?: self::$logger = self::createLogger(); &#125; private static function createLogger()&#123; return new Logger(); &#125; public static function setLogger(LoggerInterface $logger)&#123; self::$logger = $logger; &#125; public function __call($name, $arguments) &#123; call_user_func_array([self::getLogger(),$name],$arguments); &#125; public static function __callStatic($name, $arguments) &#123; forward_static_call_array([self::getLogger(),$name],$arguments); &#125;&#125;interface LoggerInterface&#123; function info($message,array $content = []); function alert($messge,array $content = []);&#125;class Logger implements LoggerInterface &#123; function info($message, array $content = []) &#123; echo 'this is Log method info' . PHP_EOL; var_dump($content); &#125; function alert($messge, array $content = []) &#123; echo 'this is Log method alert: '. $messge . PHP_EOL; &#125;&#125;Test::info('喊个口号:',['好好','学习','天天','向上']);$test = new Test();$test-&gt;alert('hello'); 输出:123456789101112this is Log method infoarray(4) &#123; [0]=&gt; string(6) &quot;好好&quot; [1]=&gt; string(6) &quot;学习&quot; [2]=&gt; string(6) &quot;天天&quot; [3]=&gt; string(6) &quot;向上&quot;&#125;this is Log method alert: hello 也许有的小伙伴已经看出来了,没错!这段代码就是仿照(抄)的 EasyWechat的日志部分,代码片段]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-Error-Permission]]></title>
    <url>%2F2017%2F06%2F23%2Fgit-error-permission%2F</url>
    <content type="text"><![CDATA[这种情况在部署 webhook 的时候经常会碰到报错信息: git error insufficient permission for adding an object这种报错就是权限错误,把项目中的.git 文件整体改成你的执行权限就行 有一点要注意,如果你服务器上有一个 www 的角色在部署项目,那么你就不能再用root的角色去部署了,否则会在 .git/objects 目录下产生由 root所属的文件从而造成当www再次执行合并任务的时候因为权限不能操作部分commit的文件而造成合并失败]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 跨域请求时两次发送请求的问题]]></title>
    <url>%2F2017%2F06%2F23%2Faxios-cors%2F</url>
    <content type="text"><![CDATA[跨域的时候总会碰上各种各样的问题,这就是其中一种情况检查一下，两次请求分别的 Request Method:因为是跨域请求，客户端发先发送一个OPTIONS 请求Preflighted Requests是CORS中一种透明服务器验证机制。预检请求首先需要向另外一个域名的资源发送一个 HTTP OPTIONS 请求头，其目的就是为了判断实际发送的请求是否是安全的。 很有可能是这个问题，我现在用axios 作为我的网络请求库，也遇到了这个问题，跨域访问的时候 ，都会先发送一个OPTIONS请求，用来判断接下来的请求是否安全和被允许 我现在的做法是，在index.php 入口文件中，检测，是否为OPTIONS 请求，如果是就返回一个状态具体代码123456if ($_SERVER[&apos;REQUEST_METHOD&apos;]==&apos;OPTIONS&apos;) &#123; header(&quot;Access-Control-Allow-Origin: *&quot;); header(&quot;Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, Authorization&quot;); header(&apos;Access-Control-Allow-Methods: GET, POST, PUT,DELETE,OPTIONS,PATCH&apos;); return;&#125; 原文]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>axios</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git同步所 Fork 的库代码]]></title>
    <url>%2F2017%2F06%2F17%2Fgit-fork-upstream%2F</url>
    <content type="text"><![CDATA[有时候我们 fork 了一个库进行开发,但是时间长了那个库已经添加了一些新的东西,这要怎么处理呢?先添加你 fork 的库的地址12git remote add FORK-sync https://github.com/xxx/yyy.gitgit remote -v 能看到类似的1234FORK-sync https://github.com/xxx/yyy.git (fetch)FORK-sync https://github.com/xxx/yyy.git (push)origin git@github.xxx/born-1.git (fetch)origin git@github.xxx/born-1.git (push) 然后接受所 fork 库的内容1git fetch FORK-sync 合并1git merge FORK-sync/master 再推送到你的远程仓库就行了1git push]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go操作 Json 文本]]></title>
    <url>%2F2017%2F06%2F05%2Fgo-json%2F</url>
    <content type="text"><![CDATA[一些简单的导入导出 事先准备一个 json 文件首先我们准备一个 json 文件,我直接就用的package.json里的一些字段12345678910111213141516&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "author": "GPF &lt;5173180@qq.com&gt;", "description": "A Vue.js project", "dependencies": &#123; "vue": "^2.2.6", "vue-router": "^2.3.1" &#125;, "browserslist": [ "&gt; 1%", "last 2 versions", "not ie &lt;= 8" ]&#125; 具体操作的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( "encoding/json" "fmt" "io/ioutil" "os" "reflect")type allStruct interface&#123;&#125;//定义了获取 json 的结构体type Package struct &#123; Mingzi string `json:"name"` Version string PrIvate bool Dependencies Depend Browserslist []string&#125;type Depend struct &#123; Vue string Router string `json:"vue-router"`&#125;func main() &#123; path := "./package.json" pkg := Package&#123;&#125; file, err := os.Open(path) checkError(err) defer file.Close() data, err := ioutil.ReadAll(file) checkError(err) //这个就是解析 json 格式内容的函数 json.Unmarshal(data, &amp;pkg) foreachStruct(pkg) //output // Mingzi -- hexo-site // Version -- 0.0.0 // PrIvate -- true // Dependencies -- &#123;^2.2.6 ^2.3.1&#125; // Browserslist -- [&gt; 1% last 2 versions not ie &lt;= 8]&#125;//检测错误的方法func checkError(err error) &#123; if err != nil &#123; panic(err) &#125;&#125;//遍历结构体的方法func foreachStruct(st interface&#123;&#125;) &#123; t := reflect.TypeOf(st) v := reflect.ValueOf(st) for k := 0; k &lt; t.NumField(); k++ &#123; key := t.Field(k).Name value := v.Field(k).Interface() fmt.Printf("%s -- %v \n", key, value) &#125;&#125; 这种写法是将 json 自动的赋值给定义好的 struct 上,自动赋值的条件是: 首先查找 tag 含有 jsonkey 值的可导出的 struct 字段(首字母大写),如: 1Mingzi string `json:&quot;name&quot;` //对应 json 中的 &quot;name:&quot; 其次查找字段名相同的可导出的 struct 字段 如: Version string //对应 json 中的 &quot;version:&quot; 然后查找可导出的大小写不敏感的字段 如: PrIvate bool //对应 json 中的 &quot;private&quot; 总之就是如果要求不高就建立 struct 的时候字段直接和 json 字段一一对应就好,但是一定要首字母大写 导入未知结构的 json 数据很多时候我们需要导入的 json 的不确定内容的,或者特别特别长,比如laravel 的 composer.json文件这个时候如果写结构体就很不灵活了,当然,像这种配置型的文件写一个长长的结构体也是可以的于是乎我们就是用 空接口 配合 断言 来实现未知格式json 的解析上代码:这里的composer.json文件可以参考 laravel的composer.json文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package mainimport ( "encoding/json" "fmt" "io/ioutil" "os" "github.com/bitly/go-simplejson")func main() &#123; filePath := "./composer.json" file, err := os.Open(filePath) checkError(err) defer file.Close() data, err := ioutil.ReadAll(file) // checkError(err) readJSON(data) js, err := simplejson.NewJson(data) checkError(err) //获取某个字段值 str, err := js.Get("name").String() checkError(err) fmt.Println("name -&gt; ", str) //多层级的key值 str2, err := js.Get("autoload").Get("classmap").GetIndex(0).String() checkError(err) fmt.Println("autoload.classmap[0] -&gt; ", str2) //判断字段是否存在 //源码内容 https://github.com/bitly/go-simplejson/blob/master/simplejson.go#L157 jType, ok := js.CheckGet("type") if ok &#123; str3, _ := jType.String() fmt.Println("type -&gt; ", str3) &#125; else &#123; fmt.Println("no exist") &#125; //数组 arr, err := js.Get("keywords").Array() checkError(err) for i, v := range arr &#123; fmt.Printf("arr index:%d value:%s \n", i, v) &#125; //字典 mp := js.Get("require").MustMap() fmt.Println("require's key:value is:") for key, value := range mp &#123; fmt.Printf("%s : %s \n", key, value) &#125;&#125;func checkError(err error) &#123; if err != nil &#123; panic(err) &#125;&#125;func readJSON(data []byte) &#123; //定义一个由空接口组成的字典用来承接解析出来的 json var f map[string]interface&#123;&#125; json.Unmarshal(data, &amp;f) //通过断言来判断字段类型 for k, v := range f &#123; switch v.(type) &#123; case string: fmt.Println(k, "is string ====&gt;", v) case int: fmt.Println(k, "is int ====&gt;", v) case []interface&#123;&#125;: fmt.Println(k, "is interface ====&gt;", v) default: fmt.Println(k, "is null type ====&gt;", v) &#125; &#125;&#125; 除了 空接口&amp;断言 这种万用的写法,社区里也是有不少成熟的轮子,我这里用的就是一个很不错的轮子simpleJson,以上给了几个示例,更全面的在轮子的 github中的测试文件中列举出来了 作为新手首要的目标就是先让项目跑起来,等有一定的代码量之后再去看轮子的源码,如果先看源码经常起到事倍功半的效果—-这是我说的 导出 json 格式文件知道了如何导入就要知道如何导出,接下来就是导出的一些需要注意的地方上代码12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( "encoding/json" "fmt")//Server is a json formattype Server struct &#123; ServerName string `json:"serverName"` ServerIP string `json:"serverIP"` Port int `json:"port,string"` // ,string 将 int,int64,bool,string 类型字段按 string 输出 Version string `json:"version,omitempty"` //添加了 ,omitempty 修饰符的意思就是如果该字段未空就不输出&#125;//Serverslice is a json formattype Serverslice struct &#123; ID string `json:"-"` // - 将不会处理 Servers []Server `json:"servers"`&#125;func main() &#123; var s Serverslice s.Servers = append(s.Servers, Server&#123;"beijing_vpn", "127.0.0.1", 22, "v0.0.1"&#125;) s.Servers = append(s.Servers, Server&#123;ServerName: "chegongzhuang", ServerIP: "127.0.0.2", Port: 443&#125;) b, err := json.Marshal(s) checkError(err) fmt.Println(string(b))&#125;func checkError(err error) &#123; if err != nil &#123; panic(err) &#125;&#125;//输出内容为://&#123;"servers":[&#123;"serverName":"beijing_vpn","serverIP":"127.0.0.1","port":"22","version":"v0.0.1"&#125;,&#123;"serverName":"chegongzhuang","serverIP":"127.0.0.2","port":"443"&#125;]&#125; 我们使用了encoding/json这个包,而且是将结构体转成的 json 格式,需要注意一下几点: 定义Struct的字段必须是首字母大写可导出的,如果不写tag的话将按照字段名来输出 tag中设置的自定义名称如json:&quot;serverName&quot;将优先于字段名用于 json 的字段当中按照我们刚才的例子就是 json 中输出 serverName 而不是 ServerName 如果 tag:&quot;-&quot; 将不对这个字段进行处理marshal 函数需要注意的问题: tag:&quot;xxx,omitempty&quot;这种修饰词就是如果字段为空时不输出 tag:&quot;xxx,string&quot;将 int,int64,bool,string 类型字段按 string 输出 json 对象只支持 string 作为 key,因此如果要编码一个 map 必须是map[string]T (T 代表任意类型) channel,complex和 function 不能被输出 指针在编码的时候会输出指针指向的内容,空指针输出null 参照七牛的sdk 文档就是一个很好的例子]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于使用 Git 的操作流程]]></title>
    <url>%2F2017%2F05%2F27%2Fgit-workflow%2F</url>
    <content type="text"><![CDATA[老夫的毕生功力都在这了… 通常我们工作时是这样操作说一下使用 git 做版本控制的时候的工作流程1234git add -A #需要添加到版本库中的文件 -A 就代表着所有文件(除开了 .gitignore忽略掉的文件)git commit -m &apos;本次提交的备注&apos;git pull #将远程的库和本地的库版本同步一下,因为远程库可能发生了修改(多人合作开发时)git push 这样操作的前提是本地远程都是同一个 master 分支上 最可能会碰到的问题以上操作前两步通常不会碰到问题,最容易发生问题的是 git pull 这一步因为多人开发时难免碰到同时修改了同一个文件,那么就会产生冲突git 是根据文件每行发生的修改进行的判定的,如果同时对同一文件的同一行发生了修改,就卡死到这一步上了 怎么解决这个问题我常用的是命令行和 phpstrom 中的版本控制工具,最推荐的是命令行操作,别的图形界面也是调的命令行接口直接学会git 的命令是学习成本最低的一种方式,一次学会到处可用啊! 命令行还有个强大的地方就是它的提示通常就是你解决问题的方法,照着提示打就行(要善用提示啊,别看见报错就慌了) 我们做一个实验,我自己的一个版本库本地和远程同时发生了修改,而且是操作的同一个文件,我直接进行 git push操作看到提示没?提示中的 hint 中说了,向远程库中更新被拒,因为远程有了修改而本地没有(说白了就是没同步),这通常发生在另一个版本库向远程推送了相同的文件(就是两个人在这个版本下同时操作了同一个文件),提示中给出原因之后紧接着给出了解决办法(e.g., &#39;git pull ...&#39;)before pushing again, 我们按着它给的提示操作一下通常如果两个人之间的操作不发生冲突比如同时修改了同一个文件的同一行的情况下就会进入commit的编辑界面了,但是我给他人为的造成一个错误,这个错误就是我们最常碰到的错误,合并冲突看到提示中的最后一行了没有?Automatic merge failed; fix conflicts and then commit the result.自动合并失败了,请修复冲突并再次提交 如果文件很多我怎么去找到它? 一种是靠界面工具主动把错误推到你面前 另一种就是自己去找了 第一种方法坑爹的地方就是好多工具他给你提示就提示一次,你如果给关了就不会再提示了,但是该提交不上去的还是提交不上去,而且如果是线上火速修复的时候你的编辑器是帮不到那么远的我们选第二种,肯定不是挨个文件去翻啊!会死人的 有一个很有用的命令1git status 标红的文件都给你了,而且还给你了需要执行的命令,你别假装看不到啊!当然这个时候直接git add &amp;&amp; git commit会出事的,你还没解决冲突呢!我们去这个冲突文件中解决掉冲突本地能跑通了再提交,而且这个错误提示会指名文件路径的,我这个冲突文件因为正好是在项目的根目录下才没有的 打开这个文件我们看到如下的内容:我这是在 phpstrom 中打开的文件,如果phpstrom 能读取到你项目中的 .git/ 目录是可以进行版本控制的这里phpstrom 就帮你把冲突文件标红了,多么醒目~当然这也是我们自己找的如果文件内容特别多但是就一两处冲突时我们直接搜索关键词 HEAD或者&lt;&lt;&lt;&lt;&lt;&lt;&lt;就行,你懂的…被尖角号扩起来的就是冲突的地方,接下来就是保孩子还是保大人解决冲突的时候了,找到谁和你改的同一处代码 什么?你说你找不到是谁?你没看到代码冲突块下的 779833d952d8a6557b2e8eba3bd192ede5cb6ca0这一段文字吗?你先别激动,这个点还不适合开车,这个是提交的 commit-id,你每次提交都会产生的一个标识要查看这到底是谁和我的代码冲突了就执行下面的命令1git log 779833d952d8a6557b2e8eba3bd192ede5cb6ca0 第一行就是你要的结果,如果直接git log -p 就是列出所有的提交记录 -p 就是显示出修改的地方 冲突块部分 HEAD就是你写的代码,下面的是别人写的,去掉其中一个把那些标签清理干净,测试一下没问题了再git add &amp;&amp; git commit &amp;&amp; git pull &amp;&amp; git push 这四连技好了,世界清净了 这合并的时候发生了什么?这是我在 segmentfault 中给出的答案: 比如你从一个git log为1,2,3,4,5,6的远程库拉取到了本地,另一个同事也拉取了同样的代码,而且你的同事先于你提交到远程了,此时远程的版本是1,2,3,4,5,6,7_new,8_new,而你当前只是本地的版本1,2,3,4,5,6,7_local,8_local,9_local从这里你就能看出你前一部分和远程的一样,后一部分和远程的不一样,这个时候你不能正常推送上去的,如果你采取git push origin master --force那么远程的版本就变成了1,2,3,4,5,6,7_local,8_local,9_local之前你同事推送的7_new,8_new这两次推送被覆盖了,这不是大家想要的情况因此需要git pull来将本地的版本合并成样1,2,3,4,5,6,7_new,7_local,8_local,8_new,9_local,10_commit_merge远程和本地的排序是按当时 commit 的时间来排的,最后一个10_commit_merge就是你本地和远程合并的标志,最后你推送到远程仓库的应该也是这个,因为你们操作的是同一个库始终要保持代码的同步,所以一旦版本库发生改动同一分支下的所有人都要跟着去同步他,因为各开发各的直接往上推 git 还没智能到帮你处理冲突的地步答案链接]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel54初始化迁移失败]]></title>
    <url>%2F2017%2F05%2F24%2Flaravel54-migrate-error%2F</url>
    <content type="text"><![CDATA[在新版的 laravel 框架当中(v5.4.23) 出现了报错1234[Illuminate\Database\QueryException] SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was t oo long; max key length is 767 bytes (SQL: alter table `users` add unique ` users_email_unique`(`email`)) 错误重现: laravel 版本 5.4.23 配置好数据库链接,执行12php artisan make:authphp artisan migrate 就会出现错误 解决办法:打开文件 @yourApp/app/Prividers/AppserviceProvider.php123456use Illuminate\Support\Facades\Schema;function boot()&#123; Schema::defaultStringLength(191);&#125; 文章来源: laracast]]></content>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-Mysql]]></title>
    <url>%2F2017%2F05%2F17%2Fgo-mysql%2F</url>
    <content type="text"><![CDATA[这里写一个go 操作 mysql 的 curd 的 demo 表结构是这样的123456create table test( id int primary key auto_increment, name varchar(20) default '', age int default 0, created_at int default 0) go 的文件是:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( "database/sql" "fmt" "time" _ "github.com/GO-SQL-Driver/MySQL")func checkErr(err error) &#123; if err != nil &#123; panic(err) &#125;&#125;func main() &#123; db, err := sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8") defer db.Close() checkErr(err) //insert stmt, err := db.Prepare("INSERT test SET name=? , age=? , created_at=?") checkErr(err) res, err := stmt.Exec("gaopengfei", 22, time.Now().Unix()) checkErr(err) //获取插入数据的 id id, err := res.LastInsertId() checkErr(err) fmt.Printf("insert id %d \n", id) //update stmt, err = db.Prepare("UPDATE test SET age=? WHERE id &lt; ?") checkErr(err) res, err = stmt.Exec(233, 4) checkErr(err) //输出受影响的条数 affect, err := res.RowsAffected() checkErr(err) fmt.Printf("affected num is %d \n", affect) //select rows, err := db.Query("SELECT * FROM test") checkErr(err) for rows.Next() &#123; var id int var name string var age int var createdAt int //go 不让使用下划线的方式定义变量,如果字段是 created_at 需要写成 createdAt 驼峰命名法 err = rows.Scan(&amp;id, &amp;name, &amp;age, &amp;createdAt) checkErr(err) //将int 转成 int64格式,方便格式化时间 var tm64 int64 tm64 = int64(createdAt) tm := time.Unix(tm64, 0) fmt.Printf("id is %d; name is %s; age is %d: created_at is %s \n", id, name, age, tm.Format("2006-01-02 03:04:05 PM")) &#125; //delete stmt, err = db.Prepare("DELETE FROM test WHERE id=?") checkErr(err) res, err = stmt.Exec(3) checkErr(err) affect, err = res.RowsAffected() checkErr(err) fmt.Printf("affected num is %d \n", affect)&#125; 这里使用了一个稳定的 mysql 包,因为 go 官方并没有实现 mysql 的实例,而是提供了数据操作的接口只要能实现就可以进行操作 文件头部 import 中出现了 _ &quot;github.com/GO-SQL-Driver/MySQL&quot; 这样的写法,意思是引用 _ 后面的包名而不直接使用其中的函数,变量等资源 另外不得不吐槽一下 go 的时间格式函数,我大 php 的格式化是这样的1date("Y-m-d H:i:s",time()) 这边的是 “Y-m-d H:i:s” 啊!,一眼就看出来格式是什么了,但是 go 里的格式是这样的1234timestamp := time.Now().Unix()tm := time.Unix(timestamp, 0)timer := tm.Format("2006-01-02 03:04:05 PM")fmt.Println(timer) 他的格式代表不是 Y,m,d,H,i,s 而是 2006,01,02,03,04,05 PM这个也好记,1234567891011121314151617月份 1,01,Jan,January日 2,02,_2时 3,03,15,PM,pm,AM,am分 4,04秒 5,05年 06,2006周几 Mon,Monday时区时差表示 -07,-0700,Z0700,Z07:00,-07:00,MST时区字母缩写 MST]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php-Callback-Func]]></title>
    <url>%2F2017%2F05%2F11%2Fphp-callback-func%2F</url>
    <content type="text"><![CDATA[你知道茴香的茴有四种写法,那你知道 php 的回调也有四种写法吗? 匿名函数1234var $array = [1,2,3];array_map(function($item)&#123; return $item;&#125;,$array); 类静态调用12345678910class A&#123; static function test($req) &#123; echo "hello world"; &#125;&#125;var $array = [1,2,3];array_map('A::Test',$array);array_map(['A','Test'],$array); 函数12345function test($item)&#123; return 'hello world';&#125;var $array = [1,2,3];array_map('test',$array); 对象方法12345678910class A&#123; static function test($req) &#123; echo "hello world"; &#125;&#125;var $array = [1,2,3];$obj = new A();array_map([$obj,'test'],$array); 转载自:4种PHP回调函数风格-Swoole扩展-Swoole文档中心]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>callback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-Askpass-Error]]></title>
    <url>%2F2017%2F05%2F08%2Fgit-askpass-error%2F</url>
    <content type="text"><![CDATA[git 的账号密码错误情况 error前段时间使用 phpstrom 中的 git 出现了一个错误1234Fetch failed error: unable to read askpass response from &apos;..\tmp\intellij-git-askpass.bat&apos; error: failed to execute prompt script (exit code 1) fatal: could not read Username for &apos;http://xxx:3000&apos;: No error 大体情况就是某一次操作的时候账户密码发生了变动,导致本地的 git 没权限去拉取远程库了(因为用的是 https)的方式 解决第一种(推荐): 将远程地址换成 ssh 地址,使用 ssh-key 登录 第二种: 实在不想换的话就是用这种方式1git remote set-url origin https://&lt;username&gt;:&lt;password&gt;@github.com/&lt;username&gt;/&lt;repo_name&gt;.git 将账号密码写入到请求地址当中比如我账户为: gaopengfei 密码为: 123456请求的库的地址是 https://github.com/gaopengfei123123/redis_lbs.git那么我的远程地址就是1git remote set-url origin https://gaopengfei:123456@github.com/gaopengfei123123/redis_lbs.git 参考issues]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>askpass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Transition]]></title>
    <url>%2F2017%2F05%2F06%2Fvue-transition%2F</url>
    <content type="text"><![CDATA[对 vue 的渐变效果的简单使用 单个节点的渐变效果123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;动画测试&lt;/title&gt; &lt;link href="http://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet"&gt; &lt;script src="http://cdn.bootcss.com/vue/2.3.2/vue.js"&gt;&lt;/script&gt; &lt;style media="screen"&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="example"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;!-- 同一个节点的多个显隐效果 --&gt; &lt;transition mode="out-in" enter-active-class="animated fadeInDown" leave-active-class="animated fadeOutDown"&gt; &lt;p v-if="show" key="1"&gt;hello&lt;/p&gt; &lt;p v-else key="2"&gt;world&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; new Vue(&#123; el: '#example', data: &#123; show: true, &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 这里解释一下 &lt;transition&gt; 中的参数问题: mode=&quot;out-in&quot; 采用的切换模式是 先出后进,保证两个节点能平滑的切换显示, 还有一种是 in-out,如果没有指定mode将同时生效,两个元素的动画同时触发这不是我现在需要的 enter-active-class=&quot;animated fadeInDown&quot; 元素显示时添加的 class , 这里使用了 animate.css, leave-active-class=&quot;animated fadeOutDown&quot; 元素消失时显示的动画 key 相同标签名中必须的标识,否则 vue 将不能区分元素内容 一种运用 key 简化判断的一种写法123&lt;transition mode="out-in" enter-active-class="animated fadeInDown" leave-active-class="animated fadeOutDown"&gt; &lt;p :key="status"&gt;&#123;&#123; status &#125;&#125;&lt;/p&gt;&lt;/transition&gt; 它的效果等同于:12345678&lt;transition mode="out-in" enter-active-class="animated fadeInDown" leave-active-class="animated fadeOutDown"&gt; &lt;button v-if="status === 'show'" key="show"&gt; show &lt;/button&gt; &lt;button v-if="status === 'hidden'" key="hidden"&gt; hidden &lt;/button&gt;&lt;/transition&gt; 如果是多重的状态判断这个会很实用 多组件之间的状态过渡123456789101112131415161718192021222324252627&lt;div id="example"&gt; &lt;input type="radio" v-model="view" value="v-a"&gt; &lt;input type="radio" v-model="view" value="v-b"&gt; &lt;!-- 多个组件的过渡效果 --&gt; &lt;transition mode="out-in" enter-active-class="animated fadeInDown" leave-active-class="animated fadeOutDown"&gt; &lt;component v-bind:is="view"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; new Vue(&#123; el: '#example', data: &#123; view: 'v-a' &#125;, methods: &#123;&#125;, components: &#123; 'v-a': &#123; template: '&lt;div&gt;Component A&lt;/div&gt;' &#125;, 'v-b': &#123; template: '&lt;div&gt;Component B&lt;/div&gt;' &#125; &#125; &#125;) &lt;/script&gt; 这种情况下部需要添加 key 值了,因为每次动态渲染的时候都只有一个]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>animate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Axios-Post 提交数据]]></title>
    <url>%2F2017%2F05%2F02%2Fvue-axios-post%2F</url>
    <content type="text"><![CDATA[继 vue-resource 之后, axios 是 vue 官方首推的网络请求组件 axios简介它的功能更强大,而且可以无痛迁移到新的项目当中,有尤大的原话就是: 最近团队讨论了一下，Ajax 本身跟 Vue 并没有什么需要特别整合的地方，使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果，vue-resource 提供的价值和其维护成本相比并不划算，所以决定在不久以后取消对 vue-resource 的官方推荐。已有的用户可以继续使用，但以后不再把 vue-resource 作为官方的 ajax 方案。这里可以去掉 vue-resource，文档也不必翻译了。原文链接 这里还有一份看两眼就是能用的手册 关于 csrf 攻击这篇文章想说的不是怎么用 axios,而是之前碰到了一种情况,就是在 php 框架当中,碰到了 csrf 验证的问题关于 csrf 攻击这里也不会讲,因为前辈们已经说的很详细了,比如这篇通俗易懂的文章 axios 与 csrf-token我常用的两个框架中 laravel 是支持在 header 中设置 csrf-token 的,而 yii 中的默认设置只是在表单提交的内容中检测 csrf-token 相关的字段,使用 axios 提交内容的时候默认并不会出现在 from-data内容当中,比如这样提交的12345678910111213let postUrl = '/route/to/action';let postData = &#123; id : 1, name: "xiaoming", _csrf_token : "&lt;?= Yii::$app-&gt;request-&gt;csrfToken ?&gt;"&#125;axios.post(postUrl,postData) .then(function(res)&#123; console.log(res) &#125;) .catch(function (error) &#123; console.log(error) &#125;) 但是这样的提交形式在 yii2.0 当中是接收不到提交的内容的,因为它的内容是存在了 request payload当中所以使用Yii::$app-&gt;request-&gt;post()是获取不到内容的,想要得到提交的内容需要这样:12345function requestPayload()&#123; $request_payload = file_get_contents('php://input'); return json_decode($request_payload,true);&#125;print_r(requestPayload()); 这样做的缺点就是获取请求都是自己去实现,而不是通过框架的 request 类去处理这么做的前提还是关闭所提交 controller 的 csrf-token 验证,不安全啊同志们! 那么问题来了,用什么样的姿势提交能让框架去识别并自动提取出来 csrf-token 呢? 说了那么多废话终于到正题了,关键就是这个类了:12345678910111213let postUrl = '/route/to/action';let postData = new FormData();postData.append('action', 'ADD');postData.append('param', 0);postData.append('_csrf_token', '&lt;?= Yii::$app-&gt;request-&gt;csrfToken ?&gt;');axios.post(postUrl,postData) .then(function(res)&#123; console.log(res) &#125;) .catch(function (error) &#123; console.log(error) &#125;) 在这之前 bb 了那么多也是想让自己的印象更清晰一点,边说边捋思路,这是当初找到答案的地方github]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery 中$(This) 和 This 的区别]]></title>
    <url>%2F2017%2F05%2F02%2Fjquery-this%2F</url>
    <content type="text"><![CDATA[说一个常识性的东西,帮助自己回忆一下 一句话, $(this)是 jquery 的对象,而 this 是 html 元素对象 什么意思呢? $(this) 可以调用jquery 中的方法12$(this).val()$(this).addClass() 而 this 是属于 html 的对象,属于原生 js,因此不能用 jq 中一些封装好的方法12this.valuethis.id 这两者容易造成混淆的地方就是在调用 jq 方法时使用闭包的情景下:123$('#input').blur(function()&#123; inputCheck(this)&#125;); 在 inputCheck(param) 这个方法中在调用参数的时候就不能再使用 jqery 的方法了,会报函数找不到的错误,因此需要转换一下,一般情景下的转换关系是这样的:1$(this)[0] == this]]></content>
      <categories>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Ssh 的 25 条实用命令]]></title>
    <url>%2F2017%2F04%2F28%2Fssh-command%2F</url>
    <content type="text"><![CDATA[OpenSSH是SSH连接工具的免费版本。telnet，rlogin和ftp用户可能还没意识到他们在互联网上传输的密码是未加密的，但SSH是加密的，OpenSSH加密所有通信（包括密码），有效消除了窃听，连接劫持和其它攻击。此外，OpenSSH提供了安全隧道功能和多种身份验证方法，支持SSH协议的所有版本。 SSH是一个非常伟大的工具，如果你要在互联网上远程连接到服务器，那么SSH无疑是最佳的候选。下面是通过网络投票选出的25个最佳SSH命令，你必须牢记于心。 （注：有些内容较长的命令，在本文中会显示为截断的状态。如果你需要阅读完整的命令，可以把整行复制到您的记事本当中阅读。） 复制SSH密钥到目标主机，开启无密码SSH登录1ssh-copy-id user@host 如果还没有密钥，请使用ssh-keygen命令生成。 从某主机的80端口开启到本地主机2001端口的隧道1ssh -N -L2001:localhost:80 somemachine 现在你可以直接在浏览器中输入 http://localhost:2001访问这个网站。 将你的麦克风输出到远程计算机的扬声器1dd if=/dev/dsp | ssh -c arcfour -C username@host dd of=/dev/dsp 这样来自你麦克风端口的声音将在SSH目标计算机的扬声器端口输出，但遗憾的是，声音质量很差，你会听到很多嘶嘶声。 比较远程和本地文件1ssh user@host cat /path/to/remotefile | diff /path/to/localfile – 在比较本地文件和远程文件是否有差异时这个命令很管用。 通过SSH挂载目录/文件系统1sshfs name@server:/path/to/folder /path/to/mount/point 从http://fuse.sourceforge.net/sshfs.html下载sshfs，它允许你跨网络安全挂载一个目录。 通过中间主机建立SSH连接1ssh -t reachable_host ssh unreachable_host Unreachable_host 表示从本地网络无法直接访问的主机，但可以从 reachable_host 所在网络访问，这个命令通过到 reachable_host 的“隐藏”连接，创建起到 unreachable_host 的连接。 将你的SSH公钥复制到远程主机，开启无密码登录 – 简单的方法1ssh-copy-id username@hostname 直接连接到只能通过主机B连接的主机A1ssh -t hostA ssh hostB 当然，你要能访问主机A才行。 创建到目标主机的持久化连接1ssh -MNf &lt;user&gt;@&lt;host&gt; 在后台创建到目标主机的持久化连接，将这个命令和你~/.ssh/config中的配置结合使用：123Host hostControlPath ~/.ssh/master-%r@%h:%pControlMaster no 所有到目标主机的SSH连接都将使用持久化SSH套接字，如果你使用SSH定期同步文件（使用rsync/sftp/cvs/svn），这个命令将非常有用，因为每次打开一个SSH连接时不会创建新的套接字。 通过SSH连接屏幕1ssh -t remote_host screen –r 直接连接到远程屏幕会话（节省了无用的父bash进程）。 端口检测（敲门）1knock &lt;host&gt; 3000 4000 5000 &amp;&amp; ssh -p &lt;port&gt; user@host &amp;&amp; knock &lt;host&gt; 5000 4000 3000 在一个端口上敲一下打开某个服务的端口（如SSH），再敲一下关闭该端口，需要先安装knockd，下面是一个配置文件示例。 123456789101112[options]logfile = /var/log/knockd.log[openSSH]sequence = 3000,4000,5000seq_timeout = 5command = /sbin/iptables -A INPUT -i eth0 -s %IP% -p tcp –dport 22 -j ACCEPTtcpflags = syn[closeSSH]sequence = 5000,4000,3000seq_timeout = 5command = /sbin/iptables -D INPUT -i eth0 -s %IP% -p tcp –dport 22 -j ACCEPTtcpflags = syn 删除文本文件中的一行内容，有用的修复1ssh-keygen -R &lt;the_offending_host&gt; 在这种情况下，最好使用专业的工具。 通过SSH运行复杂的远程shell命令1ssh host -l user $(&lt;cmd.txt) 更具移植性的版本：1ssh host -l user “`cat cmd.txt`” 通过SSH将MySQL数据库复制到新服务器1mysqldump –add-drop-table –extended-insert –force –log-error=error.log -uUSER -pPASS OLD_DB_NAME | ssh -C user@newhost “mysql -uUSER -pPASS NEW_DB_NAME” 通过压缩的SSH隧道Dump一个MySQL数据库，将其作为输入传递给mysql命令，我认为这是迁移数据库到新服务器最快最好的方法。 删除文本文件中的一行，修复“SSH主机密钥更改”的警告1sed -i 8d ~/.ssh/known_hosts 从一台没有SSH-COPY-ID命令的主机将你的SSH公钥复制到服务器1cat ~/.ssh/id_rsa.pub | ssh user@machine “mkdir ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys” 如果你使用Mac OS X或其它没有ssh-copy-id命令的*nix变种，这个命令可以将你的公钥复制到远程主机，因此你照样可以实现无密码SSH登录。 实时SSH网络吞吐量测试1yes | pv | ssh $host “cat &gt; /dev/null” 通过SSH连接到主机，显示实时的传输速度，将所有传输数据指向/dev/null，需要先安装pv。 如果是Debian：1apt-get install pv 如果是Fedora：1yum install pv （可能需要启用额外的软件仓库）。 如果建立一个可以重新连接的远程GNU screen1ssh -t user@some.domain.com /usr/bin/screen –xRR 人们总是喜欢在一个文本终端中打开许多shell，如果会话突然中断，或你按下了“Ctrl-a d”，远程主机上的shell不会受到丝毫影响，你可以重新连接，其它有用的screen命令有“Ctrl-a c”（打开新的shell）和“Ctrl-a a”（在shell之间来回切换），请访问阅读更多关于screen命令的快速参考。 继续SCP大文件1rsync –partial –progress –rsh=ssh $file_source $user@$host:$destination_file 它可以恢复失败的rsync命令，当你通过VPN传输大文件，如备份的数据库时这个命令非常有用，需要在两边的主机上安装rsync。1rsync –partial –progress –rsh=ssh $file_source $user@$host:$destination_file local -&gt; remote 或1rsync –partial –progress –rsh=ssh $user@$host:$remote_file $destination_file remote -&gt; local 通过SSH W/ WIRESHARK分析流量1ssh root@server.com ‘tshark -f “port !22″ -w -&apos; | wireshark -k -i – 使用tshark捕捉远程主机上的网络通信，通过SSH连接发送原始pcap数据，并在wireshark中显示，按下Ctrl+C将停止捕捉，但也会关闭wireshark窗口，可以传递一个“-c #”参数给tshark，让它只捕捉“#”指定的数据包类型，或通过命名管道重定向数据，而不是直接通过SSH传输给wireshark，我建议你过滤数据包，以节约带宽，tshark可以使用tcpdump替代： 1ssh root@example.com tcpdump -w – ‘port !22′ | wireshark -k -i – 保持SSH会话永久打开1autossh -M50000 -t server.example.com ‘screen -raAd mysession’ 打开一个SSH会话后，让其保持永久打开，对于使用笔记本电脑的用户，如果需要在Wi-Fi热点之间切换，可以保证切换后不会丢失连接。 更稳定，更快，更强的SSH客户端1ssh -4 -C -c blowfish-cbc 强制使用IPv4，压缩数据流，使用Blowfish加密。 使用cstream控制带宽1tar -cj /backup | cstream -t 777k | ssh host ‘tar -xj -C /backup’ 使用bzip压缩文件夹，然后以777k bit/s速率向远程主机传输。Cstream还有更多的功能，请访问了解详情，例如：1echo w00t, i’m 733+ | cstream -b1 -t2 一步将SSH公钥传输到另一台机器1ssh-keygen; ssh-copy-id user@host; ssh user@host 这个命令组合允许你无密码SSH登录，注意，如果在本地机器的~/.ssh目录下已经有一个SSH密钥对，ssh-keygen命令生成的新密钥可能会覆盖它们，ssh-copy-id将密钥复制到远程主机，并追加到远程账号的~/.ssh/authorized_keys文件中，使用SSH连接时，如果你没有使用密钥口令，调用ssh user@host后不久就会显示远程shell。 将标准输入（stdin）复制到你的X11缓冲区1ssh user@host cat /path/to/some/file | xclip 你是否使用scp将文件复制到工作用电脑上，以便复制其内容到电子邮件中？xclip可以帮到你，它可以将标准输入复制到X11缓冲区，你需要做的就是点击鼠标中键粘贴缓冲区中的内容。 原文地址]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go-Http]]></title>
    <url>%2F2017%2F04%2F26%2Fgo-http%2F</url>
    <content type="text"><![CDATA[用于了解 http 包的一些运行机制 首先一个简单的例子123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "net/http" "strings" "log")func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() //解析参数,默认不解析 fmt.Println(r.Form) //在终端中打印出表单内容 fmt.Println("Path", r.URL.Path) fmt.Println("scheme", r.URL.Scheme) fmt.Println(r.Form["url_long"]) //输出指定的参数 for k,v := range r.Form&#123; //遍历打印出表单的值 fmt.Println("key",k) fmt.Println("val", strings.Join(v, "")) &#125; fmt.Fprint(w, "hello gpf!")&#125;func main()&#123; http.HandleFunc("/", sayhelloName) //绑定路由与方法 err := http.ListenAndServe(":9090", nil) //监听 tcp:9090 端口 if err != nil &#123; log.Fatal("ListenAndServe: ",err) &#125;&#125; 文件目录下 go build http.go ./http 再直接访问http://localhost:9090就能看到页面了 运行流程是什么呢?大体的运行流程是介样: 创建 Listen Socket,监听 tcp 协议的 9090 端口,等待请求 收到请求后创建一个 client socket 去解析请求(request) 将请求内容交给 handle request 去处理,处理后返回给 client socket(handler) client socket 收到后台的处理结果返回给用户(response) 我们80%的逻辑都是在第3步内进行的,其他的已经有底层包帮我们实现了 我们的路由绑定机制是怎么实现的?当走到以上的第3步的时候将会进入自己独立的 goroutine ,这也是用户访问互不影响的原因,这一点和 nginx 很像,都是异步非阻塞的处理方式用来应对高并发 在最开始的例子当中我们绑定路由是直接将路由和函数指定了的,这里面发生了什么呢?当调用1http.HandleFunc("/", sayhelloName) 时 因为没有对监听函数传递第二个参数,传了个 nil 进去1http.ListenAndServe(":9090", nil) nil 的位置本应该是一个 handler,如果为空的话,将调用默认的 handler ,即 DefaultServeMux,因为它实现了 Handler 接口所以能处理请求, Handler接口的内容是123type Handler interface&#123; ServeHTTP(ResponseWriter, *Request)&#125; 这个方法就是我们的路由实现器,我们所有的路由指向的方法都是在这里处理的, 可是为什么我的sayhelloName()并没有实现 Handler的接口但还是正常运行了,这怎么回事呢?这是因为 http.HandleFunc()帮你完成了这个接口的实现,文档 自己实现一个简易的路由1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( "fmt" "net/http")//设定一个空的接口体来承载接口type MyMux struct&#123;&#125;//实现 Handler 接口,在这里处理路由相关的内容func (p *MyMux) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; if r.URL.Path == "/" &#123; sayHello(w, r) return &#125; if r.URL.Path == "/login" &#123; loginPage(w, r) return &#125; http.NotFound(w, r) return&#125;func sayHello(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprint(w, "Hello route '/' !")&#125;func loginPage(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "this is login page")&#125;func main() &#123; //实例化结构体 mux := &amp;MyMux&#123;&#125; //当做 handler 注入到监听服务当中去 http.ListenAndServe(":9090", mux)&#125; 如果想自己实现路由的处理也可以这样试试,但是我不想平白的用一个空的 struct 去承载这个啊,我们可以试试这个 ServeMux12345678910111213141516171819package mainimport ( "fmt" "net/http")func main() &#123; mux := http.NewServeMux() mux.HandleFunc("/login", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "this is login page") &#125;) mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "hello your first page") &#125;) http.ListenAndServe(":9090", mux)&#125; 说了这么多其实还是云里雾里的,不过没关系,可以先放在这里,等用的多了自然也能想开了]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-Comma-Switch]]></title>
    <url>%2F2017%2F04%2F24%2Fgo-comma-switch%2F</url>
    <content type="text"><![CDATA[简单介绍下 comma-ok 和 switch 用来判定变量类型上篇博客介绍了接口,接口在实际应用中可以当做一个万用变量来用,可以用一个空接口来存储多种类型的变量但是,当我们需要取出来用的时候就要头疼一下取出的到底是哪种类型的数据了 comma-okvalue, ok := element.(type) element 就是我们要判断的变量,括号中是要判断的类型,value 就是变量的值,ok 是 bool 类型,true||false 123456789101112131415161718192021222324252627282930313233343536package mainimport ( "fmt" "strconv")type Element interface&#123;&#125; //定义一个空接口type List []Element //定义一个由空接口组成的数组类型type Person struct &#123; name string age int&#125;func (p Person) String() string &#123; return "&lt; " + p.name + "-" + strconv.Itoa(p.age) + "years old /&gt;"&#125;func main() &#123; list := make(List, 3) list[0] = 1 list[1] = "shakalaka" list[2] = Person&#123;"Gao", 25&#125; for index, element := range list &#123; if value, ok := element.(int); ok &#123; fmt.Printf("list[%d] is int and value is %d \n", index, value) &#125; else if value, ok := element.(string); ok &#123; fmt.Printf("list[%d] is string and value is %s \n", index, value) &#125; else if value, ok := element.(Person); ok &#123; fmt.Printf("list[%d] is Person and value is %s \n", index, value) &#125; else &#123; fmt.Printf("list[%d] is undefined", index) &#125; &#125;&#125; 这里就是调用 go 提供的内置函数, 在 php 当中就是 is_null,is_array这类的函数方法,这种写法判定单个类型的时候比较方便,但是类型一多就会出现多个 if-else 这样很不优雅,于是就有了下面的写法 switch用代码看是最直观的1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "fmt" "strconv")type Element interface&#123;&#125; //定义一个空接口type List []Element //定义一个由空接口组成的数组类型type Person struct &#123; name string age int&#125;func (p Person) String() string &#123; return "&lt; " + p.name + "-" + strconv.Itoa(p.age) + "years old /&gt;"&#125;func main() &#123; list := make(List, 3) list[0] = 1 list[1] = "shakalaka" list[2] = Person&#123;"Gao", 25&#125; for index, element := range list &#123; switch value := element.(type) &#123; case int: fmt.Printf("list[%d] is int and value is %d \n", index, value) case string: fmt.Printf("list[%d] is string and value is %s \n", index, value) case Person: fmt.Printf("list[%d] is Person and value is %s \n", index, value) default: fmt.Printf("list[%d] is undefined", index) &#125; &#125;&#125; 这样就能批量判定类型了这里需要注意一下, element.(type) 这种写法只能出现在 switch 当中,判定单个类型的时候还是老实的用 value , ok := element.(type) 这种写法看到这里我们发现其实调用的都是同一个内置函数,就是添加了一个 switch 这样的使用情景]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>comma-ok</tag>
        <tag>switch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-Interface]]></title>
    <url>%2F2017%2F04%2F19%2Fgo-interface%2F</url>
    <content type="text"><![CDATA[关于 go 语言接口的简单介绍接口对于 go 实现面向对象来说非常重要,如果没有它 go 的结构体(struct)也就只能存储一些信息,但是相关的方法将会变得非常麻烦 什么是接口?接口就是制定一个通用的规范,只要符合这个规范就能使用这个借口(听起来像是车轱辘话) 接口类型比如我定义了一个接口1234type example interface&#123; a() b()&#125; 他定义了两个方法,只要有结构体中含有 a(),b()两个方法就能实现这个接口,通过接口来统一调用,如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//package main//import "fmt"//定义一个基本的类type Human struct&#123; name string age int phone string&#125;type Student struct&#123; Human //继承 human 中的字段 school string loan float32&#125;type Employee struct&#123; Human company string money float32&#125;//Human 实现 Sayhi 方法func (h Human) Sayhi()&#123; fmt.Printf("hi my name is %s and my phone is %s \n", h.name,h.phone)&#125;//Human 实现 Sing 方法func (h Human) Sing(lyrics string) &#123; fmt.Println("galigaygay galigaygay ...",lyrics)&#125;//student 复写 Sayhi 方法func (sdt Student) Sayhi() &#123; fmt.Printf("my name is %s and my school is %s \n", sdt.name,sdt.school)&#125;//定义一个通用的接口type Men interface&#123; Sayhi() Sing(lyrics string)&#125;func main () &#123; //实例化两种类 mike := Student&#123;Human&#123;"mike",25,"18333636999"&#125;,"MIT",3.14&#125; jack := Employee&#123;Human&#123;"jack",30,"18333636998"&#125;,"hotcast",20000&#125; //定义一个接口变量 var i Men //接口实现了 Student 类的方法 fmt.Println("下面有请 mike 开始他的表演:") i = mike i.Sayhi(); i.Sing("dongci daci") //接口实现了 Employee 类的方法 fmt.Println("下面有请 mike 开始他的表演:") i = jack i.Sayhi(); i.Sing("haha haha haha")&#125; 这里的 Men 接口被所有继承了Human的结构体的方法所实现,所以这些实例化的结构体可以赋值给Men的接口变量上,我们在 go 语言中的面向对象开发可以说就是面向接口在开发,由接口来组成一个个的变量,这和 php 的接口有所不同,在 php 中,接口是需要被 class 来继承,然后class 中去实现 interface 中指定的方法,比如12345678910111213interface Human&#123; function sayHi(); function sing();&#125;class Student implements Human&#123; public function sayHi()&#123; // TODO: &#125; public function sing()&#123; // TODO: &#125;&#125; 这样子的, 每个类需要指定继承哪些接口才可以去实现接口,而 go 和 php 正好相反,是谁实现了我的规范谁就可以用我的接口,实现顺序正好倒过来了 再举一个接口的例子12345678910111213141516171819202122package mainimport ( "fmt" "strconv")type Human struct &#123; name string age int phone string&#125;// 这里需要把 int 类型转换成字符串,否则使用 + 来连接字符的时候报数据类型不匹配的错误func (h Human) String() string &#123; return "&lt;" + h.name + "-" + strconv.Itoa(h.age) + "years old ,phone is " + h.phone + "/&gt;"&#125;func main() &#123; Duck := Human&#123;"duck", 22, "110-120-119"&#125; fmt.Println("this human is :", Duck)&#125; 上述例子当中我们实现了 fmt.Println 中的一个接口`gotype Stringer interface { String() string} 这样之后,调用 Human 的 String() 函数就能被 fmt.Println() 所用了]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go-Simple-Webserver-Demo]]></title>
    <url>%2F2017%2F04%2F18%2Fgo-simple-webserver-demo%2F</url>
    <content type="text"><![CDATA[用 go 写的一个简单的 http 服务 123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "net/http" "strings" "log")func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() //解析参数,默认不解析 fmt.Println(r.Form) //在终端中打印出表单内容 fmt.Println("Path", r.URL.Path) fmt.Println("scheme", r.URL.Scheme) fmt.Println(r.Form["url_long"]) //输出指定的参数 for k,v := range r.Form&#123; //遍历打印出表单的值 fmt.Println("key",k) fmt.Println("val", strings.Join(v, "")) &#125; fmt.Fprint(w, "hello gpf!")&#125;func main()&#123; http.HandleFunc("/", sayhelloName) //绑定路由与方法 err := http.ListenAndServe(":9090", nil) //监听 tcp:9090 端口 if err != nil &#123; log.Fatal("ListenAndServe: ",err) &#125;&#125; 打包运行之后访问 http://localhost:9090/index?url_long=aa&amp;url_long=23445&amp;name=gpf 将在页面和终端都有显示,前后台的逻辑也是在这里执行的]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>webserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-Submodule]]></title>
    <url>%2F2017%2F04%2F11%2Fgit-submodule%2F</url>
    <content type="text"><![CDATA[项目中经常会使用到第三方的 git 库,将三方库整合到项目中最简单的办法就是复制粘贴,但是如果这个库升级了一个很酷炫的功能,你要怎么整合进来呢?这就是本次要介绍的 git-submodule 操作,直接把第三方的版本库合并到自己的库中. 添加第三方库我这里是自己开了两个库做测试,主库叫 body,另一个库叫 leg 首先在本地的body库中添加leg123git clone https://git.oschina.net/gaofeifps/body.gitcd bodygit submodule add https://git.oschina.net/gaofeifps/leg.git 这时查看下状态会多两个文件123456789➜ body git:(master) ✗ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits)Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: .gitmodules new file: leg 这就多了一个 leg的库,和一个.gitmodules的文件,现在提交一下1git commit -am &quot;add leg&quot; 在其他地方使用合并后的版本库本地提交了版本之后可以提交到远程试一下1git push 这时去远程库中看的话库中的内容是这样的这里有个奇怪的 leg @ 6dec2fa,明明是没有的啊?点一下原来是一个快捷方式,直接给连接到了 leg库的地址,版本库中不会存第三方引入库的实体文件,而是通过 .gitmodules的方式存储三方的联系方式,当下载到本地运行的时候才会再拉取文件 而且这个时候在其他的地方安装body这个库的时候直接运行 git clone 是生成不了完整的文件的,缺少了 leg库的文件因为这个时候的 body/leg目录是空的需要多走一步,这时为什么呢?我们下面会讲到原因12345git clone https://git.oschina.net/gaofeifps/body.gitgit submodule init &amp;&amp; git submodule update#下面这一句的效果和上面三条命令的效果是一样的,多加了个参数 `--recursive`git clone https://git.oschina.net/gaofeifps/body.git --recursive 这时才是一个完整的库 将三方库同步到主线之前的一些步骤其实还不完整,因为 body/leg 这个目录中的文件并没有和主线在一条线上,这也是为什么在远程库的 leg 目录是空的,因为在 master 分支里面它确实是空的,文件是在另一个分支上,我们先去看一下1234cd path/to/body/leg➜ leg git:(6dec2fa) git branch* (HEAD detached at 6dec2fa) master 别的文件的分支都是 master 到这个文件的时候就是 6dec2fa分支了,其实这个值也是 leg库当前的 commitId而且如果不把第三方的库纳入自己的主线的话会非常的危险,因为你对项目中的三方库发生的任何改动都不会对主线产生任何影响,被主线遗忘了,因此我们还需要接下来的操作12cd path/to/body/leggit checkout master 更新第三方库这里有个问题就是如果body/leg发生了更新就首先在这个文件中提交一个commit,然后在body这个目录下再 commit一次第一次 commit 是为了更新 leg的版本控制,第二次更新是更新body的版本控制,同时更新 leg库在body的指针 如果更新的比较多,可以运行 批量更新第三方库假设你的项目当中引入了100个第三方的库,你需要同步的时候难道还要每一个都要执行:123cd module-dir/git checkout mastergit pull 是不是想起了小学被老师罚抄一百遍的恐惧当中了?少年,多看看文档准没错的,这些东西 git 早就帮你想好了具体操作可以看一下git help submodule有相关的介绍的不想看文档的就直接告诉你123git submodule foreach &lt;command&gt;比如:git submodule foreach git checkout master 这条命令就会按照 .gitmodules会根据path寻找所有的三方模块,并在每一个模块中都执行 foreach 后的命令,比如你想批量更新模块到最新的时候就:1git submodule foreach git submodule update 画个重点(敲黑板!)如果像让你引入的第三方库leg符合你自己的定制,你在里面发生了一些修改,但是这些修改并不能提交到远程去,因为你的提交会让第三方库的作者产生困扰:我写的好好的一个轮子你给定制成这样,还怎么去给其他的人用? 而且这个问题很严重,如果你本地的leg和body都更新了,但是 第三方的leg不能提交到远程,而body提交上去了,那么与你同使用一个版本库的小伙伴就会因为当前项目leg的指针地址找不到而产生报错 所以如果有定制的需要就得去fork这个项目到你自己的 github 上,然后自己想怎么折腾都随意了,但是怎么去既有定制,还能保持和轮子作者的版本同步呢? 怎么保持与作者同步?首先是自己有一个 fork 的三方项目,然后在自己本地添加一个三方的源123456789101112cd path/to/body/leg➜ leg git:(master) git remote -vorigin https://git.oschina.net/gaofeifps/leg.git (fetch)origin https://git.oschina.net/gaofeifps/leg.git (push)#添加第三方包的源地址➜ leg git:(master) git remote add dist_source https://git.oschina.net/xxxx/leg.git➜ leg git:(master) git remote -vdist_source https://git.oschina.net/xxxx/leg.git (fetch) #这个是三方的源地址dist_source https://git.oschina.net/xxxx/leg.git (push)origin https://git.oschina.net/gaofeifps/leg.git (fetch) #这个是你 fork 的项目地址origin https://git.oschina.net/gaofeifps/leg.git (push) 这样的话可以拉取源文件到本地并合并本地代码1git pull dist_source master 修复一下版本冲突的文件,确认没有问题之后提交到自己 fork 的库中1git push origin master 这样其他人就能正常使用了 写了这么多忽然发现:还是复制粘贴比较省事啊! 那么 怎么删除submodule?在当前 git 版本1.7.8之前,删除指定的 submodule 的命令是1git rm &lt;submodule-name&gt; 在新版的 git 下,则是运行以下命令1git submodule deinit &lt;submodule-name&gt; 查看本地有哪些三方模块可以查看 .gitmodules1234➜ body git:(master) cat .gitmodules[submodule &quot;leg&quot;] path = leg url = https://git.oschina.net/gaofeifps/leg.git]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Npm-DTrace]]></title>
    <url>%2F2017%2F04%2F10%2Fnpm-DTrace%2F</url>
    <content type="text"><![CDATA[安装npm模块的时候有时候会提示Error: Cannot find module &#39;./build/Release/DTraceProviderBindings 虽然会正常运行但是总是报这个错也是很不爽的,查了下相关的 issues比较直接的解决方法是1sudo npm install dtrace-provider ubuntu 和 macos 上都有效 这是一个历史遗留的问题,开发者已经逐渐替代了这个模块,所以说影响不大,如果觉的终端总是报错很烦就这样试试吧]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-Composer-Install]]></title>
    <url>%2F2017%2F04%2F10%2Fdocker-composer-install%2F</url>
    <content type="text"><![CDATA[安装 docker-composer123curl -L https://github.com/docker/compose/releases/download/1.1.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 可能会有被墙的情况,可以找一下国内的云服务商,比如 DaoCloud]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-compose</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brew-Update]]></title>
    <url>%2F2017%2F04%2F09%2Fbrew-update%2F</url>
    <content type="text"><![CDATA[brew更新软件时常用的操作 安装 brewruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/Go/install)&quot; 搜索brew search MySQL 查看程序具体信息brew info mysql 更新 brewbrew update 更新软件brew upgrade mysql如果不指定更新哪个则会更新所有可以更新的软件 清理缓存(更新完后的操作)brew cleanup 查看本地所有可更新的工具brew outdated]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii-Multi-Database]]></title>
    <url>%2F2017%2F04%2F08%2Fyii-multi-database%2F</url>
    <content type="text"><![CDATA[在项目中经常会碰到多个数据库的情况,在 yii 中也是可以快速设置的演示的版本是 basic 版,但是原理很好理解 编辑配置文件 @app/config/web.php1234......'db' =&gt; require(__DIR__ . '/db.php'), //框架提供的一个默认连接'localDb' =&gt; require(__DIR__ . '/db2.php'), //这个是我们新加的一个连接配置...... 在同目录下的 db2.php 内容格式和 db.php 格式一样,只是连接不同 修改 model 中需要使用的 connection id这时再在想改的 model 中复写 getDb() 方法1234567891011121314151617181920class Members extends \yii\db\ActiveRecord&#123; /** * @inheritdoc */ public static function tableName() &#123; return 'members'; &#125; /** * @return \yii\db\Connection the database connection used by this AR class. */ public static function getDb() &#123; return Yii::$app-&gt;get('localDb'); &#125; ......some functions.................&#125; 这个 model 中我们使用了 localDb 的链接配置,可以追踪代码 \yii\db\ActiveRecord中的 getDb() 方法,123456789101112//in \yii\db\ActiveRecord/** * Returns the database connection used by this AR class. * By default, the "db" application component is used as the database connection. * You may override this method if you want to use a different database connection. * @return Connection the database connection used by this AR class. */ public static function getDb() &#123; return Yii::$app-&gt;getDb(); &#125; 有这么一段,既然已经显示出来 Yii::$app 这种核心的东西了,说明已经离那个connection容器已经不远了再追踪到getDb() 显示的是 $this-&gt;get(&#39;db&#39;) 转换一下不就是默认使用的 Yii::$app-&gt;get(&#39;db&#39;) 吗? 于是回到最开始的 model 中,将其重写为 Yii::$app-&gt;get(&#39;localDb&#39;),之后我们再使用这个 model 的时候就是使用的id 为localDb的 connection 单例了]]></content>
      <categories>
        <category>yii2</category>
      </categories>
      <tags>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json-Format]]></title>
    <url>%2F2017%2F04%2F08%2Fjson-format%2F</url>
    <content type="text"><![CDATA[如何将 json 格式化打印出来 想练手的可以手写一个出来,比如12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass Helper&#123; public static function jsonFormat($data, $indent=null)&#123; // 对数组中每个元素递归进行urlencode操作，保护中文字符 array_walk_recursive($data, [self::class,'jsonFormatProtect']); // json encode $data = json_encode($data); // 将urlencode的内容进行urldecode $data = urldecode($data); // 缩进处理 $ret = ''; $pos = 0; $length = strlen($data); $indent = isset($indent)? $indent : ' '; $newline = PHP_EOL; $prevchar = ''; $outofquotes = true; for($i=0; $i&lt;=$length; $i++)&#123; $char = substr($data, $i, 1); if($char=='"' &amp;&amp; $prevchar!='\\')&#123; $outofquotes = !$outofquotes; &#125;elseif(($char=='&#125;' || $char==']') &amp;&amp; $outofquotes)&#123; $ret .= $newline; $pos --; for($j=0; $j&lt;$pos; $j++)&#123; $ret .= $indent; &#125; &#125; $ret .= $char; if(($char==',' || $char=='&#123;' || $char=='[') &amp;&amp; $outofquotes)&#123; $ret .= $newline; if($char=='&#123;' || $char=='[')&#123; $pos ++; &#125; for($j=0; $j&lt;$pos; $j++)&#123; $ret .= $indent; &#125; &#125; $prevchar = $char; &#125; return $ret; &#125; public static function jsonFormatProtect(&amp;$val)&#123; if($val!==true &amp;&amp; $val!==false &amp;&amp; $val!==null)&#123; $val = urlencode($val); &#125; &#125;&#125;$array = [ 'key1' =&gt; 123, 'key2' =&gt; 'abc', 'key3' =&gt; '中文测试'];$json = Helper::jsonFormat($array);echo '&lt;/pre&gt;';print_r($json); 转自博客 原文 还有一种方法就是使用 json_encode() 函数,它再不断的添加参数来丰富它的功能,上面同样的操作可以简化成这样:12345678910&lt;?php$array = [ 'key1' =&gt; 123, 'key2' =&gt; 'abc', 'key3' =&gt; '中文测试'];$json = json_encode($$array, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES | JSON_NUMERIC_CHECK);echo '&lt;/pre&gt;';print_r($json); 想知道 json_encode更多的参数可以看文档 文档地址]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Next-Title]]></title>
    <url>%2F2017%2F04%2F07%2Fhexo-next-title%2F</url>
    <content type="text"><![CDATA[hexo-next 是一个很完美的组合,这次我碰到的问题就是 title 不能显示&lt;hello-world/&gt; 这样的文本 比如你的网站配置文件_config.yml的内容是这样的123456# Sitetitle: &lt;hello-world/&gt;subtitle: 代码改变世界description: heyauthor: GPFlanguage: zh-Hans 如果这么写的话是根本不会正常输出出来的,于是我转换成实体格式12# Sitetitle: &amp;lt;hello-world/&amp;gt; 这里出现的问题是左边的不能正常显示出 &lt;而右边的可以正常显示&gt;,发现 title: 后不能出现&amp;特殊字符,看的比较匆暂时没理解是什么原因,但是这样写对于自己的感官上也不怎么好,于是就看了下模板的代码,原来是 swig 的模板引擎,虽然我擅长的是 php,但是我也是用过模板引擎的人! 这样就可以做很多事情了,再说 symfony 也是用的 swig. 于是乎进行一下操作: 打开@app/themes/next/layout/_partials/header.swig,找到 class=&quot;site-title&quot;,把这个标签改成这样:1&lt;span class=&quot;site-title&quot;&gt;&#123;&#123; config.title | escape &#125;&#125;&lt;/span&gt; 这样就行了 注意,如果是本地修改的 _config.yml文件需要重启 hexo server 才能显示效果]]></content>
      <tags>
        <tag>hexo-next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deploymentadd git]]></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Auth]]></title>
    <url>%2F2017%2F04%2F01%2Flaravel-auth%2F</url>
    <content type="text"><![CDATA[原文出处 auth提供了很方便的登录体系，已经做到了开箱即用的便捷，但是任何方便的工具都是需要花费学习成本的，了解的过程就由些痛苦了：） 本着松鼠过冬的原则，自己是能写一点是一点，以后忘记的话也能立即捡起来 安装auth系统1php artisan make:auth 默认会安装基于user表的登录验证，现在我们需要增加另一个表的登录验证（比如后台的数据表）编辑config/auth.php,我们需要指定的就是guards和providers这两个数组，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?phpreturn [ /* |-------------------------------------------------------------------------- | Authentication Defaults |-------------------------------------------------------------------------- | | This option controls the default authentication &quot;guard&quot; and password | reset options for your application. You may change these defaults | as required, but they&apos;re a perfect start for most applications. | */ &apos;defaults&apos; =&gt; [ &apos;guard&apos; =&gt; &apos;web&apos;, &apos;passwords&apos; =&gt; &apos;users&apos;, ], /* |-------------------------------------------------------------------------- | Authentication Guards |-------------------------------------------------------------------------- | | Next, you may define every authentication guard for your application. | Of course, a great default configuration has been defined for you | here which uses session storage and the Eloquent user provider. | | All authentication drivers have a user provider. This defines how the | users are actually retrieved out of your database or other storage | mechanisms used by this application to persist your user&apos;s data. | | Supported: &quot;session&quot;, &quot;token&quot; | */ &apos;guards&apos; =&gt; [ //......// //这里新加的一组配置，provider的配置在下面有 &apos;admin&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;session&apos;, &apos;provider&apos; =&gt; &apos;admin&apos;, ], //.......// ], /* |-------------------------------------------------------------------------- | User Providers |-------------------------------------------------------------------------- | | All authentication drivers have a user provider. This defines how the | users are actually retrieved out of your database or other storage | mechanisms used by this application to persist your user&apos;s data. | | If you have multiple user tables or models you may configure multiple | sources which represent each model / table. These sources may then | be assigned to any extra authentication guards you have defined. | | Supported: &quot;database&quot;, &quot;eloquent&quot; | */ &apos;providers&apos; =&gt; [ //.............// //这就是新加的配置，我们指定了 Admin 这个模型 &apos;admin&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;eloquent&apos;, &apos;model&apos; =&gt; App\Models\Admin::class, ], //.............// ], /* |-------------------------------------------------------------------------- | Resetting Passwords |-------------------------------------------------------------------------- | | You may specify multiple password reset configurations if you have more | than one user table or model in the application and you want to have | separate password reset settings based on the specific user types. | | The expire time is the number of minutes that the reset token should be | considered valid. This security feature keeps tokens short-lived so | they have less time to be guessed. You may change this as needed. | */ &apos;passwords&apos; =&gt; [ &apos;users&apos; =&gt; [ &apos;provider&apos; =&gt; &apos;users&apos;, &apos;table&apos; =&gt; &apos;password_resets&apos;, &apos;expire&apos; =&gt; 60, ], ],]; 新建模型 App/Models/Admin1php artisan make:model Models/Admin -m 编辑模型123456789101112131415161718192021222324&lt;?phpnamespace App\Models;use Illuminate\Notifications\Notifiable;use Illuminate\Foundation\Auth\User as Authenticatable;//这里继承了auth的验证模型 其实和User的一样class Admin extends Authenticatable&#123; use Notifiable; protected $table=&apos;admin&apos;; public $timestamps = false; protected $primaryKey = &apos;id&apos;; protected $fillable = [ &apos;name&apos;, &apos;email&apos;, &apos;password&apos;, ]; protected $hidden = [ &apos;password&apos;, &apos;remember_token&apos;, ];&#125; 编辑数据迁移文件 database/migrations/xxxx_admin_table.php123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpuse Illuminate\Support\Facades\Schema;use Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;/*** Migration auto-generated by Sequel Pro Laravel Export* @see https://github.com/cviebrock/sequel-pro-laravel-export*/class CreateAdminTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::create(&apos;admin&apos;, function (Blueprint $table) &#123; $table-&gt;increments(&apos;id&apos;); $table-&gt;string(&apos;name&apos;); $table-&gt;string(&apos;email&apos;)-&gt;unique(); $table-&gt;string(&apos;password&apos;); $table-&gt;rememberToken(); $table-&gt;timestamps(); &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::dropIfExists(&apos;admin&apos;); &#125;&#125; 编辑数据填充文件，这一步懒得折腾可以直接手动添加数据 编辑 Faker 这个数据模拟的类 database/factories/ModelFactory.php 添加一下内容,是根据我们刚创建的Models/Admin模型而填充的内容 123456789101112//other code...........$factory-&gt;define(App\Models\Admin::class, function (Faker\Generator $faker) &#123; static $password; return [ &apos;name&apos; =&gt; $faker-&gt;name, &apos;email&apos; =&gt; $faker-&gt;safeEmail, &apos;password&apos; =&gt; $password ?: $password = bcrypt(&apos;secret&apos;), &apos;remember_token&apos; =&gt; str_random(10), ];&#125;); 编辑database/seeds/AdminTableSeeder.php123456789101112131415161718&lt;?phpuse Illuminate\Database\Seeder;class AdminsTableSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; factory(&apos;App\Models\Admin&apos;,3)-&gt;create([ &apos;password&apos; =&gt; bcrypt(&apos;123456&apos;) ]); &#125;&#125; 将自动填充文件写入总的Seeder文件当中123456789101112131415//in database/seeds/DatabaseSeeder.phpclass DatabaseSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; // $this-&gt;call(UsersTableSeeder::class); $this-&gt;call(AdminsTableSeeder::class); &#125;&#125; 执行数据库迁移操作 --seed 顺便执行数据填充操作1php artisan migrate --seed 好了,到这一步数据库就已经有了admin 这个表,而且里面出现了三条测试数据,我们接着看看控制器里是怎么操作的: 首先创建相应的控制器:12php artisan make:controller Admin/LoginControllerphp artisan make:controller Admin/HomeController Admin/LoginController.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpnamespace App\Http\Controllers\Admin;use App\Http\Controllers\Controller;use Illuminate\Http\Request;use Illuminate\Foundation\Auth\AuthenticatesUsers;class LoginController extends Controller&#123; /* |-------------------------------------------------------------------------- | Login Controller |-------------------------------------------------------------------------- | | This controller handles authenticating users for the application and | redirecting them to your home screen. The controller uses a trait | to conveniently provide its functionality to your applications. | */ use AuthenticatesUsers; /** * Where to redirect users after login / registration. * * @var string */ protected $redirectTo = &apos;/admin/dash&apos;; protected $username; /** * Create a new controller instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware(&apos;guest:admin&apos;, [&apos;except&apos; =&gt; &apos;logout&apos;]); $this-&gt;username = config(&apos;admin.global.username&apos;); &#125; /** * 重写登录视图页面 */ public function showLoginForm() &#123; return view(&apos;admin.login.index&apos;); &#125; /** * 自定义认证驱动 */ protected function guard() &#123; return auth()-&gt;guard(&apos;admin&apos;); &#125; /** * 重写方法，让验证字段改成name 而不是默认的email */// protected function username()&#123;// return &apos;name&apos;;// &#125;&#125; Admin/HomeController.php1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\Http\Controllers\Admin;use Illuminate\Http\Request;use App\Http\Requests;use App\Http\Controllers\Controller;use Auth;class HomeController extends Controller&#123; /** * Create a new controller instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware(&apos;auth.admin:admin&apos;); &#125; /** * Show the application dashboard. * * @return \Illuminate\Http\Response */ public function index() &#123; dd(&apos;后台首页，当前用户名：&apos;.auth(&apos;admin&apos;)-&gt;user()-&gt;name); &#125;&#125; 因为在LoginController中也使用了 guest这个中间件,而系统自带的那个也使用了它,因此需要在这个中间件里面做一下区分 编辑 app/Http/Kernel.php12345678910public function handle($request, Closure $next, $guard = null) &#123; if (Auth::guard($guard)-&gt;check()) &#123;// return redirect(&apos;/home&apos;); $url = $guard ? &apos;admin/dash&apos;:&apos;/home&apos;; return redirect($url); &#125; return $next($request); &#125; 而在 Admin/HomeController这里,因为验证需要登录才能进入,我们给他也加了一个验证中间件 AdminAuthMiddlware1php artisan make:middleware AdminAuthMiddlware 编辑AdminAuthMiddlware123456789101112131415161718192021222324252627&lt;?phpnamespace App\Http\Middleware;use Closure;use Illuminate\Support\Facades\Auth;class AdminAuthMiddleware&#123; /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next,$guard = null) &#123; //判定是否已经登录，如果没由登录则跳转到登录界面 if (Auth::guard($guard)-&gt;guest()) &#123; if ($request-&gt;ajax() || $request-&gt;wantsJson()) &#123; return response(&apos;Unauthorized.&apos;, 401); &#125; else &#123; return redirect()-&gt;guest(&apos;admin/login&apos;); &#125; &#125; return $next($request); &#125;&#125; 在路由文件里添加对应的路由12345678910// in routes/web.php//后台登录部分Route::group([&apos;prefix&apos; =&gt; &apos;admin&apos;,&apos;namespace&apos; =&gt; &apos;Admin&apos;],function ($router)&#123; $router-&gt;get(&apos;login&apos;, &apos;LoginController@showLoginForm&apos;)-&gt;name(&apos;admin.login&apos;); $router-&gt;post(&apos;login&apos;, &apos;LoginController@login&apos;); $router-&gt;any(&apos;logout&apos;, &apos;LoginController@logout&apos;); $router-&gt;get(&apos;dash&apos;, &apos;HomeController@index&apos;);&#125;); 做到这一步其实就已经算是完成了,剩下的视图部分可以按照resources/views/auth中的内容创建一个resource/views/admin目录,resource/views/admin/login/index.blade.php就是后台登录界面,注意这里的表单提交地址要按刚才路由文件中写的指向后台的登录控制器中,route(&#39;admin.login&#39;) 这一段是我按照原文操作一遍后自己写了一遍,算是了解了auth的大致运行过程,其后就是翻一下源码进行解析了,为了controller中的代码好看一点其后的运作并不少,但是解耦做的非常不错]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Error-Log]]></title>
    <url>%2F2017%2F04%2F01%2Flaravel-error-log%2F</url>
    <content type="text"><![CDATA[laravel有一套方便的错误采集和报错机制，如果是开发api的时候我们不需要报错页面显示的那么详细，只想返回一些错误信息，而不用把所有的响应信息都返回到 controller 当中才行 之前的步骤是： 1router-&gt;beforeMiddlware-&gt;controller-&gt;someService-&gt;controller-&gt;afterMiddleware-&gt; yourInfo 我们想在这任何一个环节报错的时候都能停止掉运行流程直接返回信息 就需要接下来要说的一个类 Exception。 我们自定义的错误文件也是都放在 app/Exception 当中，比如我自定义一个 TestException1234567891011&lt;?phpnamespace App\Exceptions;class TestException extends \Exception&#123; public function responseJson()&#123; $msg = config('errors.user.'.$this-&gt;getMessage()); return \ApiResponse::error($msg); &#125;&#125; 这里面我自定义了一个responseJson()的方法，为了处理我返回的信息 然后我在同文件夹下的 Handler.php 我们返回的错误在这里集中处理 这里的两个方法report()和render() report()会优先执行，用于将错误发送到第三方服务中去，render()就是最终要返回的结果，我们的目标就是这个函数1234567891011121314/** * Render an exception into an HTTP response. * * @param \Illuminate\Http\Request $request * @param \Exception $e * @return \Illuminate\Http\Response */ public function render($request, Exception $e) &#123; if($e instanceof TestException)&#123; return $e-&gt;responseJson(); &#125; return parent::render($request, $e); &#125; 这里用了instanceof进行比较，如果是来自TestException的报错就会执行我们刚才自定义好的方法，内容当然也可以随便定义了 怎么使用呢？ 只需要在控制器中任何你需要报错的地方1throw new TestException(&apos;system_busy&apos;); 括号内的内容可以通过它的getMessage()方法获得 参考文档]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Pip]]></title>
    <url>%2F2017%2F04%2F01%2Fpip%2F</url>
    <content type="text"><![CDATA[pip语言环境配置出错root@ubuntu:~# locale12345678910111213141516locale: Cannot set LC_ALL to default locale: No such file or directoryLANG=en_US.UTF-8LANGUAGE=LC_CTYPE=&quot;en_US.UTF-8&quot;LC_NUMERIC=zh_CN.UTF-8LC_TIME=zh_CN.UTF-8LC_COLLATE=&quot;en_US.UTF-8&quot;LC_MONETARY=zh_CN.UTF-8LC_MESSAGES=&quot;en_US.UTF-8&quot;LC_PAPER=zh_CN.UTF-8LC_NAME=zh_CN.UTF-8LC_ADDRESS=zh_CN.UTF-8LC_TELEPHONE=zh_CN.UTF-8LC_MEASUREMENT=zh_CN.UTF-8LC_IDENTIFICATION=zh_CN.UTF-8LC_ALL= root@ubuntu:~# export LC_ALL=C12345678910111213141516root@ubuntu:~# localeLANG=en_US.UTF-8LANGUAGE=LC_CTYPE=&quot;C&quot;LC_NUMERIC=&quot;C&quot;LC_TIME=&quot;C&quot;LC_COLLATE=&quot;C&quot;LC_MONETARY=&quot;C&quot;LC_MESSAGES=&quot;C&quot;LC_PAPER=&quot;C&quot;LC_NAME=&quot;C&quot;LC_ADDRESS=&quot;C&quot;LC_TELEPHONE=&quot;C&quot;LC_MEASUREMENT=&quot;C&quot;LC_IDENTIFICATION=&quot;C&quot;LC_ALL=C DONE! 原文[另一个参]]></content>
  </entry>
  <entry>
    <title><![CDATA[Brew权限问题]]></title>
    <url>%2F2017%2F03%2F31%2Fbrew-install%2F</url>
    <content type="text"><![CDATA[在一个新的环境下安装 homebrew 新装系统时难免会遇到权限的问题，在老版系统下（osx 10.10.* )需要一些权限设置，方式如下: 12345sudo chown -R $(whoami):admin /usr/localsudo chown -R $(whoami) /Library/Caches/Homebrewbrew doctorbrew prunebrew update]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Next 的一些配置]]></title>
    <url>%2F2017%2F03%2F30%2Fwebconfig%2F</url>
    <content type="text"><![CDATA[目前对 hexo-next 添加的功能 搜索1$ npm install hexo-generator-searchdb --save 站点配置文件12345search: path: search.xml field: post format: html limit: 10000 next主题配置文件123# Local searchlocal_search: enable: true 生成 sitemap12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 支持 hexo deploy1$ npm install hexo-deployer-git --save 将 next 主题的依赖包由 bootcdn 提供在主题配置文件中1234567891011121314151617181920212223242526272829303132333435363738394041424344vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: //cdn.bootcss.com/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: //cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: //cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: //cdn.bootcss.com/velocity/1.2.1/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: //cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: //cdn.bootcss.com/UAParser.js/0.7.9/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: //cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: //cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js 谷歌字体主题配置文件，换成国内的一个cdn123456789101112131415161718192021222324252627282930313233343536373839404142434445# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: //fonts.css.network/icon?family=Lato:300,300italic,400,400italic,700,700italic&amp;subset=latin,latin-ext # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: 添加rss1$ npm install hexo-generator-feed --save 主题配置文件1rss: /atom.xml 代码中使用js使用 raw 标签包裹住就能让内容内容略过 markdown 解析12345&#123;% raw %&#125;&lt;script&gt; alert(12312)&lt;/script&gt;&#123;% endraw %&#125;]]></content>
      <tags>
        <tag>hexo-next</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[震惊！彩票的随机机制竟然是这样的...]]></title>
    <url>%2F2017%2F03%2F24%2Fcaipiao%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728&lt;?php$lanList = [];$hongList = [];for($i=1;$i&lt;34;$i++)&#123; if($i&lt;16)&#123; array_push($lanList,$i); &#125; array_push($hongList, $i);&#125;$res = [ 'red' =&gt; [], 'blue' =&gt; []];for($i=0;$i&lt;=6;$i++)&#123; if($i==0)&#123; $res['blue'] = array_slice($lanList, mt_rand( 0,count($lanList)-1) ,1); &#125; $res['red'][] = array_splice($hongList, mt_rand( 0,count($hongList)-1),1)[0];&#125;sort($res['red']);echo 'red:'.implode(',',$res['red']).' blue:'.implode(',',$res['blue']).PHP_EOL;?&gt;]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Symfony-路由]]></title>
    <url>%2F2017%2F03%2F23%2Fsymfony-router%2F</url>
    <content type="text"><![CDATA[laravel的路由模块就是从这里封装起来的，咱们先了解下symfony的路由机制 使用注释定义一个路由symfony 的强大之处在于代码中的注释都参与到程序运行当中，这样强制的规范了注释排版，比如123456789101112class LuckyController extends Controller&#123; /** * @Route("/lucky/number") */ public function numberAction() &#123; $numbers = mt_rand(1,999); return new Response($numbers); &#125;&#125; 当输入 http://domain/app_dev.php/lucky/number 将会返回方法中的随机数 使用配置文件定义一个路由推荐这种写法，方便他人维护在 @app/config/routing.yml文件中，定义一个blog_show路由123blog_show: path: /blog/&#123;slug&#125; defaults: &#123; _controller: AppBundle:Lucky:show ,slug:2333&#125; 这里还有 {slug} 奇怪的写法，这代表着路由中传入 slug的自定义参数，从laravel过来的同学一定不会陌生 defaults 下指定了该路由指向哪个控制器，同时 slug 也有了默认值，在控制器中就是这样写：1234567891011// src: @src/AppBundle/LuckyControllerpublic function showAction($slug)&#123; $str = &apos;this is blog-&apos;.$slug; return new Response($str);&#125;#注释的写法就是/** * @Route(&quot;/blog/&#123;slug&#125;&quot;, defaults=&#123;&quot;slug&quot; = 1&#125;) */ 高级路由示例12345678910111213141516171819202122232425# in Controller/** * @Route( * "/articles/&#123;_locale&#125;/&#123;year&#125;/&#123;title&#125;.&#123;_format&#125;", * defaults=&#123;"_format": "html"&#125;, * requirements=&#123; * "_locale": "en|fr", * "_format": "html|rss", * "year": "\d+" * &#125; * ) */public function showAction($_locale, $year, $title)&#123;&#125;# in yaml# app/config/routing.ymlarticle_show: path: /articles/&#123;_locale&#125;/&#123;year&#125;/&#123;title&#125;.&#123;_format&#125; defaults: &#123; _controller: AppBundle:Article:show, _format: html &#125; requirements: _locale: en|fr _format: html|rss year: \d+ 这里对参数进行了正则筛选，如果不复合条件的也将报 404 错误 新出现的 requirements 部分就是对指定的参数筛分，使用的是正则的格式 在程序中生成路由和解析路由路由在系统中是双向映射，既能生成带参数的路由，又能反向解析成运行的函数123456789101112$params = $this-&gt;get('router')-&gt;match('/blog/my-blog-post');dump($params);// array(// 'slug' =&gt; 'my-blog-post',// '_controller' =&gt; 'AppBundle:Blog:show',// )$uri = $this-&gt;get('router')-&gt;generate('blog_show', array( 'slug' =&gt; 'my-blog-post'));dump($uri);// /blog/my-blog-post 在 generate 方法中，如果添加了路由中没设置的参数比如123456$uri = $this-&gt;get('router')-&gt;generate('blog_show', array( 'slug' =&gt; 'my-blog-post', 'author' =&gt; 'jack', 'type' =&gt; 'markdown'));// /blog/my-blog-post?author=jack&amp;type=markdown 会以 Query Strings 的形式添加到地址中 现在生成的是相对路径，如果是全路径的话需要加一个参数12345$uri = $this-&gt;get('router')-&gt;generate('blog_show', array( 'slug' =&gt; 'my-blog-post', 'author' =&gt; 'jack', 'type' =&gt; 'markdown'),UrlGenerator::ABSOLUTE_URL); UrlGenerator::ABSOLUTE_URL 这个参数也可以替换成 0]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo构建博客]]></title>
    <url>%2F2017%2F03%2F22%2Finstall%2F</url>
    <content type="text"><![CDATA[本地搭建 hexo 构建hexo需要在本地安装node.js1brew install node 当前版本的node版本12node -vv7.7.3 全局安装 hexo1npm install -g hexo 国外镜像慢的话可以搜索找下淘宝的 cnmp 创建一个目录并且安装 hexo 1234mkdir hexo_blogcd hexo_bloghexo initnpm install 新建一个文章 1hexo new &quot;your-first-page&quot; 文件在 hexo_blog/source/_post/下进行编辑啊 然后就是生成静态文件12hexo generatehexo server 这时就可以访问 http://localhost:4000 来查看效果，这个时候hexo已经搭建成功了，但是我们需要外网能够访问，这就用到了今天的另一个主角：github page 将 hexo 放到github上 需要一个github账号，具体申请登录看 https://github.com 上的引导就行 创建一个新的 repository 名字格式是固定的，比如我的账户名是 gaopengfei123123 那么这个库的名字就是 gaopengfei123123.github.io 不能改的哦 为了可以直接提交远程文件需要添加 ssh 密匙本地操作123ssh-keygen -t rsa -C &quot;5173180@qq.com” -f ~/.ssh/github-rsacat ~/.ssh/github_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3K5mcQxH9mu1cUIu2+byK1iksES/7Tnfh23l2U6y1fOKO4XFhPLdAoMQdePnI51PAF4faXxucOYsiDb6IpQimWPwORKTkEkcglOiZ414eZZ829gY98RAldbFQeT2L9A0l2APfcan1fH4HvrCmZKlY8CNDQDDfRzXub9hfSX3LS5mQlgS9PHiFoXRfrS10hYweere9Cb9OFiEdkdCfMKUBr25ImGahqbaHxE8Vb3QzMT8Q5PBITaqFwYnIE/z6HU6Lok92EZ/uVG81SMJb9A5SQCZdsjWmyDqXj1eDZ1A2YyUlA+/6QM7JjCrLoZAAtZHTH+ylNAG79w9WG0eYAuL GaoPengFeiFiy@github.com 把这一段完整的复制到 https://github.com/settings/keys 这个地址下，添加一条新的ssh-key，这样就能免登录提交版本文件 现在编辑本地hexo根目录下的站点配置文件 path/to/hexo_blog/_config.yml查找字段 deploy 编辑成这样123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:gaopengfei123123/gaopengfei123123.github.io.git branch: master 设置好后，就将本地生成的静态文件发到github上1234hexo deploy#如果报错就可能是少个插件npm install hexo-deployer-git 进入 你的版本库地址/settings 比如我的就是 https://github.com/gaopengfei123123/gaopengfei123123.github.io/settings找到 github pages 设置块按照你的需求调整，这时访问 https://gaopengfei123123.github.io就能访问 hexo 上传的内容了 绑定一个自己的域名，通过它来访问github pages 我用的是阿里云的万网来举例 首先进入到万网云解析的页面 123记录类型：A主机记录：blog记录值：xxx.xxx.xxx #这里需要 ping -c 3 https://gaopengfei123123.github.io 获取ip地址 然后返回到 你的版本库地址/settings 这里，将 Custom domain 设置成你刚才解析的名字，与此同时在github上版本的根目录下添加一个文件 CNAME 内容是 12#in CNAMEblog.justwe.site 这时再返回settings中就能看的 github pages 部分的域名绑定的是你的域名了，到这里博客算是搭建成功了 hexo官网 hexo的next模版官网]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo和github-Pages发布博客]]></title>
    <url>%2F2017%2F03%2F22%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[本地搭建 hexo 构建hexo需要在本地安装node.js1brew install node 当前版本的node版本12node -vv7.7.3 全局安装 hexo1npm install -g hexo 国外镜像慢的话可以搜索找下淘宝的 cnmp 创建一个目录并且安装 hexo 1234mkdir hexo_blogcd hexo_bloghexo initnpm install 新建一个文章 1hexo new &quot;your-first-page&quot; 文件在 hexo_blog/source/_post/下进行编辑啊 然后就是生成静态文件12hexo generatehexo server 这时就可以访问 http://localhost:4000 来查看效果，这个时候hexo已经搭建成功了，但是我们需要外网能够访问，这就用到了今天的另一个主角：github page 将 hexo 放到github上 需要一个github账号，具体申请登录看 https://github.com 上的引导就行 创建一个新的 repository 名字格式是固定的，比如我的账户名是 gaopengfei123123 那么这个库的名字就是 gaopengfei123123.github.io 不能改的哦 为了可以直接提交远程文件需要添加 ssh 密匙本地操作123ssh-keygen -t rsa -C &quot;5173180@qq.com” -f ~/.ssh/github-rsacat ~/.ssh/github_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3K5mcQxH9mu1cUIu2+byK1iksES/7Tnfh23l2U6y1fOKO4XFhPLdAoMQdePnI51PAF4faXxucOYsiDb6IpQimWPwORKTkEkcglOiZ414eZZ829gY98RAldbFQeT2L9A0l2APfcan1fH4HvrCmZKlY8CNDQDDfRzXub9hfSX3LS5mQlgS9PHiFoXRfrS10hYweere9Cb9OFiEdkdCfMKUBr25ImGahqbaHxE8Vb3QzMT8Q5PBITaqFwYnIE/z6HU6Lok92EZ/uVG81SMJb9A5SQCZdsjWmyDqXj1eDZ1A2YyUlA+/6QM7JjCrLoZAAtZHTH+ylNAG79w9WG0eYAuL GaoPengFeiFiy@github.com 把这一段完整的复制到 https://github.com/settings/keys 这个地址下，添加一条新的ssh-key，这样就能免登录提交版本文件 现在编辑本地hexo根目录下的站点配置文件 path/to/hexo_blog/_config.yml查找字段 deploy 编辑成这样123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:gaopengfei123123/gaopengfei123123.github.io.git branch: master 设置好后，就将本地生成的静态文件发到github上1234hexo deploy#如果报错就可能是少个插件npm install hexo-deployer-git 进入 你的版本库地址/settings 比如我的就是 https://github.com/gaopengfei123123/gaopengfei123123.github.io/settings找到 github pages 设置块按照你的需求调整，这时访问 https://gaopengfei123123.github.io就能访问 hexo 上传的内容了 绑定一个自己的域名，通过它来访问github pages 我用的是阿里云的万网来举例 首先进入到万网云解析的页面 123记录类型：A主机记录：blog记录值：xxx.xxx.xxx #这里需要 ping -c 3 https://gaopengfei123123.github.io 获取ip地址 然后返回到 你的版本库地址/settings 这里，将 Custom domain 设置成你刚才解析的名字，与此同时在github上版本的根目录下添加一个文件 CNAME 内容是 12#in CNAMEblog.justwe.site 这时再返回settings中就能看的 github pages 部分的域名绑定的是你的域名了，到这里博客算是搭建成功了 hexo官网 hexo的next模版官网]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel事务]]></title>
    <url>%2F2017%2F03%2F21%2Flaravel-trancate%2F</url>
    <content type="text"><![CDATA[laravel 事务的使用会忽略的地方 laravel开启事物有两种方法： 一种是闭包12345DB::transaction(function()&#123; DB::table('user')-&gt;insert(['username'=&gt;'xxx']); DB::table('comment')-&gt;insert(['content'=&gt;'zzz']);&#125;); 当闭包内发生错误就会自动回滚 另一种比较灵活1234567DB::beginTransaction();//这里执行一些数据库操作，包括 eloquent 的if(condition)&#123; DB::commit();&#125;else&#123; DB::rollback();&#125; 但是我有一次发现两种方法的事物都不起作用，在想掉几根头发之后想到了可能是不同数据库的原因！ 如果你采用的是分库存储不同逻辑的方式，执行事物的时候一定要加上连接信息 上面的就要这样写了：1234567DB::connection('admin_database')-&gt;beginTransaction();//这里执行一些数据库操作，包括 eloquent 的if(condition)&#123; DB::connection('admin_database')-&gt;commit();&#125;else&#123; DB::connection('admin_database')-&gt;rollback();&#125; 如果逻辑中的 eloquent 连接的数据库和开启事物的数据库不是一个库一样是不起作用的]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言了解(3) 工作流程]]></title>
    <url>%2F2017%2F03%2F19%2Fgo-workflow%2F</url>
    <content type="text"><![CDATA[本章将的关键字有 defer,panic,recover,main,init,import defergo语言中有一个不错的设计，就是defer。尤其是调用资源时需要打开和关闭两个选项的时候就能凸显出来 它的作用是将指定的语句在函数结束时执行，没明白？咱们举个例子啊12345main () &#123; for i :=0;i &lt; 5 ; i++&#123; defer fmt.Println(&apos;输出：&apos;,i) &#125;&#125; 输出的结果不是01234而是相反的43210，这样就明白它的功能了吧？再举一个常用的例子12345678910111213141516func OpenFile() bool&#123; file.Open(&quot;file/path&quot;) if condition1 &#123; file.Close() return false &#125; if condition2 &#123; file.Close() return false &#125; file.Close() return true&#125; 在别的语言中我们打开文件的逻辑大体是这样的，你会发现打开一个文件需要在每个条件结束的时候去再声明关闭它，这显得语句很臃肿，而且如果我们哪个地方给忘了很可能就造成内存泄漏，但在go中它变的很简单123456789101112func OpenFile() bool&#123; file.Open(&quot;file/path&quot;) defer file.Close() if condition1 &#123; return false &#125; if condition2 &#123; return false &#125; return true&#125; 当函数按照从上往下执行的时，执行到最下面准备结束这个函数，go将会再从下往上执行一下标明的defer的命令 panic 和 recover这两个函数放在一起说，因为他们的作用是相对的 panic会中断控制流程的命令，是go语言的报错机制，一旦执行panic那么当前进程就会终止，但是我们刚才讲的defer命令还是会执行，等defer执行完了就会结束这个goroutine recover会恢复panic造成的中断，从而让进程继续进行，而且recover只能在defer中执行，同时在正常进程中执行的recover()将返回false 由于没想到十分合适的场景就先不举例了:p main 和 init这两个也能放在一起说 main只能有一个，而且只能在main package当中，而init()每个包里都可以有多个，也可以没有，为了方便维护，建议包里不超过一个init 这两个都是系统自动执行的函数，不用在文件中执行 在平时构建项目的时候我们会导入很多的包(package)，多个包中肯定会有重复的，但是不用担心，重复导入的包只会生效一次 从main package导入外界的包会优先执行外界包的init和变量初始化，如果外界的包也导入了第三方的包，那么优先执行外界包的第三方包的初始化，再执行外界包的初始化最后执行mian package的初始化 这也很好理解，我们引入包的时候这个包肯定要是完整的形态，为了让他完整就要优先满足它的条件，这也层层向外翻到了最边缘初始化完毕再一层层的向内完成初始化 importimport有几个很方便的特性比如:12345import( f &quot;fmt&quot; . &quot;fmt&quot; _ &quot;fmt&quot; ) 这三种写法 第一种是引入别名 fmt.Println 就可以简写成 f.Println 第二种更厉害了，直接就可以把包名给省去 可以当成自己的方法写成 Println 第三种其实是引入该包，不直接使用包里的函数，而是调用了该包的init函数]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言了解(2)--切片]]></title>
    <url>%2F2017%2F03%2F14%2Fgo-slice%2F</url>
    <content type="text"><![CDATA[切片是一种复合类型，可以是数组也可以是字符串 接下来是一个简单切片使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport &quot;fmt&quot;func slienceInfo(slience []int, str string) &#123; fmt.Println(&quot;\n&quot;, str, &quot;的长度是:&quot;, len(slience)) fmt.Println(str, &quot;的大小是:&quot;, cap(slience), &quot;\n&quot;) for i, v := range slience &#123; fmt.Println(str, &quot;下标&quot;, i, &quot;是&quot;, v) &#125;&#125;func main() &#123; //定义一个数组 var arr [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; //打印一下 for _, v := range arr &#123; fmt.Println(&quot;arr element is&quot;, v) &#125; //获取数组 arr 从0 到下标为5（不包含下标5) 的一个切片 mySlice := arr[:5] slienceInfo(mySlice, &quot;mySlice&quot;) //声明一个包含5个元素的数组切片 此时会创建一个匿名数组 elementSlience := []int&#123;1, 2, 2, 3, 4&#125; slienceInfo(elementSlience, &quot;elementSlience&quot;) //声明一个默认值0，长度5，预留长度10的切片 emptySlience := make([]int, 5, 10) slienceInfo(emptySlience, &quot;emptySlience&quot;) //向切片中添加元素 这时数组的长度和占用内存是一致的 emptySlience = append(emptySlience, 1, 2, 3, 4, 5) //如果超过分配的内存，会动态分配足够的内存空间 // emptySlience = append(emptySlience, 1, 2, 3, 4, 5) slienceInfo(emptySlience, &quot;emptySlience2&quot;) mySlice = append(mySlice, emptySlience...) slienceInfo(mySlice, &quot;mySlice2&quot;) //内容复制 slice1 := []int&#123;1, 2, 3, 4, 5&#125; slice2 := []int&#123;6, 6, 6&#125; //从slice2复制前三个元素到slice1当中，不同长度的按照较小的来 copy(slice1, slice2) slienceInfo(slice2, &quot;slice&quot;)&#125; 从示例中可以看出切片是动态分配内存大小的，我总结了一下几条规律 当切片源于一个已有的数组时，切片长度取决于截取的长度，切片分配的内存大小和源数组占用的内存大小一样 当直接生成一个切片数组时，可以定义长度和预留内存 当切片超出分配内存大小时，系统将会再分配一块足够大的内存 通常如果直到业务中明确的数组极限长度的时候，就分配足够大的内存，以缓解系统不断计算分配内存的压力，典型的空间换时间]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git标签操作]]></title>
    <url>%2F2017%2F03%2F13%2Fgit-tag%2F</url>
    <content type="text"><![CDATA[列出所有标签1git tag 添加标签(同时生成独立的版本库)12345# 给当前commit打标签git tag -a v0.0.1 -m &apos;第一次添加标签&apos;# 给指定的commit打标签，需要commit的headgit tag -a v0.0.1 0ed1dd07d324cb5aece243a95312187955619fcf 不加 -a 参数相当于是一个commit的引用 将标签推送到远程库1234# 推送本地所有标签git push origin --tags# 推送指定标签git push origin v0.0.1 跳转到指定标签1git checkout v0.0.1 和跳转到branch操作一样，但是因为是独立的版本库上，你在独立标签中的git branch和在主线中包含的branch显示的是不同的，独立版本库和分支的性质是不一样的 删除指定标签1git tag -d v0.0.1 删除远程分支1git push origin -d tag &lt;tagname&gt;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Redis—geo Api实现搜索附近的人，自己写的一个composer包]]></title>
    <url>%2F2017%2F03%2F11%2Fcomposer-redis-lbs%2F</url>
    <content type="text"><![CDATA[git地址 安装需要使用composer，安装composer, composer中国镜像 如果是应用在项目当中的话找到根目录，需要和 composer.json同级 1composer require gaopengfei/redis_lbs #基本操作 初始化12require_once __DIR__.'/vendor/autoload.php';$lbs = new \LBS\Services\LBSService(); 添加123456789101112131415161718192021222324252627282930313233343536373839404142434445$add_params = [ [ 'name' =&gt; 'yabao_road', 'long' =&gt; '116.43620200729366', 'lat' =&gt; '39.916880160714435' ], [ 'name' =&gt; 'jianguomen', 'long' =&gt; '116.4356870231628', 'lat' =&gt; '39.908560377800676' ], [ 'name' =&gt; 'chaoyangmen', 'long' =&gt; '116.4345336732864', 'lat' =&gt; '39.924466658329585' ], [ 'name' =&gt; 'galaxy_soho', 'long' =&gt; '116.4335788068771', 'lat' =&gt; '39.921372916981106' ], [ 'name' =&gt; 'cofco', 'long' =&gt; '116.43564410781856', 'lat' =&gt; '39.92024564137184' ], [ 'name' =&gt; 'fesco', 'long' =&gt; '116.435182767868', 'lat' =&gt; '39.91811857809279' ],];/** * 在集合中新加一个坐标 * @param array $params * 结构是 ['name'=&gt;'xxx','long'=&gt;'1.2321','lat'=&gt;'1.3112']或者[['name'=&gt;'xxx','long'=&gt;'1.2321','lat'=&gt;'1.3112']] * @param null $key * @return int */$res = $lbs-&gt;add($add_params);返回int 6 删除1234567891011121314/** * 删除集合中指定元素 * @param $name * @param null $key 默认存在集合，可以指定 * @return int */$res = $lbs-&gt;del('gao1');返回int 0 或 1如果是指定的集合名就$res = $lbs-&gt;del('gao1','set-name'); 用坐标查询附近的单位123456789101112131415161718192021222324252627282930/** * 查询范围内元素，如果不转 key就用默认的 * @param $long 经度 * @param $lat 纬度 * @param $radius 范围 * @param $unit 单位 (仅支持 m,km,ft,mi) * @param null $key 集合名 * @return mixed */$search = $lbs-&gt;search('116.435182767868','39.91811857809279',500,'m');返回数组array:4 [▼ 0 =&gt; array:2 [▼ "name" =&gt; "fesco" "dist" =&gt; "0.1250" ] 1 =&gt; array:2 [▼ "name" =&gt; "yabao_road" "dist" =&gt; "162.8454" ] 2 =&gt; array:2 [▼ "name" =&gt; "cofco" "dist" =&gt; "239.7758" ] 3 =&gt; array:2 [▼ "name" =&gt; "galaxy_soho" "dist" =&gt; "386.9165" ]] 根据已有的位置查询1234567891011121314151617181920212223242526272829/** * 根据集合中的元素查询范围内元素，如果不转 key就用默认的 * @param $name 集合中的元素名 * @param $radius 范围 * @param $unit 单位 * @param null $key 集合名 * @return mixed */$search = $lbs-&gt;-&gt;searchByMembers('fesco',500,'m');返回数组array:4 [▼ 0 =&gt; array:2 [▼ "name" =&gt; "fesco" "dist" =&gt; "0.1250" ] 1 =&gt; array:2 [▼ "name" =&gt; "yabao_road" "dist" =&gt; "162.8454" ] 2 =&gt; array:2 [▼ "name" =&gt; "cofco" "dist" =&gt; "239.7758" ] 3 =&gt; array:2 [▼ "name" =&gt; "galaxy_soho" "dist" =&gt; "386.9165" ]] 列出集合的所有值（其实就是 zrange)123456789101112131415161718/** * 列出集合中的内容 * @param $key 集合的key * @param int $start 起始位置 * @param int $end 结束位置 -1 为直到末尾 * @return array */$list = $lbs-&gt;list($test-&gt;geoset_name,2,-1);返回数组array:6 [▼ 0 =&gt; "jianguomen" 1 =&gt; "yabao_road" 2 =&gt; "fesco" 3 =&gt; "cofco" 4 =&gt; "galaxy_soho" 5 =&gt; "chaoyangmen"]]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LBS使用redis的解决方案--GEOHASH]]></title>
    <url>%2F2017%2F03%2F10%2Fredis-geohash-lbs%2F</url>
    <content type="text"><![CDATA[最近需要用到LBS距离测绘方面的东西，用于搜索附近的人，在网上搜了一下有一个比较通用的方案，就是采用 GEOHASH 算法 相关的参考资料 这套算法在 mongoDB 当中已经集成了，但是公司的业务中没有用到 mongodb 而是用了redis，本来打算自己造个轮子去实现，但是万幸翻看了一下redis的文档，它也在 3.* 版本后提供了GEO相关的api 相关文章 首先是添加命令 GEOADD1GEOADD key long lat name [long lat name1,long lat name2,long lat name3...] key GEOSET的名字 long 地点的经度 lat 地点的纬度 name GEOSET内的值的名字可以批量输入 举个栗子12GEOADD chaoyangqu 116.43620200729366 39.916880160714435 &quot;yabaolu&quot; 116.4356870231628 39.908560377800676 &quot;jianguomen&quot; 116.4345336732864 39.924466658329585 &quot;chaoyangmen&quot; 116.4335788068771 39.921372916981106 &quot;yinhesoho&quot; 116.43564410781856 39.92024564137184 &quot;zhongliang&quot;(integer) 5 返回值为1 说明是新添，返回0 说明是更新 错误的话就报错了 查看当前插入的内容123456zrange chaoyangqu 0 -11) &quot;jianguomen&quot;2) &quot;yabaolu&quot;3) &quot;zhongliang&quot;4) &quot;yinhesoho&quot;5) &quot;chaoyangmen&quot; 从这条命令也可以看出来 geoset 是属于有序集合 命令 GEORADIUS1GEORADIUS key long lat radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC] [COUNT count] key 集合的名字 long 指定的经度 lat 指定的纬度 radius 半径范围 unit 单位 可以说 m km ft(英尺) mi(英里)123GEORADIUS chaoyangqu 116.435182767868 39.91811857809279 300 m1) &quot;zhongliang&quot;2) &quot;yabaolu&quot; 带上参数可以显示更多位置信息，通常业务需要显示下距离和进行排序，添加 WITHDIST ASC12345GEORADIUS chaoyangqu 116.435182767868 39.91811857809279 300 m WITHDIST ASC1) 1) &quot;yabaolu&quot; 2) &quot;162.8454&quot;2) 1) &quot;zhongliang&quot; 2) &quot;239.7758&quot; 命令GEORADIUSBYMEMBER1GEORADIUSBYMEMBER key member radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC] [COUNT count] key 集合的名字 long 指定的经度 lat 指定的纬度 radius 半径范围 unit 单位 可以说 m km ft(英尺) mi(英里) 这个和 GEORADIUS 的区别就是 前者是指定坐标，后者是可以直接从集合中指定一个name做计算栗子123456GEORADIUSBYMEMBER chaoyangqu yinhesoho 300 m WITHDIST ASCGEORADIUSBYMEMBER chaoyangqu yinhesoho 300 m WITHDIST ASC1) 1) &quot;yinhesoho&quot; 2) &quot;0.0000&quot;2) 1) &quot;zhongliang&quot; 2) &quot;216.2817&quot; 排在第一位的肯定是自己啊，而且需要确定你要搜寻的名字已经存在集合中，否则会报错 命令GEOPOS1GEOPOS key elem1 elem2 ... elemN 列出集合中指定name的坐标栗子：123456GEOPOS chaoyangqu yabaolu yinhesoho xxx1) 1) &quot;116.43620342016220093&quot; 2) &quot;39.9168813345921123&quot;2) 1) &quot;116.43358021974563599&quot; 2) &quot;39.92137286048646416&quot;3) (nil) 说明如果 name 不存在set中就会返回nil 命令GEODIST12GEODIST key elem1 elem2 [unit]1. unit 单位可以说m lm ft mi 只能是两个元素之间的啊，不然三个元素就是语法错误，两个元素中有一个不存在则返回 nil栗子12GEODIST chaoyangqu yabaolu yinhesoho m&quot;547.4030&quot; 下面的几个命令做个了解，平时不常用到 GEOHASH key elem1 elem2 … elemN //获取指定name的hash值]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker(3) 构建Dockerfile]]></title>
    <url>%2F2017%2F03%2F08%2Fdocker-dockerfile%2F</url>
    <content type="text"><![CDATA[上一章我们用的是 docker commit 命令创建的自己的库，虽然简单但是定制性比较差，因此我们采用另一种且更广泛的做法就是 docker build命令，先上手做个demo 1234cd $HOME/document/wwwmkdir build_democd build_demovi Dockerfile 下面是 Dockerfile 中的代码123456# Version 0.0.1FROM gaofeifiy/ubuntu-lastMAINTAINER GPF “5173180@qq.com”RUN touch /ReadMe.txtRUN echo &apos;hey your contain build success!&apos; &gt; /ReadMe.txtEXPOSE 80 然后在 $HOME/document/www/build_demo 目录下运行12345678910111213141516171819202122➜ lnmp_docker docker build -t=&quot;gaofeifiy/lnmp_server&quot; .# 下面是显示的Sending build context to Docker daemon 2.048 kBStep 1 : FROM gaofeifiy/ubuntu-last ---&gt; 6f8cfa1871b0Step 2 : MAINTAINER GPF ---&gt; Running in 3e442a5807f3 ---&gt; 8d0efc1cf9f7Removing intermediate container 3e442a5807f3Step 3 : RUN touch /ReadMe.txt ---&gt; Running in 91a7a049d18c ---&gt; b98309a7d5a4Removing intermediate container 91a7a049d18cStep 4 : RUN echo &apos;hey your contain build success!&apos; &gt; /ReadMe.txt ---&gt; Running in 0158f49fef8f ---&gt; 6416fe72ff4cRemoving intermediate container 0158f49fef8fStep 5 : EXPOSE 80 ---&gt; Running in 26e1d7df6ab7 ---&gt; c994cb02df6eRemoving intermediate container 26e1d7df6ab7Successfully built c994cb02df6e -t 就是我们新建镜像的标签 接下来我们查看一下本地的镜像列表里出现了什么1234➜ lnmp_docker docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgaofeifiy/lnmp_server latest c994cb02df6e 40 hours ago 227 MBgaofeifiy/ubuntu-last latest 6f8cfa1871b0 2 days ago 227 MB 我们刚刚创建的镜像已经出现到本地的列表里面了 输入 docker history c994cb02df6e 查看镜像的构建流程 我们回顾一下整个流程：刚才所有的操作都是在 Dockerfile 这个文件中进行的，我们用到以下命令 . FROM gaofeifiy/ubuntu-last 新建的库采用 gaofeifiy/ubuntu-last 这个镜像构建的(就是上一章我们建的那个，因为写这个的时候电脑没网… 其实应该是 ubuntu:16.04 这类的基础镜像). MAINTAINER GPF “5173180@qq.com” 指定了该镜像的作者和邮箱. RUN touch /ReadMe.txt 运行系统命令，创建一个ReadMe.txt 文件 其他的RUN命令欧式同样的道理. EXPOSE 80 指定镜像对外端口是80 下面介绍一下更多的Dockerfile相关的指令 . ENV 设置镜像中的环境变量 比如 ENV REFRESHED_AT 2017-02-22 设置缓存更新时间. CMD 和docker run 命令类似，是等容器启动后执行的命令，会被docker run指令干扰 例CMD [&quot;/bin/bash&quot;,&quot;-l&quot;] 这里推荐使用数组形式，防止出现-c参数的干扰. ENTRYPOINT 和CMD命令类似，但是不会被docker run的命令干扰，而且会把docker run后的指令当作 ENTRYPOINT的参数来用 例如：ENTRYPOINT [&quot;/usr/sbin/nginx&quot;,&quot;-g&quot;,&quot;demon off&quot;] 这条命令和 ENTRYPOINT [&quot;/usr/sbin/nginx&quot;] 加上 docker run -t -i xxx镜像 -g &quot;demon off&quot; 两条语句产生的作用相同. USER 指定镜像以什么用户去运行，默认是root 也可以docker run -u 来指定用户. VOLUME 创建一个容器的共享卷，这样的话多个镜像容器公用一套内容，相当于类中的静态变量. ADD 将本地文件添加到镜像当中，会解压 仅限在以Dockerfile文件为根目录的目录下. COPY 将本地文件拷贝到镜像当中，不会解压 仅限在以Dockerfile文件为根目录的目录下. ONBUILD 当其他镜像使用本镜像的时候触发的命令 例如ONBUILD RUN echo &#39;hello world&#39; 当别的镜像引用到这个镜像的时候就会执行这条命令]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言了解(1)]]></title>
    <url>%2F2017%2F03%2F08%2Fgo-info%2F</url>
    <content type="text"><![CDATA[有人说go和php有很多相似的地方，用惯了弱语言的php是时候换换口味了 声明变量go的声明变量的方式四种（茴香的茴有四种写法），开个玩笑，但是以下几种形式还是可以的 var ValueName type //直接声明一个，声明了就要用啊，不然编译的时候就会报错 var name1,name2,name3 type //类型就近原则，直接声明三个相同类型的变量 var ValueName type = value //声明了变量顺便赋值 var name1,name2,name3 type = value1,value2,value3 //批量赋值也可以，注意他们的类型是一样的 name1,name2,name3 := value1,value2,value3 //这才是常用的写法，用 : 来自动判断类型，单个的也是这个用法还有个特殊的变量名， _ 这代表占个位置但是赋给他的值会被丢弃，比如 _,a := 1,2 a的值为2 但是1就给丢了 这时的使用情景碰到再说 声明常量常量的关键词就不是 var 了 而是 const，和变量的区别是一旦定义就不能改了 const ValueName = value //直接赋值 const Pi float32 = 3.1415926 //也可以声明常量的类型 ###分组赋值在多个包里用到再赋值有的时候不利于debug，可以直接把要赋值的都放到一起 比如:1234567891011const&#123; ENV := true LOCAL := &apos;dev&apos; DATE := 20170307&#125;var&#123; i int pi float32 name string&#125; ##boolean类型true or false 默认为false ##数值类型go支持 int,uint可以定义的类型有rune,int8,int16,int32,int64,byte,uint8,uint16,uint16,uint32,uint64 其中 rune是int32的别称，byte是uint8的别称 不同类型的数不能相互赋值和操作 二进制的数不能和八进制的相加减 浮点型也有float32,float64两种，没有 float这个类型，默认 float64 ##字符串字符串的赋值方式遵循着上面的 声明变量 那一块说的。 Value1 := ‘string’ 和 Value1 := “string” 一个效果 &quot;&quot;代表的是一个空字符串也是占着内存的 字符串之间的拼接用 + 比如12345a,b :=&quot;hello&quot;,&quot;world&quot; c := a + bPrintf(&quot;%s\n&quot;,c) //输出 helloworld 字符串的修改不能直接修改，可以用切片的方式实现例如：123a := &apos;hello&apos;b := &apos;w&apos; + a[1:]//b 的值为 wello 什么是切片我们一会儿就会说到]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go安装godoc]]></title>
    <url>%2F2017%2F03%2F07%2Fgo-doc%2F</url>
    <content type="text"><![CDATA[现在的版本(go version 1.8)下，go的开发工具已经都在git上上线了，可以直接安装 123git clone https://github.com/golang/tools $GOPATH/src/golang.org/x/toolsgo build golang.org/x/tools 就能生成 godoc 的二进制包了，注意需要把第三方的包放到 $GOPATH/src 目录下，这样才能让go能找到并构建]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装LiteIde配置]]></title>
    <url>%2F2017%2F03%2F07%2Fgo-liteide%2F</url>
    <content type="text"><![CDATA[这里设置 Liteide 的配置(环境macOS) Liteide 是一款专门为go开发的一款ide，省去了类似atom编辑器的一些麻烦的环境配置导致atom越来越臃肿，是不少go的开发者在推荐的一款ide 1.安装go1brew install go 下载Liteide 下载地址 选择一个适合系统的版本，推荐qt5的，版本高的不容易过时 打开编辑器 查看-&gt;编辑当前环境 列出我现在的环境1234567891011121314151617# native compiler darwin amd64GOROOT=/usr/local/Cellar/go/1.8/libexecGOPATH=$HOME/Documents/goGOBIN=GOARCH=amd64GOOS=darwinCGO_ENABLED=1PATH=$GOROOT/bin:$PATHLITEIDE_GDB=/usr/local/bin/gdbLITEIDE_MAKE=makeLITEIDE_TERM=/usr/bin/openLITEIDE_TERMARGS=-a TerminalLITEIDE_EXEC=/usr/X11R6/bin/xtermLITEIDE_EXECOPT=-e 上面这一块刚开始是注释掉的，需要我们自己填写，这个是每次运行编辑器的适合才会用到的配置，和安装时的系统配置不冲突 需要注意区分的就是 GOROOT 和 GOPATH 这两个变量 GOROOT 是go的执行目录，说白了就是go源码的安装目录，比如 import “fmt”这条命令就是从 GOROOT 给的路径中找加载的包 GOPATH 是工作目录，类似apache的www目录，你的项目代码都是放到 $GOPATH/src 目录下的同时我们通过 go get 获取的第三方package也是放在这里的为了能执行package里的文件也是需要把这个路径添加到环境变量当中，因此才会出现 PATH=$GOROOT/bin:$PATH 这样的配置 配置完成后运行个文件试一下12cd $HOME/Documents/go/srcmkdir hello &amp;&amp; cd hello 通过liteide编辑器打开目录，创建一个文件 main.go 文件内容如下1234567package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;Hello world!&quot;)&#125; 然后点击编辑器右上角的 BR(build and run) 就能在编辑器下面的信息框中看到输出内容了 ready go！ 参考1 参考2 ps:因为颜值我最后还是采用了 atom 的 go-plus 插件 :)]]></content>
      <tags>
        <tag>liteide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 HTML5上传文件显示进度]]></title>
    <url>%2F2017%2F03%2F06%2Fhtml5-ajax-process%2F</url>
    <content type="text"><![CDATA[使用ajax上传文件的时候为了通过 files api来获取文件信息，从而可以看到显示进度html 1234567891011121314151617&lt;div class="row"&gt; &lt;label for="file"&gt; Upload Image:&lt;/label&gt; &lt;input type="file" name="fileToUpload" id="fileToUpload" multiple="multiple" onchange="fileSelected();" /&gt; &lt;/div&gt; &lt;div id="fileName"&gt; &lt;/div&gt; &lt;div id="fileSize"&gt; &lt;/div&gt; &lt;div id="fileType"&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;input type="button" onclick="uploadFile()" value="Upload Image" /&gt; &lt;/div&gt; &lt;div id="progressNumber"&gt; &lt;/div&gt; js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function fileSelected() &#123; var file = document.getElementById(&apos;fileToUpload&apos;).files[0]; if (file) &#123; var fileSize = 0; if (file.size &gt; 1024 * 1024) fileSize = (Math.round(file.size * 100 / (1024 * 1024)) / 100).toString() + &apos;MB&apos;; else fileSize = (Math.round(file.size * 100 / 1024) / 100).toString() + &apos;KB&apos;; document.getElementById(&apos;fileName&apos;).innerHTML = &apos;Name: &apos; + file.name; document.getElementById(&apos;fileSize&apos;).innerHTML = &apos;Size: &apos; + fileSize; document.getElementById(&apos;fileType&apos;).innerHTML = &apos;Type: &apos; + file.type; &#125;&#125;function uploadFile() &#123; var fd = new FormData(); fd.append(&quot;fileToUpload&quot;, document.getElementById(&apos;fileToUpload&apos;).files[0]); var xhr = new XMLHttpRequest(); xhr.upload.addEventListener(&quot;progress&quot;, uploadProgress, false); xhr.addEventListener(&quot;load&quot;, uploadComplete, false); xhr.addEventListener(&quot;error&quot;, uploadFailed, false); xhr.addEventListener(&quot;abort&quot;, uploadCanceled, false); xhr.open(&quot;POST&quot;, &quot;Home/Upload&quot;); xhr.send(fd);&#125;function uploadProgress(evt) &#123; if (evt.lengthComputable) &#123; var percentComplete = Math.round(evt.loaded * 100 / evt.total); document.getElementById(&apos;progressNumber&apos;).innerHTML = percentComplete.toString() + &apos;%&apos;; &#125; else &#123; document.getElementById(&apos;progressNumber&apos;).innerHTML = &apos;unable to compute&apos;; &#125;&#125;function uploadComplete(evt) &#123; /* This event is raised when the server send back a response */ alert(evt.target.responseText);&#125;function uploadFailed(evt) &#123; alert(&quot;There was an error attempting to upload the file.&quot;);&#125;function uploadCanceled(evt) &#123; alert(&quot;The upload has been canceled by the user or the browser dropped the connection.&quot;);&#125; 这里加了一个监听事件，可以通过异步来不断获取上传信息，从而能正常的显示上传进度 文章来源另一个资料－使用 JavaScript File API 实现文件上传]]></content>
      <categories>
        <category>front-end</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos65安装docker遇到的坑]]></title>
    <url>%2F2017%2F03%2F01%2Fcontentos-docker%2F</url>
    <content type="text"><![CDATA[在国内的云服务商提供的镜像内核都是2.6.*的，不能满足docker需要的3.1.*，因此首先需要升级一下内核 12345678#导入public keyrpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org#安装elrepo到内核为2.6.32的CentOS中rpm -Uvh http://www.elrepo.org/elrepo-release-6-6.el6.elrepo.noarch.rpm#安装kernel-lt(long term support)长期支持版本yum --enablerepo=elrepo-kernel install kernel-lt -y 如果yum安装的慢，可以通过rpm安装kernel-lt12访问http://elrepo.org/linux/kernel/el6/x86_64/RPMS/下载对应的rpm包，通过rpm方式安装：rpm -ivh kernel-lt-3.10.93-1.el6.elrepo.x86_64.rpm 安装完毕后编辑配置文件123456789101112131415161718192021222324vi /etc/grub.conf# grub.conf generated by anaconda## Note that you do not have to rerun grub after making changes to this file# NOTICE: You do not have a /boot partition. This means that# all kernel and initrd paths are relative to /, eg.# root (hd0,0)# kernel /boot/vmlinuz-version ro root=/dev/xvda1# initrd /boot/initrd-[generic-]version.img#boot=/dev/xvdadefault=0timeout=5splashimage=(hd0,0)/boot/grub/splash.xpm.gzhiddenmenutitle CentOS (3.10.105-1.el6.elrepo.x86_64) root (hd0,0) kernel /boot/vmlinuz-3.10.105-1.el6.elrepo.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-3.10.105-1.el6.elrepo.x86_64.imgtitle CentOS (2.6.32-573.22.1.el6.x86_64) root (hd0,0) kernel /boot/vmlinuz-2.6.32-573.22.1.el6.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-2.6.32-573.22.1.el6.x86_64.imgtitle CentOS (2.6.32-431.23.3.el6.x86_64) 我们用的 CentOS (3.10.105-1.el6.elrepo.x86_64)就排在第一个，因此改成 default=0 保存后重启系统12uname -aLinux iZm5eib1msf1eaxvrvhp60Z 3.10.105-1.el6.elrepo.x86_64 #1 SMP Fri Feb 10 10:48:08 EST 2017 x86_64 x86_64 x86_64 GNU/Linux 安装docker123yum install -y docker-engineservice docker startsudo docker version 如果出现 Cannot connect to the Docker daemon. Is &#39;docker -d&#39; running on this host? 这种提示，按以下解决步骤： 执行 service docker start 加上 sudo 执行 yum upgrade device-mapper 我是执行到第三步就可以正常运行了，如果还没解决问题的话就自己找去吧 资料1-centos安装docker升级内核到3.10 资料2-github/docker/issues/11356]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[beforeAction的一个示例]]></title>
    <url>%2F2017%2F02%2F28%2Fyii-beforeaction%2F</url>
    <content type="text"><![CDATA[1234567891011121314public function beforeAction($action)&#123; if(condition)&#123; Yii::$app-&gt;response-&gt;format = Response::FORMAT_JSON; Yii::$app-&gt;response-&gt;data = array( &apos;status&apos; =&gt; -1, &apos;message&apos; =&gt; &apos;请先登录&apos;, &apos;url&apos; =&gt; \Yii::$app-&gt;getHomeUrl() ); return false; &#125; return true;&#125; 这个函数只返回bool值，响应内容交给 response 原文]]></content>
      <categories>
        <category>Yii2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[局部关闭Csrf验证]]></title>
    <url>%2F2017%2F02%2F28%2Fyii-csrf%2F</url>
    <content type="text"><![CDATA[简单理解 yii的 hehavior 就是代码实现了php54的 trait 特性创建一个hehavior1234567891011121314151617181920212223&lt;?phpuse Yii;use yii\base\ActionEvent;use yii\base\Behavior;use yii\web\Controller;class NoCsrf extends Behavior&#123; public $actions = []; public $controller; public function events() &#123; return [Controller::EVENT_BEFORE_ACTION =&gt; &apos;beforeAction&apos;]; &#125; public function beforeAction($event) &#123; $action = $event-&gt;action-&gt;id; if(in_array($action, $this-&gt;actions))&#123; $this-&gt;controller-&gt;enableCsrfValidation = false; &#125; &#125; &#125; 在controller中调用1234567891011121314&lt;?php public function behaviors() &#123; return [ &apos;csrf&apos; =&gt; [ &apos;class&apos; =&gt; NoCsrf::className(), &apos;controller&apos; =&gt; $this, &apos;actions&apos; =&gt; [ &apos;action-name&apos; ] ] ]; &#125; 这种方法是将控制器中指定的路由方法不经过csrf验证，如果是全局关闭csrf验证的话直接在 controller 添加12//关闭csrf验证public $enableCsrfValidation = false; 原文地址]]></content>
      <categories>
        <category>Yii2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker(2) 创建属于自己的库]]></title>
    <url>%2F2017%2F02%2F19%2Fdocker-repo%2F</url>
    <content type="text"><![CDATA[上一章是了解了怎么创建一个容器，现在我们来把它做成我们自己的库，类似git那样的首先查看下自己的库有哪些12345➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4cd577624dd2 ubuntu &quot;/bin/bash&quot; 2 days ago Exited (127) 16 hours ago little_cat80ac1b1ba419 ubuntu &quot;/bin/bash&quot; 2 days ago Exited (0) 2 days ago determined_bhaskarace5104ceef1f ubuntu &quot;/bin/bash&quot; 4 days ago Exited (0) 4 days ago small_hugle 我们上次创建并操作的容器就是名字是little_cat 而且它的容器id为4cd577624dd2 正是我们需要的 接下来就是在docker官网上注册一个账号，过程也很简单，填个账户，邮箱，密码 邮箱再验证一下就好 本地我们登陆一下1➜ ~ docker ps -a 输入有效的账户信息就行，他会在 $HOME/.docker/config.json 文件中生成一条 auth 信息 登陆成功后，我们把指定的容器做成我们自己的库1➜ ~ docket commit 4cd577624dd2 gaofeifiy/ubuntu-base 这条命令的作用就是把 containerId 为 4cd577624dd2 (也就是 little_cat) 提交给 gaofeifiy/ubuntu-base 这个库，注意，这里commit的时候要用到id而不是容器的name，我自己试的时候就出现提交为none的情况，也许以后的版本会补上 这个有什么作用呢？ 我们查看一下images 12345➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgaofeifiy/ubuntu-base latest 6f8cfa1871b0 40 minutes ago 227 MBubuntu 16.04 f49eec89601e 4 weeks ago 129.5 MBubuntu latest f49eec89601e 4 weeks ago 129.5 MB 我们最早的 little_cat 已经在本地被做成一个基础的images了 直接用它创建一个容器123456➜ ~ docker run -t -i --name big_cat gaofeifiy/ubuntu-base /bin/bash➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES10ea9940c6d2 gaofeifiy/ubuntu-base &quot;/bin/bash&quot; 48 seconds ago Exited (0) 39 seconds ago big_cat 我们用刚才新建的image为基础创建了 big_cat 这个容器 要删除的话也是很简单，这里有两个命令 docker rm 和 docker rmi 12docker rm 10ea9940c6d2 这是用来删除容器(CONTAINER)的docker rmi 6f8cfa1871b0 这是用来删除镜像的(IMAGE) 的 有一点需要注意的就是如果要删除的image是有container在使用的话需要先把container给删除再删除image]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker(1)入门]]></title>
    <url>%2F2017%2F02%2F16%2Fdocker-info%2F</url>
    <content type="text"><![CDATA[开始首先在docker官网或者国内的daoCloud来下载工具，不推荐新手在直接通过brew来安装 docker-machine 根据安装导航安装好就行 刚接触一个新玩具最先要做的就是让他跑起来 打开命令行，输入命令1234567891011121314151617docker versionlient: Version: 1.12.3 API version: 1.24 Go version: go1.6.3 Git commit: 6b644ec Built: Wed Oct 26 23:26:11 2016 OS/Arch: darwin/amd64Server: Version: 1.12.3 API version: 1.24 Go version: go1.6.3 Git commit: 6b644ec Built: Wed Oct 26 23:26:11 2016 OS/Arch: linux/amd64 运行正常 接下来我们用到了几个命令12345docker run 运行一个主机docker ps 列出正在运行的主机docker attach 附着到指定的主机上docker pull 从远程拉下指定的容器docker images 列出下载到本地的容器 首先开启运行一个ubuntu容器1docker run -i -t ubuntu /bin/bash 解释一下命令含义： 运行ubuntu容器， -i 保证容器中的 STDIN 是开启的， -t 为容器生成一个伪tty终端 ubuntu 以ubuntu作为基础镜像，同理可以使用 centos，debain之类的 更多的命令 输入 docker run –help 可以查看 执行这条命令的时候，如果本地没有 ubuntu 的话会自动执行 docker pull ubuntu 拉取默认的ubuntu镜像到本地，执行完毕后就会进入容器中的bash界面，相当于一个ubuntu的虚拟机，执行 hostname 查看homeId执行 exit推出容器内部界面，当退出的时候容器也将停止运行 退出后到本地的终端界面12345678docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES572fd5bda011 ubuntu &quot;-i -t /bin/bash&quot; Less than a second ago Created hungry_franklin4cd577624dd2 ubuntu &quot;/bin/bash&quot; 58 minutes ago Exited (127) 9 minutes ago little_cat80ac1b1ba419 ubuntu &quot;/bin/bash&quot; About an hour ago Exited (0) 59 minutes ago determined_bhaskarace5104ceef1f ubuntu &quot;/bin/bash&quot; 47 hours ago Exited (0) 47 hours ago small_hugle 列出所有的容器，每次 docker run 都会新创建一个容器， 相当于每次运行的时候都是一个初始的容器 如果想接着上次退出的就执行12docker start 4cd577624dd2docker start little_cat 这两条执行的效果是一样的，都是指向同一个容器 但是这时只是开启了，我们想进入这个容器里怎么办？ 执行下一条命令1docker attach littlt_cat 这样就会进入到容器里面的界面 忘了说了，如果想创建一个指定名字的容器就添加一个 --name 参数 比如1docker run -d --name littl_cat ubuntu /bin/bash 这里的 -d 就是以守护进程的方式在后台运行 –name 就是指定了容器的名字，如果不指定的话也会随机分配一个]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Composer的一个小毛病]]></title>
    <url>%2F2017%2F02%2F13%2Fcomposer-debug%2F</url>
    <content type="text"><![CDATA[当环境中同时安装xdebug和composer的时候，会产生一个报错1You are running composer with xdebug enabled. This has a major impact on runtime performance. See Https://getcomposer.org/xdebug 其实作为开发环境来说，并没有太大的影响，也就是拖慢了composer的运行速度，大概3-4倍的样子。 当然，如果不想让那个 warning 再显示就先全局关闭xdebug 首先知道到php.ini的文件路径123➜ ~ php -i | grep &quot;php.ini&quot;Configuration File (php.ini) Path =&gt; /usr/local/etc/php/7.0Loaded Configuration File =&gt; /usr/local/etc/php/7.0/php.ini 编辑php.ini文件 找到xdebug扩展的位置给加上引号注释下就行123;[xdebug];zend_extension=&quot;/usr/local/opt/php70-xdebug/xdebug.so&quot;~ 如果php.ini文件当中没有这个模块的配置，就找找php.ini同级目录下的 conf.d 目录，那里也是加载php扩展的配置文件的 比如我的路径就是1cd /usr/local/etc/php/7.0/conf.d/ext-xdebug.ini 一样给注释掉就行 参考1 参考2]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[科学上网Shadowsocks]]></title>
    <url>%2F2017%2F02%2F09%2Fshadowssocks%2F</url>
    <content type="text"><![CDATA[首先找个国外的服务器，比如 AWS 搬瓦工 这样的，然后开始安装 shadowsocks： 安装shadowsocks依赖1234561. sudo -s // 获取超级管理员权限2. apt-get update // 更新apt-get3. apt-get install python-pip // 安装python包管理工具pip4. pip install shadowsocks // 安装shadowsocks 当写好配置文件之后就可以开启了，配置文件内容在下面列出来了5. ssserver -c /etc/shadowsocks.json -d start // 启动shadowsocks 3 4 5 可以换成12343 apt install shadowsocks4 ssserver -c /etc/shadowsocks.json startapt我当时安装的shadowsocks没有开启守护进程的指令（-d），使用pip安装的可以 所以如果pip的正常安装就用那个 就是取消了守护进程开启 shadowskcks.json内容12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:开放的端口, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;访问密码&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false&#125; 或者12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;port_password&quot;: &#123; &quot;端口1&quot;: &quot;连接密码1&quot;, &quot;端口2&quot; : &quot;连接密码2&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 机器设置好后再修改防火墙规则，开放你在配置文件中设置的端口号 这时候在你要使用的 pc／mobile 上下载个shadowsocks 服务器地址就是你国外主机的地址，端口就是你配置文件中的端口，密码是配置文件中的密码 完]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git推送远程失败]]></title>
    <url>%2F2017%2F01%2F11%2Fgit-error%2F</url>
    <content type="text"><![CDATA[git push 的时候提示:12remote: Permission to ******/born.git denied to ******/.fatal: unable to access &apos;https://github.com/ ******//born.git/&apos;: The requested URL returned error: 403 是因为git的账号冲突，git误认为你使用的是另一个账号，解决办法也很简单 推送方式改成ssh的，这样即使是不同账号但是使用的是同一台设备，还不需要改动究竟和哪一个账号冲突了 查看本机ssh－key1cat ~/.ssh/id_rsa.pub 登录自己的github账户&gt;自己的头像&gt;Setting&gt;SSH and GPG keys&gt;New SSH key 把本机的那一串密码填里面就行 推送方式也改成ssh的地址1git remote set-url origin git@github.com:******/born.git]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己封装一个Composer包玩玩]]></title>
    <url>%2F2017%2F01%2F11%2Fcomposer-package%2F</url>
    <content type="text"><![CDATA[how to build a composer package 参考文档 首先是完善 composer.json 这个是composer需要抓去的的东西，相当于这个composer包的名片 实现步骤是 创建一个git库 （不用说自己查） 初始化composer包命令 composer init 然后一路回车，生成的 composer.json 的样本如下（重点在这里） https://packagist.org 上注册顺着网站提示一路下去就行 库中引用在你想要使用库的项目中的 composer.json 的 require 中添加 &quot;gaopengfei/born&quot;:&quot;dev-master&quot; 然后运行 composer update ，你的包就出现在该项目中的依赖当中了，注意：require的时候一定要指明版本，不然会报错 1234567891011121314151617181920212223242526//composer.json&#123; &quot;name&quot;: &quot;gaopengfei/born&quot;, &quot;description&quot;: &quot;how to build a composer package&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;gaofeifiy&quot;, &quot;email&quot;: &quot;5173180@qq.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.3.0&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Body\\Arm\\&quot;: &quot;src/Body/Arm&quot;, &quot;Body\\Leg\\&quot;: &quot;src/Body/Leg&quot; &#125; &#125;, &quot;files&quot;: [ &quot;path/to/file.php&quot; ]&#125; files 是用于引入全局使用的帮助函数 想让文件能自动加载就靠 autoload 这块的配置了，这里选用了 psr-4 格式的命名规范，这里设置了你的命名空间生效的文件夹在哪里， 当我 use Body\Arm\** 的时候，composer 知道是从 ./src/Body/Arm 这个径下找对应的类名， psr-4规范的大体思想就是命名空间就是文件路径，类名就是文件名，这样设置完之后 运行 composer install 生成了 vendor／autoload.php 文件就能自动加载了]]></content>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git强制将远程版本覆盖本地]]></title>
    <url>%2F2017%2F01%2F06%2Fgit-push-force%2F</url>
    <content type="text"><![CDATA[12git fetch --allgit reset --hard origin/master]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel服务容器延迟加载]]></title>
    <url>%2F2016%2F12%2F26%2Flaravel-lazy-load%2F</url>
    <content type="text"><![CDATA[laravel 注册的服务是可以延时加载的 很简单，在provider文件夹下指定的服务当中这样写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace App\Providers;use App\Repositories\RecommendRepository;use Illuminate\Support\ServiceProvider;class HotcastProvider extends ServiceProvider&#123; /** * 服务提供者加是否延迟加载. * * @var bool */ protected $defer = true; /** * Bootstrap the application services. * * @return void */ public function boot() &#123; // &#125; /** * Register the application services. * * @return void */ public function register() &#123; $this-&gt;app-&gt;bind('App\Repositories\Contract\RecommendInterface','App\Repositories\RecommendRepository'); $this-&gt;app-&gt;singleton('RecommendFacade',function ()&#123; return new RecommendRepository(); &#125;); &#125; /** * 获取由提供者提供的服务. * * @return array */ public function provides() &#123; return ['RecommendFacade','App\Repositories\Contract\RecommendInterface']; &#125;&#125; 把 defer 改为 true， 添加一个 provides方法，然后命令行执行php artisan clear-compiled 重新编译一下服务文件就OK了]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[通过Git Rebase来合并commit提交记录]]></title>
    <url>%2F2016%2F12%2F25%2Fgit-rebase%2F</url>
    <content type="text"><![CDATA[多人合作开发的时候就会因为本地的多个版本提交的很多杂乱的信息，导致git log查看的时候并不能很快的从一堆无意义的提交记录中找到我们想要的版本。做完一个小功能随时提交是一个好习惯，但是这写小记录推送到远程就是个不大不小的麻烦我们通过rebase命令将这些小版本合并成一个大的版本，然后推送到远程，前提是你的代码功能已经达到了。 查看log信息123456789101112131415161718commit 53097de5638d371da51bc6fef74a90ca1420d967Author: GPF &lt;5173180@qq.com&gt;Date: Sun Dec 25 22:46:13 2016 +0800 test3commit 830026adb43506d0bc1172432f84639f84dae087Author: GPF &lt;5173180@qq.com&gt;Date: Sun Dec 25 22:45:56 2016 +0800 test2commit 646f5be02ec285e30626f5682e6e7e9437762ac5Author: GPF &lt;5173180@qq.com&gt;Date: Sun Dec 25 22:45:43 2016 +0800 test1... 比如我们就合并这前三个提交记录 开启rebase脚本1git rebase -i HEAD~3 HEAD~3的意思就是最近的san tiao三条提交信息 编辑脚本执行步骤2的时候就会进入一个编辑脚本如下：12345678910111213141516171819202122pick 646f5be test1pick 830026a test2pick 53097de test3# Rebase dbaf38a..53097de onto dbaf38a (3 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 带#号的都是注释内容，这里提供了很多命令信息。最上面的三行就是我们要执行的命令，pick 查看注释是 use commit 可以简写成 p ， 而且你看排列commit记录的顺序是最早的排在最上面，我们这次是为了合并commit，因此我们要用的命令就是squash 简写成 s将脚本修改成这样：12345678910111213141516171819202122pick 646f5be test1s 830026a test2s 53097de test3# Rebase dbaf38a..53097de onto dbaf38a (3 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 我们合并最早的两个到test1版本当中然后:wq退出，注意合并记录的时候，不能pick最近的一条，会产生报错，如果把报错的话就输入命令git rebase --abort终止这次执行就好 接下来会直接进入一个commit记录编辑界面，#都是注释过的，将非注释的内容编辑成我们想要的然后:wq保存就完毕了]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再来个Facade吧]]></title>
    <url>%2F2016%2F12%2F19%2Flaravel-facade%2F</url>
    <content type="text"><![CDATA[参照上一篇的文章laravel 的 Repository 模式 都已经注册了服务也可以使用 Facade了 首先创建一个 Facade文件，还是在 app/Repositories这里，创建HelloFacade.php 名字无所谓，路径也是无所谓的，关键是能够正确引入文件就行12345678910111213141516171819&lt;?php/** * Created by PhpStorm. * User: gpf * Date: 2016/12/19 * Time: 下午10:48 */namespace App\Repositories;use Illuminate\Support\Facades\Facade;class HelloFacade extends Facade&#123; protected static function getFacadeAccessor() &#123; return 'Hello'; &#125;&#125; 然后再在之前创建的namespace App\Providers\HelloProvider中作出一些改动123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\Providers;use Illuminate\Support\ServiceProvider;use App\Repositories\Hello;use App\Repositories\HelloRepository;class HelloProvider extends ServiceProvider&#123; /** * Bootstrap the application services. * * @return void */ public function boot() &#123; // &#125; /** * Register the application services. * * @return void */ public function register() &#123; $this-&gt;app-&gt;bind(&apos;App\Repositories\Hello&apos;,&apos;App\Repositories\HelloRepository&apos;); $this-&gt;app-&gt;singleton(&apos;Hello&apos;,function()&#123; return new HelloRepository(); &#125;); &#125;&#125; $this-&gt;app-&gt;singleton就是为了去绑定facade 现在已经成功了一半了，接下来去配置文件中注册一下就能正常使用了 在config/app.php中12345678910&apos;providers&apos; =&gt; [ .... App\Providers\HelloProvider::class, ....],&apos;aliases&apos; =&gt; [ ... &apos;Hello&apos; =&gt; \App\Repositories\HelloFacade::class, ...] 这样注册过后就能在文件中直接类似123use Hello;Hello::say(); 这一类的调用了]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows构建node,npm,gulp工具(测试可用)]]></title>
    <url>%2F2016%2F12%2F13%2Fwin-node-npm%2F</url>
    <content type="text"><![CDATA[windows 安装 node 其实很简单 原文地址 第一步到官网下载页下载nodejs，并默认安装，安装成功后打开cmd， 运行node -v即可查看当前node.js版本。 第二步安装windows git工具，本机已经安装好git bash，可自行百度安装。 第三步安装npm，打开git bash，进入自定义的文件夹下，然后执行 12git config --system http.sslcainfo /bin/curl-ca-bundle.crtgit clone --recursive git://github.com/isaacs/npm.git 克隆成功后，进入npm文件夹下，执行1node cli.js install npm -gf 第四步用npm安装gulp 12$ npm install --global gulp$ npm install --save-dev gulp 第五步安装gulp插件 1npm install gulp-util gulp-imagemin gulp-ruby-sass gulp-minify-css gulp-jshint gulp-uglify gulp-rename gulp-concat gulp-clean gulp-livereload tiny-lr --save-dev 第六步测试gulp，创建一个名为 gulpfile.js 的配置文件在当前目录下，并输入下面的代码，这里创建了一个空的任务（仅作为用于测试gulp是否正常工作） 1234var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; // place code for your default task here&#125;); 最后，执行1$ gulp 运行gulp，如果正确输出类似下面的信息，则说明gulp 已经正确安装并运行。1234$ gulp[11:13:17] Using gulpfile xxx\gulpfile.js[11:13:17] Starting &apos;default&apos;...[11:13:17] Finished &apos;default&apos; after 44 μs]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swoole构建聊天室demo]]></title>
    <url>%2F2016%2F12%2F10%2Fwebsocket-demo%2F</url>
    <content type="text"><![CDATA[websocket文档 原文出处 后端代码12345678910111213141516171819202122232425//websocket.php&lt;?php$server = new swoole_websocket_server("0.0.0.0", 9501);$server-&gt;on('open', function (swoole_websocket_server $server, $request) &#123; file_put_contents( __DIR__ .'/log.txt' , $request-&gt;fd);&#125;);$server-&gt;on('message', function (swoole_websocket_server $server, $frame) &#123; global $client; $data = $frame-&gt;data; $m = file_get_contents( __DIR__ .'/log.txt'); for ($i=1 ; $i&lt;= $m ; $i++) &#123; echo PHP_EOL . ' i is ' . $i . ' data is '.$data . ' m = ' . $m; $server-&gt;push($i, $data ); &#125;&#125;);$server-&gt;on('close', function ($ser, $fd) &#123; echo "client &#123;$fd&#125; closed\n";&#125;);$server-&gt;start(); 前端代码123456789101112131415161718192021//index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;script type="text/javascript"&gt; var exampleSocket = new WebSocket("ws://0.0.0.0:9501"); exampleSocket.onopen = function (event) &#123; exampleSocket.send("亲爱的服务器！我连上你啦！"); &#125;; exampleSocket.onmessage = function (event) &#123; console.log(event.data); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="content"&gt;&lt;button onclick="exampleSocket.send( document.getElementById('content').value )"&gt;发送&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 现在在本地命令行运行1php websocket.php 查看浏览器的console就可以测试了,swoole官方example中有个示例，这个demo就是为了抢先体验一下]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装Swoole的记录]]></title>
    <url>%2F2016%2F12%2F10%2Fphp-swoole%2F</url>
    <content type="text"><![CDATA[源码地址 因为swoole已经加入官方扩展包中，可以直接用pecl安装1pecl install swoole 也可以通过源码安装： 首先确认php的安装路径1which php 这个大部分都是指向的/usr/local/bin/php这个地址，但这些文件都是链接，顺着这个就能找到文件真正所在了 去这里是为了找到 phpize 这个工具,在文件安装目录中的 bin 目录中找有没有 phpize 这个快捷方式如果没有的话，就运行如下命令：12yum install php-dev注意版本问题 之后有了 phpize 工具就好说了123456sudo apt-get install php5-devgit clone https://github.com/swoole/swoole-src.gitcd swoole-srcphpize./configuremake &amp;&amp; make install 这一段是官方提供的安装命令，安装完毕后留意一下他的安装路径，或者指定路径 可以在编译前的 ./configure --help查看，比如----prefix=/your/wanted/path 之后就是在运行的php.ini文件中添加配置了12#查看php运行的php.iniphp -i | grep php.ini 编辑 php.ini 直接添加一行1extension= swoole.so 保存退出后1php -m | grep swoole 出现了就说明已经安装上了，high起来！]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos上安装git2.2]]></title>
    <url>%2F2016%2F12%2F03%2Fcentos-install-git%2F</url>
    <content type="text"><![CDATA[centos自带的git版本太低了,安装个新吧 安装依赖环境12&gt;# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidoc&gt;# yum install gcc perl-ExtUtils-MakeMaker error: ```/utf8.c:463: undefined reference to `libiconv&apos; wget http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gztar zxvf libiconv-1.14.tar.gzcd libiconv-1.14./configure –prefix=/usr/local/libiconvmake &amp;&amp; make install1### 卸载Centos自带的git1.7.1 yum remove git1### 下载git2.2.1并将git添加到环境变量中 wget https://github.com/git/git/archive/v2.2.1.tar.gztar zxvf v2.2.1.tar.gzcd git-2.2.1make configure./configure –prefix=/usr/local/git –with-iconv=/usr/local/libiconvmakeall docmake install install-doc install-htmlecho”export PATH=$PATH:/usr/local/git/bin” &gt;&gt; /etc/bashrcsource /etc/bashrc1### 查看版本号 git –versiongit version2.2.1`]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git删除已提交入库的文件]]></title>
    <url>%2F2016%2F11%2F29%2Fgit-rm-cache%2F</url>
    <content type="text"><![CDATA[将git已经提交的文件移除出库（针对的就是 .idea 和 .DS_Store）12345678git rm -r --cache .idea/git rm --cache .DS_Store在 .gitignore 文件中添加相应禁止的东西git commit -m &apos;we didnt want to see you any more!&apos;git pullgit push 这是将指定的文件从库中删除而不影响实际使用的文件]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git更换远程地址]]></title>
    <url>%2F2016%2F11%2F29%2Fgit-remote%2F</url>
    <content type="text"><![CDATA[关键就是移除本地的远程连接路径，替换成我们需要传到的路径将本地库的远程地址更改1git remote set-url origin nideyuanchengdizhi 接下来正常推送就好]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git本地建库推送远程]]></title>
    <url>%2F2016%2F11%2F29%2Fgit-push%2F</url>
    <content type="text"><![CDATA[本地新建库和多远程库的操作 新建本地库12345678910111213#初始化git initgit add -Agit commit -m 'init it'#删除本地远程连接git remote rm origingit remote add origin https://git.oschina.net/gaofeifps/laravel53.git#自动合并远程文件git pull origin master#推送到远程git push --set-upstream origin master 多个远程分支的情况这种情况比如说你本地开发的代码想提交一份到 github,又想提交一份到 gitlab,别问我为什么,就是为了刷 commit 1234567891011121314151617181920# 添加远程分支git remote add test http://blog.justwe.site # 添加了一个名为 test 的远程分支,地址为 http://blog.justwe.site # 查看当前的远程地址列表, 通常会有一个 origin 的默认远程分支, 其他的都是咱们自己加的git remote -v# 向指定远程分支推送git push test master# 这行命令的含义就是将本地的 master 分支提交到 test 这个远程库的 master 分支上# 向指定远程分支的某一分支推送git push test master:develop# 这行的结果就是 本地的 master 分支被推送到 test 这个远程库的 develop 分支上# 移除指定的远程库git remote remove test# 查看其他命令git remote -h]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql5.7版本初始化设置]]></title>
    <url>%2F2016%2F11%2F15%2Fmysql57-config%2F</url>
    <content type="text"><![CDATA[5.7版本有了一些新的变动，首先就是密码部分和之前有了较大的区别。它对数据的安全性方面做了较大的提升。其次的是数据对json的支持，数据库添加时自带计算等等一些更加方便的玩意 当第一次安装完毕的时候，要注意安装提示，会给你串字符串那就是系统给的默认密码这个是重点。 登录后进行查库操作会有这样的提示ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.，需要重设密码，步骤如下：12345SET PASSWORD = PASSWORD(‘your new password’);ALTER USER ‘root’@‘localhost’ PASSWORD EXPIRE NEVER;flush privileges; 将mysql添加到环境变量当前我的mac版本是10.10 OS X Yosemite,属于Bourne Shell的变种,这样就简单了 对于系统自带的终端是这样的：1234567sudo vim ~/.bash_profile#对文件中编辑export PATH=$&#123;PATH&#125;:/usr/local/mysql/bin#保存退出:/wq#解析文件立即生效source ~/.bash_profile 如果用的~/.zshrc的这样配置的也是同样的操作步骤,如果有.zshrc这样的文件优先它，否则上面配置的环境变量会被它覆盖，结果就是上面的配置好了关闭终端再重进就又失效了]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lumen5.3正常使用dd()函数]]></title>
    <url>%2F2016%2F11%2F15%2Flumen-dd%2F</url>
    <content type="text"><![CDATA[主用laravel的已经习惯了dd函数的方便，但是放到lumen5.3的时候就变成了悲催的var_dump,查看了下源码12345678910111213141516if (! function_exists('dd')) &#123; /** * Dump the passed variables and end the script. * * @param mixed * @return void */ function dd() &#123; array_map(function ($x) &#123; (new Dumper)-&gt;dump($x); &#125;, func_get_args()); die(1); &#125;&#125; 再找Dumper这个类，1234567891011121314151617181920212223242526&lt;?phpnamespace Illuminate\Support\Debug;use Symfony\Component\VarDumper\Dumper\CliDumper;use Symfony\Component\VarDumper\Cloner\VarCloner;class Dumper&#123; /** * Dump a value with elegance. * * @param mixed $value * @return void */ public function dump($value) &#123; if (class_exists(CliDumper::class)) &#123; $dumper = &apos;cli&apos; === PHP_SAPI ? new CliDumper : new HtmlDumper; $dumper-&gt;dump((new VarCloner)-&gt;cloneVar($value)); &#125; else &#123; var_dump($value); &#125; &#125;&#125; 发现当它查不到CliDumper::class这个类的时候就会使用php自带的var_dump函数，因此我们需要加载一个clidumper1composer require symfony/var-dumper 这样的话哪怕不用的lumen，只要composer能够自动加载就可以直接使用dump()方法，而在lumen当中就是dd()辅助函数]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[七牛云javascriptSDK的demo]]></title>
    <url>%2F2016%2F11%2F12%2Fqiniujs-demo%2F</url>
    <content type="text"><![CDATA[使用oss的话碰到用户上传的场景建议优先使用的js上传到oss，不需要经过服务端，也算减轻了服务器的压力，缺点就是有的sdk不支持文件类型的筛分，但这些都是可以规避的 七牛js的sdkdemo 这里用的laravel框架和vuejs，里面涉及到的语法就算 @ 和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Plupload使用指南&lt;/title&gt; &lt;!-- 七牛云存储文件 --&gt; &lt;script src="http://cdn.staticfile.org/Plupload/2.1.1/plupload.full.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.staticfile.org/qiniu-js-sdk/1.0.14-beta/qiniu.min.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.bootcss.com/vue/2.0.3/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 这里我们只使用最基本的html结构：一个选择文件的按钮，一个开始上传文件的按钮(甚至该按钮也可以不要) --&gt;&lt;p id="container"&gt; &lt;button id="browse"&gt;选择文件&lt;/button&gt; &lt;button id="start_upload"&gt;开始上传&lt;/button&gt;&lt;/p&gt;&lt;div id="info"&gt; &lt;p&gt;上传进度@&#123;&#123; loaded &#125;&#125;&lt;/p&gt; &lt;div v-bind:style="&#123; color: 'black', width: percent + 'px' ,height : '10px'&#125;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var data = &#123; percent : 0, speed : 0, loaded : 0, lastTime : '--:--' &#125;; var vm = new Vue(&#123; el : '#info', data : data &#125;); var uploader = Qiniu.uploader(&#123; runtimes: 'html5,flash,html4', // 上传模式,依次退化 browse_button: 'browse', // 上传选择的点选按钮，**必需** // 在初始化时，uptoken, uptoken_url, uptoken_func 三个参数中必须有一个被设置 // 切如果提供了多个，其优先级为 uptoken &gt; uptoken_url &gt; uptoken_func // 其中 uptoken 是直接提供上传凭证，uptoken_url 是提供了获取上传凭证的地址，如果需要定制获取 uptoken 的过程则可以设置 uptoken_func uptoken : '&#123;&#123; $token &#125;&#125;', // uptoken 是上传凭证，由其他程序生成 // uptoken_url: '/uptoken', // Ajax 请求 uptoken 的 Url，**强烈建议设置**（服务端提供） // uptoken_func: function(file)&#123; // 在需要获取 uptoken 时，该方法会被调用 // // do something // return uptoken; // &#125;, get_new_uptoken: false, // 设置上传文件的时候是否每次都重新获取新的 uptoken // downtoken_url: '/downtoken', // Ajax请求downToken的Url，私有空间时使用,JS-SDK 将向该地址POST文件的key和domain,服务端返回的JSON必须包含`url`字段，`url`值为该文件的下载地址 unique_names: true, // 默认 false，key 为文件名。若开启该选项，JS-SDK 会为每个文件自动生成key（文件名） // save_key: true, // 默认 false。若在服务端生成 uptoken 的上传策略中指定了 `sava_key`，则开启，SDK在前端将不对key进行任何处理 domain: 'og3uiutra.bkt.clouddn.com', // bucket 域名，下载资源时用到，**必需** container: 'container', // 上传区域 DOM ID，默认是 browser_button 的父元素， max_file_size: '200mb', // 最大文件体积限制 flash_swf_url: 'http://cdn.staticfile.org/Plupload/2.1.1/Moxie.swf', //引入 flash,相对路径 max_retries: 3, // 上传失败最大重试次数 dragdrop: true, // 开启可拖曳上传 drop_element: 'container', // 拖曳上传区域元素的 ID，拖曳文件或文件夹后可触发上传 chunk_size: '4mb', // 分块上传时，每块的体积 auto_start: true, // 选择文件后自动上传，若关闭需要自己绑定事件触发上传, //x_vars : &#123; // 自定义变量，参考http://developer.qiniu.com/docs/v6/api/overview/up/response/vars.html // 'time' : function(up,file) &#123; // var time = (new Date()).getTime(); // do something with 'time' // return time; // &#125;, // 'size' : function(up,file) &#123; // var size = file.size; // do something with 'size' // return size; // &#125; //&#125;, init: &#123; 'FilesAdded': function(up, files) &#123; plupload.each(files, function(file) &#123; console.log(file); // 文件添加进队列后,处理相关的事情 &#125;); &#125;, 'BeforeUpload': function(up, file) &#123; // 每个文件上传前,处理相关的事情 &#125;, 'UploadProgress': function(up, file) &#123; console.log(file); console.log(file.percent); vm.percent = file.percent; vm.spead = file.spead; vm.loaded = file.loaded; // 每个文件上传时,处理相关的事情 &#125;, 'FileUploaded': function(up, file, info) &#123; // 每个文件上传成功后,处理相关的事情 // 其中 info 是文件上传成功后，服务端返回的json，形式如 // &#123; // "hash": "Fh8xVqod2MQ1mocfI4S4KpRL6D98", // "key": "gogopher.jpg" // &#125; // 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html // var domain = up.getOption('domain'); // var res = parseJSON(info); // var sourceLink = domain + res.key; 获取上传成功后的文件的Url alert('success') &#125;, 'Error': function(up, err, errTip) &#123; console.log(errTip); //上传出错时,处理相关的事情 &#125;, 'UploadComplete': function() &#123; //队列文件处理完毕后,处理相关的事情 &#125;, 'Key': function(up, file) &#123; // 若想在前端对每个文件的key进行个性化处理，可以配置该函数 // 该配置必须要在 unique_names: false , save_key: false 时才生效 var key = ""; // do something with key here return key &#125; &#125; &#125;); // domain 为七牛空间（bucket)对应的域名，选择某个空间后，可通过"空间设置-&gt;基本设置-&gt;域名设置"查看获取 // uploader 为一个 plupload 对象，继承了所有 plupload 的方法，参考http://plupload.com/docs&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里需要后台传给一个token,token内容是 这里 ,或者通过异步请求来token 这里有一个bug当七牛oss的存储空间选择的是华北区的话，目前版本(v1.0.17.1)需要修改以下js文件的上传地址，不然会出现 请求报文格式错误。(400：incorrect region, please use up-z1.qiniu.com) 报错，需要下载最新的(v1.0.17.1) qiniu.js 文件，同时要修改的地方如下，别的地方正常使用。1234567891011121314151617var qiniuUploadUrl; if (window.location.protocol === 'https:') &#123; qiniuUploadUrl = 'https://up.qbox.me'; &#125; else &#123; //qiniuUploadUrl = 'http://upload.qiniu.com'; qiniuUploadUrl = 'http://up-z1.qiniu.com'; &#125; /** * qiniu upload urls * 'qiniuUploadUrls' is used to change target when current url is not avaliable * @type &#123;Array&#125; */ var qiniuUploadUrls = [ "http://upload-z1.qiniu.com", "http://up-z1.qiniu.com" ];]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小程序(2)]]></title>
    <url>%2F2016%2F11%2F07%2Fwxcx-2%2F</url>
    <content type="text"><![CDATA[由上篇博客可以了解小程序运行的一个大体过程,首先app.json进行配置路由和基本的样式调整,其次可以在对应的路由指向的目录下添加 .wxml .wxss .js 这三种文件,只要指定一个路径框架就会对他们自行加载 接下来我们开始了解小程序的一些细节问题: 注册程序在根目录下有app.js这个文件,里面涉及了小程序整体的一些事件响应,代码如下:123456789101112131415161718App(&#123; //当小程序初始化完成时，会触发onLaunch（全局只触发一次） onLaunch: function () &#123; console.log(&apos;App Launch&apos;) &#125;, //当小程序启动，或从后台进入前台显示，会触发onShow onShow: function () &#123; console.log(&apos;App Show&apos;) &#125;, //当小程序从前台进入后台，会触发onHide onHide: function () &#123; console.log(&apos;App Hide&apos;) &#125;, //以及其他的自定义的方法 globalData: &#123; hasLogin: false &#125;&#125;) 这里的前后台转换的前提都是系统没有将小程序销毁,要注意一个概念进入后台不意味着资源被销毁,只有进入后台有一段时间或者系统内存不足的时候小程序才会被回收资源 App() 这个函数是注册小程序的函数,我们进行的操作都是在它里面运行的 App.prototype.getCurrentPage()getCurrentPage()函数用户获取当前页面的实例。 getApp()我们提供了全局的getApp()函数，可以获取到小程序实例。 123// other.jsvar appInstance = getApp()console.log(appInstance.globalData) // I am global data 注意:App()必须在app.js中注册，且不能注册多个。 不要在定义于App()内的函数中调用getApp()，使用this就可以拿到app实例。 不要在onLaunch的时候调用getCurrentPage()，此时page还没有生成。 通过getApp获取实例之后，不要私自调用生命周期函数。 注册页面上篇博客的例子中我们也运用到了怎么对我们要构建的页面进行js操作,这里用到了Page()方法,里面的结果真的和Vue很像,简直就是它的简化版,这里给出了一些api123456789101112131415161718192021222324252627//index.jsPage(&#123; data: &#123; text: &quot;This is page data.&quot; &#125;, onLoad: function(options) &#123; // Do some initialize when page load. &#125;, onReady: function() &#123; // Do something when page ready. &#125;, onShow: function() &#123; // Do something when page show. &#125;, onHide: function() &#123; // Do something when page hide. &#125;, onUnload: function() &#123; // Do something when page close. &#125;, // Event handler. viewTap: function() &#123; this.setData(&#123; text: &apos;Set some data for updating view.&apos; &#125;) &#125;&#125;)]]></content>
      <categories>
        <category>wx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多维数组排序]]></title>
    <url>%2F2016%2F11%2F03%2Fphp-array-1%2F</url>
    <content type="text"><![CDATA[123456789101112131415$testArr = [ ['id'=&gt;1,'msg'=&gt;'aaa'], ['id'=&gt;2,'msg'=&gt;'bbb'], ['id'=&gt;3,'msg'=&gt;'ccc'], ['id'=&gt;4,'msg'=&gt;'ddd'], ];$roler = [2,1,3,4];usort($testArr,function($a,$b) use($roler)&#123; return (array_search($a['id'], $roler) &lt; array_search($b['id'], $roler)) ? -1 : 1;&#125;);var_dump($testArr);die(); 输出结果：反正成功了 还有就是 第一层要是索引数组]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git本地拉取远程分支]]></title>
    <url>%2F2016%2F10%2F28%2Fgit-pull%2F</url>
    <content type="text"><![CDATA[首先git clone一个git库，其次在本地新建一个分支1git checkout -b devlocal 然后设置本地git文件，将本地分支和远程分支关联起来 （我有个远程分支叫做dev）1git branch --set-upstream-to=origin/dev devlocal 再git pull 就能获取到远程git dev分支上的东西到本地的devlocal这个分支上了 还有一个是将本地分支推送到远程分支前要做的处理（远程不存在该分支）1git push --set-upstream origin new]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2路由重写方案]]></title>
    <url>%2F2016%2F10%2F27%2Fyii-rewrite%2F</url>
    <content type="text"><![CDATA[yii2 关于 apache 和 nginx 的路由重写配置 apache路由重写12345678910Options +FollowSymLinksIndexIgnore */*RewriteEngine on# if a directory or a file exists, use it directlyRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-d# otherwise forward it to index.phpRewriteRule . index.php 从yiichina那里推荐的apache路由重写方案直接改服务器的配置文件影响太大了,我们需要把它限制在这个项目里,这样更方便操作了 需要开启 apache 的 rewrite 模块 参考了一下laravel的路由重写方案,首先在你的根目录下 your-app/web创建一个文件 .htaccess文件内容如下123456789&lt;IfModule mod_rewrite.c&gt; # 开启 mod_rewrite 用于美化 URL 功能的支持（译注：对应 pretty URL 选项） RewriteEngine on # 如果请求的是真实存在的文件或目录，直接访问 RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d # 如果请求的不是真实文件或目录，分发请求至 index.php RewriteRule . index.php&lt;/IfModule&gt; nginx路由重写12345location / &#123; if (!-e $request_filename)&#123; rewrite ^/(.*) /index.php last; &#125; &#125; conf/web.php 中的 ‘components’数组是这样的 123456&apos;urlManager&apos; =&gt; [ &apos;enablePrettyUrl&apos; =&gt; true, &apos;showScriptName&apos; =&gt; false, &apos;rules&apos; =&gt; [ ], ],]]></content>
      <tags>
        <tag>rewrite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序初次接触(1)]]></title>
    <url>%2F2016%2F10%2F24%2Fwxcx%2F</url>
    <content type="text"><![CDATA[刚开始接触vue.js没多久就收到小程序内侧的信息,看了看文档两者关联性很强,于是就两者一块学了 首先安装小程序的开发工具,虽然我们没有邀请id但是我们可以通过熟悉操作来达到快速上手,更多的功能体验可以等到正式发布的时候去进行拓展 安装微信开发工具下载网址 目录结构12345app----image---utils---pages---app.json 首先必备的就是app.json文件,这是小程序的配置文件,里面配置了路由,底部菜单,窗口标题等等一些最重要的东西123456789101112131415161718192021222324252627&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;微信小练习&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &#125;, &quot;tabBar&quot;: &#123; &quot;backgroundColor&quot;:&quot;#000000&quot;, &quot;list&quot;: [&#123; &quot;iconPath&quot;:&quot;image/wechat.png&quot;, &quot;selectedIconPath&quot;:&quot;image/wechatHL.png&quot;, &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;iconPath&quot;:&quot;image/record.png&quot;, &quot;selectedIconPath&quot;:&quot;image/play.png&quot;, &quot;pagePath&quot;: &quot;pages/about/about&quot;, &quot;text&quot;: &quot;我的&quot; &#125;] &#125;, &quot;debug&quot; : true&#125; 这个文件的内容可读性也是很不错,各个项目是做什么的让人一目了然, pages块的就是注册前端路由了,比如pages/index/index就是需要引用 pages/index 目录下的 index.wxml index.js index.wxss 我们不需要指定后缀,这都是自动完成的 其他的关于引入文件路径的问题都和这个是一类的 接下来就是关于页面的布局在 pages/index目录下创建 index.wxml文件12345678910111213141516&lt;!--文章列表模板 begin--&gt;&lt;template name=&quot;itmes&quot;&gt; &lt;view class=&quot;imgs&quot;&gt;&lt;image src=&quot;&#123;&#123;imgURL&#125;&#125;&quot; class=&quot;in-img&quot; background-size=&quot;cover&quot; model=&quot;scaleToFill&quot;&gt;&lt;/image&gt;&lt;/view&gt; &lt;view class=&quot;infos&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;date&quot;&gt;&#123;&#123;time&#125;&#125;&lt;/view&gt; &lt;view class=&quot;classification&quot;&gt;&#123;&#123;classification&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;view&gt;hello world&lt;/view&gt;&lt;/template&gt;&lt;!--文章列表模板 begin--&gt;&lt;block wx:for=&quot;&#123;&#123;newList&#125;&#125;&quot;&gt; &lt;template is=&quot;itmes&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot; /&gt;&lt;/block&gt; 在这里, &lt;template&gt;这标签块内的东西只是一个模板,而不会实际显示出来,真正显示的是下面 &lt;block&gt;这个标签对里的东西,他在这里调用了上面的 template 模板, 当然此时是没有东西的,因为我们指定的变量还没有建立 赶紧在同级目录下创建 index.js1234567891011121314151617//获取应用实例var app = getApp()Page(&#123; data: &#123; newList:[&#123;url:&quot;baidu.com&quot;,title:&quot;111&quot;,classification:&quot;ss&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;222&quot;,classification:&quot;ss&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;333&quot;,classification:&quot;12&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;444&quot;,classification:&quot;333&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;555&quot;,classification:&quot;44&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;666&quot;,classification:&quot;44&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;777&quot;,classification:&quot;32&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;888&quot;,classification:&quot;123&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;999&quot;,classification:&quot;456&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;000&quot;,classification:&quot;454&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125; ] &#125;,&#125;) 这个时候重新解析一下调试界面就能看到效果了,这个时候我们还没用到 .wxss 的文件,所以样式还是裸奔状态]]></content>
      <tags>
        <tag>xcx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Larvel ORM模型中的一些方法和变量的作用]]></title>
    <url>%2F2016%2F10%2F21%2Flaravel-orm%2F</url>
    <content type="text"><![CDATA[用代码说话 相关命令： 创建迁移文件 php artisan make:migration Pate_table 进行迁移 php artisan migrate 创建模型文件 php artisan make:model Page 把如下文件内容复制到对应的文件下，就可以按照注释进行测试了。控制器的代码就需要自己动手一遍了，用一次就会了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class Page extends Model&#123; //可批量注入的字段 protected $fillable = ['*']; //不可批量注入的字段 protected $guarded = []; //声明时间字段,这些字段可以调用Carbon,dateTime实例 //如: //$page = Page::find(1); //dd($page-&gt;created_at-&gt;getTimestamp()); protected $dates = ['created_at', 'updated_at']; //设置时间字段属性// protected $dateFormat = 'U'; //当使用 toArray() 和 toJson() 时要隐藏的字段 protected $hidden = ['body']; //$hidden是隐藏 它是显示 两者存在一个就好// protected $visible = ['first_name', 'last_name']; //定义字段调用时的所用的格式 //比如下面的$page-&gt;body 将自动json转array 存储的时候array自动转json protected $casts = [ 'body' =&gt; 'array', ]; //append添加字段是当需要对数据添加不存在的字段的时候,在这里声明一下, //需要配合 getFooAttribute 方法使用, //注意:不要在这里写可调用的字段 // 比如下面的 getTitleAttribute 这个, //如果 $append 数组中存在 title的话则会因为获取不到 $value 参数去执行方法内容 且会将结果覆盖到原有的字段 protected $appends = ['other']; //当类似$page-&gt;title的时候调用该方法, //已发现的问题是在使用select foo as title的时候也会调用这个方法 public function getTitleAttribute($value) &#123; return strtolower($value).'+salt'; &#125; public function getOtherAttribute() &#123; return 'this is other ziduan'; &#125; //当添加或更新title字段的时候将调用该方法, //例如$page-&gt;title = 'foo'; foo将作为参数传递到这里, public function setTitleAttribute($value) &#123; $this-&gt;attributes['title'] = strtoupper($value); &#125;&#125; 相关的表结构如下：12345678910111213141516171819202122232425262728293031323334&lt;?phpuse Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;class CreatePagesTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::create('pages', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('title'); $table-&gt;string('slug')-&gt;nullable(); $table-&gt;text('body')-&gt;nullable(); $table-&gt;integer('user_id'); $table-&gt;timestamps(); &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::drop('pages'); &#125;&#125;]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webuploader插件]]></title>
    <url>%2F2016%2F10%2F12%2Fwebupload-demo%2F</url>
    <content type="text"><![CDATA[通过这个插件让我感觉到大百度还仍然是技术公司 说了句废话,开始正题.这里用的是插件提供的源码 插件官网传送门 demo就是拿的源码的 image-upload 示例,就是把代码中我们需要了解的给摘了出来 html代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;WebUploader演示&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; asset(&apos;webuploaderDemo/css/webuploader.css&apos;) &#125;&#125;&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; asset(&apos;webuploaderDemo/examples/image-upload/style.css&apos;) &#125;&#125;&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;wrapper&quot;&gt; &lt;h1 id=&quot;stopBtn&quot;&gt;暂停&lt;/h1&gt; &lt;h1 id=&quot;continueBtn&quot;&gt;继续&lt;/h1&gt; &lt;h1 id=&quot;cancleBtn&quot; attr=&quot;&quot;&gt;取消&lt;/h1&gt; &lt;div id=&quot;container&quot;&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id=&quot;uploader&quot;&gt; &lt;div class=&quot;queueList&quot;&gt; &lt;div id=&quot;dndArea&quot; class=&quot;placeholder&quot;&gt; &lt;div id=&quot;filePicker&quot;&gt;&lt;/div&gt; &lt;p&gt;或将文件拖动到这里,支持格式:mp4,rmvb,上限3个&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;statusBar&quot; style=&quot;display:none;&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;span class=&quot;text&quot;&gt;0%&lt;/span&gt; &lt;span class=&quot;percentage&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btns&quot;&gt; &lt;div id=&quot;filePicker2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;uploadBtn&quot;&gt;暂停&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; asset(&apos;webuploaderDemo/examples/image-upload/jquery.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; asset(&apos;webuploaderDemo/dist/webuploader.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; asset(&apos;webuploaderDemo/examples/image-upload/upload3.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254(function( $ )&#123; // 当domReady的时候开始初始化 $(function() &#123; var $wrap = $(&apos;#uploader&apos;), // 图片容器 $queue = $( &apos;&lt;ul class=&quot;filelist&quot;&gt;&lt;/ul&gt;&apos; ) .appendTo( $wrap.find( &apos;.queueList&apos; ) ), // 状态栏，包括进度和控制按钮 $statusBar = $wrap.find( &apos;.statusBar&apos; ), // 文件总体选择信息。 $info = $statusBar.find( &apos;.info&apos; ), // 上传按钮 $upload = $wrap.find( &apos;.uploadBtn&apos; ), // 没选择文件之前的内容。 $placeHolder = $wrap.find( &apos;.placeholder&apos; ), $progress = $statusBar.find( &apos;.progress&apos; ).hide(), // 添加的文件数量 fileCount = 0, // 添加的文件总大小 fileSize = 0, // 优化retina, 在retina下这个值是2 ratio = window.devicePixelRatio || 1, // 缩略图大小 thumbnailWidth = 110 * ratio, thumbnailHeight = 110 * ratio, // 可能有pedding, ready, uploading, confirm, done. state = &apos;pedding&apos;, // 所有文件的进度信息，key为file id percentages = &#123;&#125;, // 判断浏览器是否支持图片的base64 isSupportBase64 = ( function() &#123; var data = new Image(); var support = true; data.onload = data.onerror = function() &#123; if( this.width != 1 || this.height != 1 ) &#123; support = false; &#125; &#125; data.src = &quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==&quot;; return support; &#125; )(), // 检测是否已经安装flash，检测flash的版本 flashVersion = ( function() &#123; var version; try &#123; version = navigator.plugins[ &apos;Shockwave Flash&apos; ]; version = version.description; &#125; catch ( ex ) &#123; try &#123; version = new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;) .GetVariable(&apos;$version&apos;); &#125; catch ( ex2 ) &#123; version = &apos;0.0&apos;; &#125; &#125; version = version.match( /\d+/g ); return parseFloat( version[ 0 ] + &apos;.&apos; + version[ 1 ], 10 ); &#125; )(), supportTransition = (function()&#123; var s = document.createElement(&apos;p&apos;).style, r = &apos;transition&apos; in s || &apos;WebkitTransition&apos; in s || &apos;MozTransition&apos; in s || &apos;msTransition&apos; in s || &apos;OTransition&apos; in s; s = null; return r; &#125;)(), // WebUploader实例 uploader; if ( !WebUploader.Uploader.support(&apos;flash&apos;) &amp;&amp; WebUploader.browser.ie ) &#123; // flash 安装了但是版本过低。 if (flashVersion) &#123; (function(container) &#123; window[&apos;expressinstallcallback&apos;] = function( state ) &#123; switch(state) &#123; case &apos;Download.Cancelled&apos;: alert(&apos;您取消了更新！&apos;) break; case &apos;Download.Failed&apos;: alert(&apos;安装失败&apos;) break; default: alert(&apos;安装已成功，请刷新！&apos;); break; &#125; delete window[&apos;expressinstallcallback&apos;]; &#125;; var swf = &apos;./expressInstall.swf&apos;; // insert flash object var html = &apos;&lt;object type=&quot;application/&apos; + &apos;x-shockwave-flash&quot; data=&quot;&apos; + swf + &apos;&quot; &apos;; if (WebUploader.browser.ie) &#123; html += &apos;classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; &apos;; &#125; html += &apos;width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline:0&quot;&gt;&apos; + &apos;&lt;param name=&quot;movie&quot; value=&quot;&apos; + swf + &apos;&quot; /&gt;&apos; + &apos;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;&apos; + &apos;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&apos; + &apos;&lt;/object&gt;&apos;; container.html(html); &#125;)($wrap); // 压根就没有安转。 &#125; else &#123; $wrap.html(&apos;&lt;a href=&quot;http://www.adobe.com/go/getflashplayer&quot; target=&quot;_blank&quot; border=&quot;0&quot;&gt;&lt;img alt=&quot;get flash player&quot; src=&quot;http://www.adobe.com/macromedia/style_guide/images/160x41_Get_Flash_Player.jpg&quot; /&gt;&lt;/a&gt;&apos;); &#125; return; &#125; else if (!WebUploader.Uploader.support()) &#123; alert( &apos;Web Uploader 不支持您的浏览器！&apos;); return; &#125; // 实例化 uploader = WebUploader.create(&#123; auto: true, //开启自动上传 pick: &#123; //点击选择文件按钮 id: &apos;#filePicker&apos;, label: &apos;点击选择文件&apos;, multiple : false //是否开起同时选择多个文件能力。 &#125;, formData: &#123; //上传时的文本内容 uid: 5173180, filename : &apos;filename_test&apos; &#125;, dnd: &apos;#dndArea&apos;, //文件可拖拽范围 paste: &apos;#uploader&apos;, //可通过粘贴添加到文件框内 swf: &apos;../../dist/Uploader.swf&apos;, //flash文件 chunked: true, //开启分片上传 chunkSize: 512 * 1024, //分片大小 512k server : &apos;http://testlaravel/web/uploader&apos;, //后端处理函数 // runtimeOrder: &apos;flash&apos;, accept: &#123; //限制文件类型 title: &apos;Video&apos;, extensions: &apos;mp4,rmvb&apos;, mimeTypes: &apos;video/*&apos; &#125;, disableGlobalDnd: true, // 禁掉全局的拖拽功能。这样不会出现图片拖进页面的时候，把图片打开。 fileNumLimit: 1, //限制上传一个文件 fileSizeLimit: 1024 * 1024 * 1024, // 1 G fileSingleSizeLimit: 1024 * 1024 * 1024, // 单个最大文件 1G method : &apos;POST&apos; //指定上传方法 &#125;); //// 拖拽时不接受 js, txt 文件。 uploader.on( &apos;dndAccept&apos;, function( items ) &#123; var denied = false, len = items.length, i = 0, // 修改js类型 unAllowed = &apos;text/plain;application/javascript &apos;; for ( ; i &lt; len; i++ ) &#123; // 如果在列表里面 if ( ~unAllowed.indexOf( items[ i ].type ) ) &#123; denied = true; break; &#125; &#125; return !denied; &#125;); var oldTime = new Date().getTime(); uploader.on( &apos;uploadProgress&apos;, function( file, percentage ) &#123; console.log(&apos;上传进度:&apos;+ percentage * 100 + &apos;%&apos;); var currentTime = new Date().getTime(); var cha = currentTime - oldTime; var chunkSize = 512; //设置网速 var ws = (chunkSize/cha)*1000; console.log(&apos;当前网速:&apos; + ws + &apos;kb/s&apos;); oldTime = currentTime; &#125;); //接收服务器返回信息 //这里才是接收服务器信息的地方,如果有出错就 `return false` 来停止上传 uploader.on( &apos;uploadAccept&apos;, function( file, response ) &#123; var str = response._raw; var info = eval(&apos;(&apos; + str + &apos;)&apos;); console.log(info); //if ( hasError ) &#123; // // 通过return false来告诉组件，此文件上传有错。 // return false; //&#125; &#125;); uploader.onFileQueued = function( file ) &#123; console.log(&apos;添加文件动作&apos;); $(&apos;#cancleBtn&apos;).attr(&#123;&apos;attr&apos;: file.id&#125;); &#125;; uploader.onUploadFinished = function()&#123; console.log(&apos;完成上传&apos;); &#125; $(&apos;#stopBtn&apos;).on( &apos;click&apos;, function() &#123; console.log(&quot;暂停上传...&quot;); uploader.stop(true); &#125;); $(&apos;#continueBtn&apos;).on( &apos;click&apos;, function() &#123; console.log(&quot;继续&quot;); uploader.upload(); &#125;); $(&apos;#cancleBtn&apos;).on( &apos;click&apos;, function() &#123; console.log(&quot;取消上传&quot;); var id = $(this).attr(&apos;attr&apos;); //指定取消的文件id uploader.cancelFile(id); &#125;); &#125;);&#125;)( jQuery ); 后端php部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public function testSaveWebUploader(Request $request)&#123; //强制浏览器不缓存 header(&quot;Expires: Mon, 26 Jul 1997 05:00:00 GMT&quot;); header(&quot;Last-Modified: &quot; . gmdate(&quot;D, d M Y H:i:s&quot;) . &quot; GMT&quot;); header(&quot;Cache-Control: no-store, no-cache, must-revalidate&quot;); header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false); header(&quot;Pragma: no-cache&quot;); //指定提交方式 if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &apos;OPTIONS&apos;) &#123; exit; // finish preflight CORS requests here &#125; //当出现debug判断服务器报错 if ( !empty($_REQUEST[ &apos;debug&apos; ]) ) &#123; $random = rand(0, intval($_REQUEST[ &apos;debug&apos; ]) ); if ( $random === 0 ) &#123; header(&quot;HTTP/1.0 500 Internal Server Error&quot;); exit; &#125; &#125; @set_time_limit(5 * 60); //临时文件夹和存放文件的文件夹 $targetDir = &apos;upload_tmp&apos;; $uploadDir = &apos;upload&apos;; $cleanupTargetDir = true; // Remove old files $maxFileAge = 5 * 3600; // Temp file age in seconds // 检测文件夹是否存在 if (!file_exists($targetDir)) &#123; @mkdir($targetDir); &#125; if (!file_exists($uploadDir)) &#123; @mkdir($uploadDir); &#125; // 重新设置文件名 $fileName = $this-&gt;renameFile(); $filePath = $targetDir . DIRECTORY_SEPARATOR . $fileName; $uploadPath = $uploadDir . DIRECTORY_SEPARATOR . $fileName; // 是否分片 $chunk = isset($_REQUEST[&quot;chunk&quot;]) ? intval($_REQUEST[&quot;chunk&quot;]) : 0; $chunks = isset($_REQUEST[&quot;chunks&quot;]) ? intval($_REQUEST[&quot;chunks&quot;]) : 1; // 删除过期文件 if ($cleanupTargetDir) &#123; if (!is_dir($targetDir) || !$dir = opendir($targetDir)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 100, &quot;message&quot;: &quot;Failed to open temp directory.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; while (($file = readdir($dir)) !== false) &#123; $tmpfilePath = $targetDir . DIRECTORY_SEPARATOR . $file; // 忽略当前临时文件 if ($tmpfilePath == &quot;&#123;$filePath&#125;_&#123;$chunk&#125;.part&quot; || $tmpfilePath == &quot;&#123;$filePath&#125;_&#123;$chunk&#125;.parttmp&quot;) &#123; continue; &#125; // 过期文件删除 if (preg_match(&apos;/\.(part|parttmp)$/&apos;, $file) &amp;&amp; (@filemtime($tmpfilePath) &lt; time() - $maxFileAge)) &#123; @unlink($tmpfilePath); &#125; &#125; closedir($dir); &#125; // 打开缓存文件 if (!$out = @fopen(&quot;&#123;$filePath&#125;_&#123;$chunk&#125;.parttmp&quot;, &quot;wb&quot;)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 102, &quot;message&quot;: &quot;Failed to open output stream.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; if (!empty($_FILES)) &#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;] || !is_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;])) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 103, &quot;message&quot;: &quot;Failed to move uploaded file.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; // Read binary input stream and append it to temp file if (!$in = @fopen($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;rb&quot;)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 101, &quot;message&quot;: &quot;Failed to open input stream.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; &#125; else &#123; if (!$in = @fopen(&quot;php://input&quot;, &quot;rb&quot;)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 101, &quot;message&quot;: &quot;Failed to open input stream.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; &#125; while ($buff = fread($in, 4096)) &#123; fwrite($out, $buff); &#125; @fclose($out); @fclose($in); //重命名文件名 rename(&quot;&#123;$filePath&#125;_&#123;$chunk&#125;.parttmp&quot;, &quot;&#123;$filePath&#125;_&#123;$chunk&#125;.part&quot;); $index = 0; $done = true; for( $index = 0; $index &lt; $chunks; $index++ ) &#123; if ( !file_exists(&quot;&#123;$filePath&#125;_&#123;$index&#125;.part&quot;) ) &#123; $done = false; break; &#125; &#125; if ( $done ) &#123; if (!$out = @fopen($uploadPath, &quot;wb&quot;)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 102, &quot;message&quot;: &quot;Failed to open output stream.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; if ( flock($out, LOCK_EX) ) &#123; for( $index = 0; $index &lt; $chunks; $index++ ) &#123; if (!$in = @fopen(&quot;&#123;$filePath&#125;_&#123;$index&#125;.part&quot;, &quot;rb&quot;)) &#123; break; &#125; while ($buff = fread($in, 4096)) &#123; fwrite($out, $buff); &#125; @fclose($in); @unlink(&quot;&#123;$filePath&#125;_&#123;$index&#125;.part&quot;); &#125; flock($out, LOCK_UN); &#125; @fclose($out); die(&quot;&#123;&apos;jsonrpc&apos; : &apos;2.0&apos;, &apos;result&apos; : &apos;done&apos;, &apos;chunk&apos; : &apos;&#123;$chunk&#125;&apos;, &apos;chunks&apos;: &apos;&#123;$chunks&#125;&apos;&#125;&quot;); &#125; // Return Success JSON-RPC response die(&quot;&#123;&apos;jsonrpc&apos; : &apos;2.0&apos;, &apos;result&apos; : &apos;success&apos;, &apos;chunk&apos; : &apos;&#123;$chunk&#125;&apos;, &apos;chunks&apos;: &apos;&#123;$chunks&#125;&apos;&#125;&quot;); &#125; protected function renameFile()&#123; //获取后缀 $ext = pathinfo($_FILES[&quot;file&quot;][&quot;name&quot;], PATHINFO_EXTENSION); //文件名 if (isset($_REQUEST[&quot;name&quot;])) &#123; $fileName = isset($_REQUEST[&quot;filename&quot;]) ? $_REQUEST[&quot;filename&quot;] : $_REQUEST[&quot;name&quot;]; &#125; elseif (!empty($_FILES)) &#123; $fileName = $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125; else &#123; $fileName = uniqid(&quot;file_&quot;); &#125; $key = isset($_REQUEST[&apos;uid&apos;]) ? $_REQUEST[&apos;uid&apos;] : &apos;hotcast&apos;; $fileName = md5($fileName.$key); return $fileName.&apos;.&apos;.$ext; &#125; 最后相关的代码已经贴出来了,事件调用在js部分找,后端处理的大体思路就是保存分片上传过来的文件,当文件上传完毕后就通过fwrite或者file_put_content这类的函数给按顺序怼到一个文件当中//如果真的懒需要源码的话 我这有 , 写在了laravel框架里面了,但是代码可以单独拿出来,依赖性并不高]]></content>
      <categories>
        <category>front-end</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Js获取地址信息]]></title>
    <url>%2F2016%2F10%2F10%2Fjs-href%2F</url>
    <content type="text"><![CDATA[js获取api的一系列API接口12345window.location.hostdocument.domain(vue下会发生错误)//全地址window.location.href 补充:获取当前域名信息 代码如下123456789thisTLoc = top.location.href;thisPLoc = parent.document.location;thisTHost = top.location.hostname;thisHost = location.hostname;strwrite = ” thisTLoc: [" + thisTLoc + "]”strwrite += ” thisPLoc: [" + thisPLoc + "]”strwrite += ” thisTHost: [" + thisTHost + "]”strwrite += ” thisHost: [" + thisHost + "]”document.write( strwrite );]]></content>
      <categories>
        <category>front-end</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel的定时任务]]></title>
    <url>%2F2016%2F10%2F09%2Flaravel-cron%2F</url>
    <content type="text"><![CDATA[了解下 laravel 定时任务是怎么使用的首先在linux上创建一个crontab命令.crontab -e第一次用的时候会选择编辑器,默认nano然后在crontab文件中添加一行命令:1***** php /path/to/artisan schedule:run 1&gt;&gt;/dev/null2&gt;&amp;1 linux上的操作就完毕了,接下来是在框架中的操作: 在 app/Console/Kernel.php文件中12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\Console;use Illuminate\Console\Scheduling\Schedule;use Illuminate\Foundation\Console\Kernel as ConsoleKernel;use App\Http\Controllers\SystemConf\SiteVisitorController;class Kernel extends ConsoleKernel&#123;/** * The Artisan commands provided by your application. * * @var array */protected $commands = [//这里是注册自定义命令的,如果不想调用控制器方法就把cron任务写到命令中,也是很方便Commands\Inspire::class, ];/** * Define the application's command schedule. * * @param \Illuminate\Console\Scheduling\Schedule $schedule * @return void */protected function schedule(Schedule $schedule)&#123; //这条命令是测试用的,通过检查是否添加了数据迁移文件来看cron是否已经正常运行 $schedule-&gt;command('make:migration test') //-&gt;everyMinute() //每分钟执行 -&gt;cron('* * * * *'); //linux上cronTab的周期格式 //当调用控制器的方法的时候,一定要把命名空间写全,不然是找不到的, //在文件中用了 use 也没用,因为传入的是字符串 $schedule-&gt;call('App\Http\Controllers\SystemConf\SiteVisitorController@test') -&gt;cron('* * * * *');&#125; 这里仅仅是用artisan命令做了一个测试,实际也可以调用服务,有了这个例子再结合文档来看对小白来说估计就稍微不那么蒙圈了]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel的报错处理]]></title>
    <url>%2F2016%2F10%2F09%2Flaravel-error%2F</url>
    <content type="text"><![CDATA[有很多时候我们需要有404 500 这类的错误页面,在逻辑层里写这些又有些太繁琐,干脆从上游去搞一下 在 app/exceptions/handler.php中 判定$e是属于 http异常还是其他的类似model或者pdo异常，这样就根据异常的类型返回对应的页面，http异常就返回404（其实可以按照状态码分好多） 服务器异常不想显示报错信息就返回一个页面这样的 如果为了方便开发时查看报错信息，需要再添加一层输出debug的配置判定12345678910111213141516171819202122232425/** * Render an exception into an HTTP response. * * @param \Illuminate\Http\Request $request * @param \Exception $e * @return \Illuminate\Http\Response */public function render($request, Exception $e)&#123;// return parent::render($request, $e); if(Config('app.debug'))&#123; if ($e instanceof ModelNotFoundException) &#123; $e = new NotFoundHttpException($e-&gt;getMessage(), $e); &#125; return parent::render($request, $e); &#125; if($e instanceof NotFoundHttpException) &#123; return response()-&gt;view('errors.404', ['message'=&gt;'找不到页面'], 404); &#125; else &#123; return response()-&gt;view('errors.500', ['message'=&gt;'服务器发生未知错误'], 500); &#125;&#125;]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue的初识]]></title>
    <url>%2F2016%2F10%2F09%2Fvue-1%2F</url>
    <content type="text"><![CDATA[照着下面的代码打一遍体会一下vue的优雅1234567891011121314151617181920212223242526272829&lt;div class="mytest"&gt;&#123;&#123;--直接调取js中定义好的值--&#125;&#125;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&#123;&#123;--和模型绑定,这样的话输入框和上面的值能够同步更改--&#125;&#125;&lt;input v-model="message"&gt; &lt;ul&gt;&#123;&#123;--vue中的遍历,和php的遍历相反, items是这个模型中存入的值,todo是遍历出来的单个元素,--&#125;&#125;&lt;li v-for="todo in items"&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123;// 这里是筛选器获取目标classel: '.mytest',// 这里是目标中的变量和变量值,json格式数据data: &#123;message:'this is my test',items: [ &#123;text:'first'&#125;,&#123;text:'second'&#125;,&#123;text:'third'&#125;,] &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>front-end</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laravel5.1使用stmp邮箱服务]]></title>
    <url>%2F2016%2F10%2F09%2Flaravel-stmp%2F</url>
    <content type="text"><![CDATA[这里主要使用的qq邮箱来举例 流程:登录qq邮箱-&gt;进入账户设置-&gt;开通stmp服务 laravel配置.env文件当中：123456MAIL_DRIVER=smtp //服务驱动MAIL_HOST=smtp.qq.com //服务器地址MAIL_PORT=465 //端口MAIL_USERNAME=5173180@qq.com //账户MAIL_PASSWORD=fgxhrahbayzvcai //你账户的授权码，在开通stmp服务的时候获取到MAIL_ENCRYPTION=ssl //安全协议 以上的内容如果不因环境变化可直接写入到config/mail.php文件内config/mail.php内要修改的1&apos;from&apos; =&gt; [&apos;address&apos; =&gt; &apos;5173180@qq.com&apos;, &apos;name&apos; =&gt; &apos;GsMail&apos;], 这样基本配置就算配置好了 测试一下使用 php artisan tinker12345 Mail::send('emails.test',['testVar'=&gt;'LaravelAcademy.org'], function($message)&#123; $message-&gt;to('5173180@qq.com')-&gt;subject('测试邮件 '); &#125;); send的参数分别是发送过去的邮件视图，向邮件视图内绑定的参数，一个回调函数$message变量在视图模板当中恒定存在相关$message的方法有：12345678910111213$message-&gt;from($address, $name = null);$message-&gt;sender($address, $name = null);$message-&gt;to($address, $name = null);$message-&gt;cc($address, $name = null);$message-&gt;bcc($address, $name = null);$message-&gt;replyTo($address, $name = null);$message-&gt;subject($subject);$message-&gt;priority($level);$message-&gt;attach($pathToFile, array $options = []);// 从$data字符串追加文件...$message-&gt;attachData($data, $name, array $options = []);// 获取底层SwiftMailer消息实例...$message-&gt;getSwiftMessage();]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[唉~被Ie坑了一次又一次]]></title>
    <url>%2F2016%2F10%2F08%2Ffuck-ie%2F</url>
    <content type="text"><![CDATA[最近的网站项目当中用上了vue,结果ie低版本的不支持es5的写法,导致各种报错,而且一些很实用的api也不能用了..还有webGL的支持也是让人心碎,于是乎就有了下面的一段代码1234567891011121314$uarowser=$_SERVER['HTTP_USER_AGENT'];if(strstr($uarowser, 'MSIE 6') || strstr($uarowser, 'MSIE 7') || strstr($uarowser, 'MSIE 8'))&#123;echo '&lt;div id="ie-alertBox"&gt;&lt;div id="ie-infoBar"&gt;&lt;h1&gt;对不起，本站不支持低版本ie浏览器！&lt;/h1&gt;&lt;p&gt;请使用ie9或更高的版本&lt;/p&gt;&lt;p&gt;试试火狐啊谷歌什么的超好用的，如果你对IE是真爱......那么请关闭本站吧。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="ie-overlay"&gt;&lt;/div&gt;&lt;style type="text/css"&gt;#ie-alertBox&#123;width: 600px;margin-top: 160px;margin-right: auto;margin-bottom: 0px;margin-left: auto;padding: 20px;border: 1px solid #CCCCCC;text-align: center;font-family: "Microsoft YaHei", Verdana, sans-serif; line-height: 30px;&#125; #ie-infoBar h1&#123;font-size: 22px;color: #ff0000;line-height: 60px;&#125;&lt;/style&gt;';exit;&#125; 当使用万恶的ie的时候可以加上下面段1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; 优先使用chrome渲染,如果碰到ie就用浏览器支持的最高版本]]></content>
      <categories>
        <category>front-end</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F10%2F07%2Fhello-world%202%2F</url>
    <content type="text"><![CDATA[接触编程输出的第一句话就是hello world,这是信仰;终于决定整个博客写点东西了,这里的主要用处就是发牢骚和记录点日常收获;向着大牛匍匐前进;]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Session]]></title>
    <url>%2F2016%2F06%2F01%2Flaravel-session%2F</url>
    <content type="text"><![CDATA[前置条件首先需要有redis的支持 session_driver=database 的另说 1composer require predis/predis 1.0.* 文件配置在.env 文件下的app_key1234APP_KEY=Lajq5EFWYq1COgmgltYM5TlSfRaTxLq1CACHE_DRIVER=redisSESSION_DRIVER=redis config/database.php1234567891011121314'redis' =&gt; [ 'cluster' =&gt; false, //...其它一些配置...// 'session' =&gt; [ 'host' =&gt; env('REDIS_HOST', '8b9a53cd4dc044e7.redis.rds.aliyuncs.com'), 'port' =&gt; 6379, 'database' =&gt; 4, 'password' =&gt; env('REDIS_PASSWORD', 'Hotcast123'), ], ], config/session.php1234567'driver' =&gt; env('SESSION_DRIVER', 'file'),//向指定当session驱动使用redis时指定redis的配置方案（就是上面的那个数组）'connection' =&gt; 'session',//必须指定共同的域名 否则session无法共享'domain' =&gt; '.yourWebName.com', config/cache.php12345'redis' =&gt; [ 'driver' =&gt; 'redis', //这里就是将cache和session的redis配置共用 'connection' =&gt; 'session', ], 示例在 a.yourWebName.com 的route.php12345678Route::get('/test-set-cache-session',function()&#123; Cache::put('cache1','cache1-value',1); Cache::put('cache2','cache2-value',1); Session::put('session1','session1-value',1); Session::put('session2','session2-value',1); return Session::getId();&#125;);//此条路由分别用 Cache 设置两条数据和两条 Session 数据，最后返回 SessionId 在 b.yourWebName.com 的route.php中1234567891011Route::get('/test-get-cache-session',function()&#123; $data = [ 'cache1'=&gt;Cache::get('cache1'), 'cache2'=&gt;Cache::get('cache2'), 'session1'=&gt;Session::get('session1'), 'session2'=&gt;Session::get('session2'), 'session_id'=&gt;Session::getId() ]; return $data;&#125;);//此条路由分别获取获取两条 Cache 数据和两条 Session 数据及 SessionId ,最后返回数据 总结同步session有以下关键点： app_key两者要一样 session配置指向的redis库要一样，这样方便两个程序找到共享的session位置 所属项目需要支持redis扩展包]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Repository]]></title>
    <url>%2F2016%2F04%2F01%2Flaravel-repository%2F</url>
    <content type="text"><![CDATA[laravel版本5.1+ 首先创建测试文件1php artisan make:controller TestController 修改路由文件route.php或者routes/web.php1Route::get('test', 'TestController@index'); 创建服务提供者文件,这个文件的作用就是用来注册自定义的服务容器1php artisan make:provider HelloProvider 我们再创建一个容器文件夹app/Repositories这里存放相应的接口和应用类，现在上我们的主角12345678910111213141516&lt;?php//app/Repositories/Hello.php/** * Created by PhpStorm. * User: gpf * Date: 2016/12/18 * Time: 下午9:30 */namespace App\Repositories;interface Hello&#123; function say();&#125; 123456789101112131415161718&lt;?php//app/Repositories/HelloRepository.php/** * Created by PhpStorm. * User: gpf * Date: 2016/12/18 * Time: 下午9:17 */ namespace App\Repositories;class HelloRepository implements Hello&#123; public function say()&#123; return 'hello baby'; &#125;&#125; 还记得刚才我们创建的HelloProvider吗？现在我们在这里注册一下服务1234567891011121314151617181920212223242526272829&lt;?php//app/Provider/HelloProvider.phpnamespace App\Providers;use Illuminate\Support\ServiceProvider;use App\Repositories\Hello;class HelloProvider extends ServiceProvider&#123; /** * Bootstrap the application services. * * @return void */ public function boot() &#123; // &#125; /** * Register the application services. * * @return void */ public function register() &#123; $this-&gt;app-&gt;bind('App\Repositories\Hello','App\Repositories\HelloRepository'); &#125;&#125; 接下来是最重要的一步，那就是去注册这个服务，你发现每次安装一个依赖包的时候都会操作一个文件，那就是config/app.php，在providers这个数组中添加服务1234'providers' =&gt; [ //other providers... App\Providers\HelloProvider::class, ], 现在就可以使用这个啦！进入我们的TestController1234567891011121314151617181920&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;use App\Repositories\Hello;class TestController extends Controller&#123; public $provider = null; public function __construct(Hello $hello) &#123; $this-&gt;provider = $hello; &#125; public function index()&#123; return $this-&gt;provider-&gt;say(); &#125;&#125; 访问 http://your-domain/test就能看到效果了 这里要记住，我们在控制器中调用的是接口，而接口已经通过provider已经注册绑定了一个符合接口规范的实例，这样的话我们只调用接口提供的外部方法，这样一个好处就是在控制器中我们就专注流程，具体的实现交给服务，内部需要什么依赖就服务自己去解决，而且服务是通用的，每个控制器都能调用，代码的可复用性和可维护性，这一点项目初期可能会感觉不到，但是一旦发生变动的时候，重复改动的地方就会非常多，项目经营时间越长这个变动的代价就会越高 试想一下，如果你是每个controller中都写相同的调度逻辑，有一天你的产品经理对你说：这里这里改一下，添加个字段而已很简单的……你会不会有砍死他的冲动？如果用上了服务仓库，你完全可以先看一下仓库中需要改动的方法到底怎么样再考虑砍人的事情 ：）]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
</search>
