<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[转 Golang 需要避免踩的 50 个坑]]></title>
    <url>%2F2019%2F01%2F31%2Fgo-50-tips%2F</url>
    <content type="text"><![CDATA[Golang 需要避免踩的 50 个坑（一）Golang 需要避免踩的 50 个坑（二）Golang 需要避免踩的 50 个坑（三）大体看了一遍, 看时的想法是: 原来还有这样的?]]></content>
      <categories>
        <category>精选转载</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Go 的 for Range 上的一个坑]]></title>
    <url>%2F2019%2F01%2F30%2Fgo-for-range-error%2F</url>
    <content type="text"><![CDATA[range作为go的一个语法糖在进行迭代的时候是很方便的, 但6是传址赋值的时候需要小心一点 出现问题直接上代码: 12345678910111213141516171819202122232425262728293031package mainimport "fmt"func main() &#123; slice := []int&#123;0, 1, 2, 3&#125; myMap := make(map[int]*int) for index, value := range slice &#123; fmt.Printf("value's memery address: %v | value's value: %v \n", &amp;value, value) myMap[index] = &amp;value &#125; fmt.Println("=====new map by range=====") fmt.Printf("result: %v \n", myMap) prtMap(myMap) myMap2 := make(map[int]*int) for i := 0; i &lt; len(slice); i++ &#123; myMap2[i] = &amp;slice[i] &#125; fmt.Println("=====new map by for=====") fmt.Printf("result: %v \n", myMap2) prtMap(myMap2)&#125;func prtMap(myMap map[int]*int) &#123; for key, value := range myMap &#123; fmt.Printf("map[%v]=%v\n", key, *value) &#125;&#125; 输出:1234567891011121314151617181920value's memery address: 0xc0000160a8 | value's value: 0value's memery address: 0xc0000160a8 | value's value: 1value's memery address: 0xc0000160a8 | value's value: 2value's memery address: 0xc0000160a8 | value's value: 3=====new map by range=====result: map[0:0xc0000160a8 1:0xc0000160a8 2:0xc0000160a8 3:0xc0000160a8]map[1]=3map[2]=3map[3]=3map[0]=3i's memery address: 0xc000016120 | value: 0i's memery address: 0xc000016120 | value: 1i's memery address: 0xc000016120 | value: 2i's memery address: 0xc000016120 | value: 3=====new map by for=====result: map[2:0xc00001c110 3:0xc00001c118 0:0xc00001c100 1:0xc00001c108]map[2]=2map[3]=3map[0]=0map[1]=1 猜测原因range 和 for 进行赋值操作只执行了一次, 因此在上面那个例子中 value和i的内存地址在循环的时候都没变过, 在进行值拷贝的时候是没问题的, 但是一旦加上 &amp; 的时候就变得很危险了, 造成的结果就是上面那个例子中的问题, 新数组存的都是同一个内存地址, 在 for 循环的时候因为只是利用的索引, 没有直接用到切片的值而不会引发这些问题, 在 range 的时候会出现 key,value 同时出现,那么就要小心处理了, 因为这里的value并不是切片中的原值, 而是一个拷贝出来的 Go Range 内部实现go语言坑之for range 类似的问题123456789101112131415161718package mainimport ( "fmt" "sync")func main() &#123; wg := sync.WaitGroup&#123;&#125; for i := 0; i &lt; 4; i++ &#123; wg.Add(1) go func() &#123; fmt.Printf("i is %d \n", i) wg.Done() &#125;() &#125; wg.Wait()&#125; 1输出 4,4,4,4 这个和上一个的问题还不一样, 这个就是闭包的执行顺序以及变量作用域的问题, 在执行闭包的时候for循环已经执行完毕,此时i=4, 接下来才会执行闭包内的函数, 规避这个问题也简单, 把变量的作用域改一下就行, 还有就是函数参数的值拷贝特点1234567for i := 0; i &lt; 4; i++ &#123; wg.Add(1) go func(i int) &#123; fmt.Printf("i is %d \n", i) wg.Done() &#125;(i) &#125; 闭包和变量作用域]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>range</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Mac上一些好玩的命令行工具]]></title>
    <url>%2F2019%2F01%2F18%2Ftool-mac-terminal-awesome%2F</url>
    <content type="text"><![CDATA[mac上一些有意思的命令行小工具 asciinema 和 svg-termassiiname 是用来命令行录屏的, svg-term 将文件转换成svg动图, 这个做截屏很方便 安装:12brew install asciinemanpm install -g svg-term 使用方式:12asciinema rec cast.json // 开始录制, 数据保存在cast.json, 按 ctrl+d 保存cat cast.json | svg-term-cli //输出svg文件 比如下图缺点就是如果文件特别大帧率受到严重的影响 sl 和 cmatrix 小特效玩具安装12brew install slbrew install cmatrix 平时装哔用的 bat安装1brew install bat 替代 cat 命令, 支持代码高亮 ncdu 清理磁盘如标题, 清理磁盘, 直接运行就行 安装1brew install ncdu 收藏链接:优秀的命令行工具整理（一）优秀的命令行工具整理（二）]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>mac</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Gorilla Websocket 搞一个聊天室]]></title>
    <url>%2F2019%2F01%2F15%2Fgo-chat%2F</url>
    <content type="text"><![CDATA[这个demo实现了: 消息广播 心跳检测 提供了一个通过命令行来进行聊天的例子 具体逻辑都在 websocket.go 这个文件里 这里的核心就是 aliveList 这个全局变量, 负责把消息分发给各客户端, 事件用channel来传递, 减少阻塞 单个链接会在 aliveList 中注册, ConnList 就是所有活跃的链接 12345678910111213141516// AliveList 当前在线列表type AliveList struct &#123; ConnList map[string]*Client register chan *Client destroy chan *Client broadcast chan Message cancel chan int Len int&#125;// Client socket客户端type Client struct &#123; ID string conn *websocket.Conn cancel chan int&#125; 服务启动后会执行事件监听循环 123456789101112131415161718192021222324252627282930313233343536373839404142// 启动监听func (al *AliveList) run() &#123; log.Println("开始监听注册事件") for &#123; select &#123; case client := &lt;-al.register: log.Println("注册事件:", client.ID) al.ConnList[client.ID] = client al.Len++ al.SysBroadcast(ConnectedMessage, Message&#123; ID: client.ID, Content: "connected", SentAt: time.Now().Unix(), &#125;) case client := &lt;-al.destroy: log.Println("销毁事件:", client.ID) err := client.conn.Close() if err != nil &#123; log.Printf("destroy Error: %v \n", err) &#125; delete(al.ConnList, client.ID) al.Len-- case message := &lt;-al.broadcast: log.Printf("广播事件: %s %s %d \n", message.ID, message.Content, message.Type) for id := range al.ConnList &#123; if id != message.ID &#123; err := al.sendMessage(id, message) if err != nil &#123; log.Println("broadcastError: ", err) &#125; &#125; &#125; case sign := &lt;-al.cancel: log.Println("终止事件: ", sign) os.Exit(0) &#125; &#125;&#125; 因为消息的类型比较多, 单纯字符串无法满足需求, 就选用了比较常用的json格式去传递, 消息目前分: 12345678910111213141516171819202122const ( // SystemMessage 系统消息 SystemMessage = iota // BroadcastMessage 广播消息(正常的消息) BroadcastMessage // HeartBeatMessage 心跳消息 HeartBeatMessage // ConnectedMessage 上线通知 ConnectedMessage // DisconnectedMessage 下线通知 DisconnectedMessage)// Message 消息体结构type Message struct &#123; ID string Content string SentAt int64 Type int // &lt;- SystemMessage 等类型就是这里了&#125; 如果有空闲时间就再搞搞多聊天室的实现, 以及优化一下目前的事件循环逻辑如果还有更多的余力, 就搞一个好看点的客户端? demo地址]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Yii2 断线重连问题]]></title>
    <url>%2F2018%2F12%2F19%2Fyii-mysql%2F</url>
    <content type="text"><![CDATA[yii2 + swoole 的模式下因为使用swoole做的常驻内存服务, 那么之前的设计思路会有一点偏差, 不是第一眼能看到的就是 mysql has gone away的问题 目前解决思路就是当sql命令报错mysql has gone away的时候就断开重连再重新执行一次 参考 Yii2实现mysql断线重连 重写一个command类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php namespace common\components; use Yii; /** * 新增加执行sql时断开重连 * 数据库连接断开异常 * errorInfo = [''HY000',2006,'错误信息'] * Class Command * @package common\components */ class Command extends \yii\db\Command &#123; const EVENT_DISCONNECT = 'disconnect'; /** * 处理修改类型sql的断线重连问题 * @return int * @throws \Exception * @throws \yii\db\Exception */ public function execute() &#123; try&#123; return parent::execute(); &#125;catch(\Exception $e)&#123; if($this-&gt;handleException($e)) return parent::execute(); throw $e; &#125; &#125; /** * 处理查询类sql断线重连问题 * @param string $method * @param null $fetchMode * @return mixed * @throws \Exception * @throws \yii\db\Exception */ protected function queryInternal($method, $fetchMode = null) &#123; try&#123; return parent::queryInternal($method, $fetchMode); &#125;catch(\Exception $e)&#123; if($this-&gt;handleException($e)) return parent::queryInternal($method, $fetchMode); throw $e; &#125; &#125; /** * 处理执行sql时捕获的异常信息 * 并且根据异常信息来决定是否需要重新连接数据库 * @param \Exception $e * @return bool true: 需要重新执行sql false: 不需要重新执行sql */ private function handleException(\Exception $e) &#123; //如果不是yii\db\Exception异常抛出该异常或者不是MySQL server has gone away $offset = stripos($e-&gt;getMessage(),'MySQL server has gone away'); if(($e instanceof \yii\db\Exception) == false OR $offset === false) //OR $e-&gt;errorInfo[0] != 'HY000' OR $e-&gt;errorInfo[1] != 2006) return false; $this-&gt;trigger(static::EVENT_DISCONNECT); //将pdo设置从null $this-&gt;pdoStatement = NULL; //$this-&gt;db-&gt;resetPdo(); $this-&gt;db-&gt;close(); return true; &#125; &#125; 在配置文件中关于db的配置给加上指定的class123456789101112&lt;?php return [ 'components' =&gt; [ 'db' =&gt; [ 'class' =&gt; 'yii\db\Connection', 'commandClass' =&gt; 'common\components\Command',// 加上这个 'username' =&gt; 'XXX', 'password' =&gt; 'XXX', 'dsn' =&gt; 'mysql:host=XXX;dbname=XXX;port=3306', ], ], ]; 相关文章:Yii2实现mysql断线重连在mysql中connection设置和wait-timeout的设置查看mysql连接情况，以及连接超时时间设置源码剖析Yii错误 Invalid parameter number: no parameters were boundYii 数据库重连告别General error: 2006 MySQL server has gone away]]></content>
      <categories>
        <category>yii2</category>
      </categories>
      <tags>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go Mysql数据库连接池的使用]]></title>
    <url>%2F2018%2F12%2F17%2Fgo-mysql-pool%2F</url>
    <content type="text"><![CDATA[建立一个mysql连接池将极大的缩短应用的响应时间, 减少频繁的io开销以及gc, 这在golang里面也是很容易就实现的 示例代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// main.gopackage mainimport ( "database/sql" "fmt" _ "github.com/GO-SQL-Driver/MySQL" "net/http" "time")var db *sql.DBfunc init() &#123; db, _ = sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8") // 设置最大连接数 db.SetMaxOpenConns(300) // 设置最大空闲连接数 db.SetMaxIdleConns(100) // 设置每个链接的过期时间 db.SetConnMaxLifetime(time.Second * 5) err := db.Ping() checkErr(err)&#125;func main() &#123; startServer(":9999")&#125;func startServer(port string) &#123; http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; record := doSomething() fmt.Fprintln(w, record) &#125;) fmt.Printf("listening http://localhost%s\n", port) err := http.ListenAndServe(port, nil) checkErr(err)&#125;func doSomething() map[string]string &#123; rows, err := db.Query("SELECT * FROM test LIMIT 1") checkErr(err) defer rows.Close() columns, _ := rows.Columns() scanArgs := make([]interface&#123;&#125;, len(columns)) values := make([]interface&#123;&#125;, len(columns)) for j := range values &#123; scanArgs[j] = &amp;values[j] &#125; record := make(map[string]string) for rows.Next() &#123; //将行数据保存到record字典 err = rows.Scan(scanArgs...) for i, col := range values &#123; if col != nil &#123; record[columns[i]] = string(col.([]byte)) &#125; &#125; &#125; // fmt.Println(record) return record&#125;func doSomething2() map[string]string &#123; dbConn, _ := sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8") defer dbConn.Close() rows, err := dbConn.Query("SELECT * FROM test LIMIT 1") checkErr(err) defer rows.Close() columns, _ := rows.Columns() scanArgs := make([]interface&#123;&#125;, len(columns)) values := make([]interface&#123;&#125;, len(columns)) for j := range values &#123; scanArgs[j] = &amp;values[j] &#125; record := make(map[string]string) for rows.Next() &#123; //将行数据保存到record字典 err = rows.Scan(scanArgs...) for i, col := range values &#123; if col != nil &#123; record[columns[i]] = string(col.([]byte)) &#125; &#125; &#125; // fmt.Println(record) return record&#125;func checkErr(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; 测试代码: 12345678910111213141516171819202122232425262728293031323334353637383940// main_test.gopackage mainimport ( "testing")func TestDoSomething(t *testing.T) &#123; record := doSomething() t.Log(record)&#125;func BenchmarkDoSomething(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; doSomething() &#125;&#125;func BenchmarkDoSomethingParallel(b *testing.B) &#123; b.RunParallel(func(pb *testing.PB) &#123; for pb.Next() &#123; doSomething() &#125; &#125;)&#125;func BenchmarkDoSomethingWithoutPoll(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; doSomething2() &#125;&#125;func BenchmarkDoSomethingWithoutPollParallel(b *testing.B) &#123; b.RunParallel(func(pb *testing.PB) &#123; for pb.Next() &#123; doSomething2() &#125; &#125;)&#125; 测试输出对比:12345678910$ go test --bench=.goos: darwingoarch: amd64BenchmarkDoSomething-4 20000 67898 ns/opBenchmarkDoSomethingParallel-4 50000 29347 ns/opBenchmarkDoSomethingWithoutPoll-4 1000 8400516 ns/opBenchmarkDoSomethingWithoutPollParallel-4 2000 8167164 ns/opPASSok _/Users/gpf/Documents/go/code/mysql_curd/pool 28.857s 关键就是这几个方法:1234567db, _ = sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8")// 设置最大连接数db.SetMaxOpenConns(300)// 设置最大空闲连接数db.SetMaxIdleConns(100)// 设置每个链接的过期时间db.SetConnMaxLifetime(time.Second * 5) 设置超时时间很有必要, 避免出现server端主动关闭的情况 mysql has gone away... 代码来源]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go里的点点点语法]]></title>
    <url>%2F2018%2F12%2F14%2Fgo-dotdotdot%2F</url>
    <content type="text"><![CDATA[golang 代码里面有时会出现 ... 这个操作, 初次看到也是摸不到头脑,其实他是用来做数组的析构用的 举个例子就明白了: 123456789101112131415161718192021package mainimport "fmt"func main() &#123; pm := []string&#123;"a", "b", "c"&#125; test("abc", pm...) // 相当于 test("abc", "a", "b", "c") ap := []string&#123;"f", "g"&#125; rs := append(pm, ap...) // 相当于 append(pm, ap[0], ap[1], 以此类推) fmt.Println("rs:", rs)&#125;func test(name string, pms ...string) &#123; fmt.Println("output name:", name) for k, v := range pms &#123; fmt.Printf("k: %v, v: %v \n", k, v) &#125; return&#125; 输出: 12345output name: abck: 0, v: ak: 1, v: bk: 2, v: crs: [a b c f g] 这里做了两个示例: 在func中的 ... eg: func test(name string, pms ...string)代表着不限参数数量, 而多出的参数都放在了 var pms []string 这个数组当中, 在go中典型的使用例子就是 fmt.Print 这一系列的方法 在传参的时候使用... 是用来表示将数组中每个元素单独传入函数中较长用的就是出现数组合并的时候, 使用append() 方法时:这样写正确 12ap := []string&#123;"f", "g"&#125; rs := append(pm, ap...) // 相当于 append(pm, ap[0], ap[1], 以此类推) 这样写就报错12ap := []string&#123;"f", "g"&#125;rs := append(pm, ap)]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crontab 设置一小时执行一次]]></title>
    <url>%2F2018%2F12%2F11%2Flinux-crontab%2F</url>
    <content type="text"><![CDATA[如果主管给你个任务, 让你每小时执行一次脚本, 是不是就是这样:1* */1 * * * xxxxx.bash 这样就错了呦~ 以上产生的结果是每分钟执行一次, 因为从匹配角度来看每分钟都符合规则, 继而执行命令 因此对于整点定时任务有两种写法: 每整点执行一次:10 */1 * * * xxxxx.bash 每隔60分钟执行一次:1*/60 * * * * xxxxx.bash 注意我的描述啊, 整点和隔60分钟其实是两个东西, 根据具体业务要求去使用它 关于定时器这里有三个示例: 在上午8点到11点的第3和第15分钟执行 13,15 8-11 * * * command 每隔两天的上午8点到11点的第3和第15分钟执行 13,15 8-11 */2 * * command 每个星期一的上午8点到11点的第3和第15分钟执行 13,15 8-11 * * 1 command 详细的crontab操作可以参考这篇博客:crontab–定时器命令]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Channel控制并发数量]]></title>
    <url>%2F2018%2F12%2F04%2Fgo-channel-waitgroup%2F</url>
    <content type="text"><![CDATA[使用 go 关键字有时候需要控制一下并发的数量, 但不至于去修改 runtime.GOMAXPROCS 这个数值, 这里就用到了缓冲channel的特性 demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package poolimport ( "sync")// WaitGroup 一个异步结构体type WaitGroup struct &#123; workChan chan int wg sync.WaitGroup&#125;// NewPool 生成一个工作池, coreNum 限制func NewPool(coreNum int) *WaitGroup &#123; ch := make(chan int, coreNum) return &amp;WaitGroup&#123; workChan: ch, wg: sync.WaitGroup&#123;&#125;, &#125;&#125;// Add 添加func (ap *WaitGroup) Add(num int) &#123; for i := 0; i &lt; num; i++ &#123; ap.workChan &lt;- i ap.wg.Add(1) &#125;&#125;// Done 完结func (ap *WaitGroup) Done() &#123;LOOP: for &#123; select &#123; case &lt;-ap.workChan: break LOOP &#125; &#125; ap.wg.Done()&#125;// Wait 等待func (ap *WaitGroup) Wait() &#123; ap.wg.Wait()&#125; test: 123456789101112131415161718192021222324252627package poolimport ( "fmt" "testing" "time")func TestRun(t *testing.T) &#123; work := NewPool(4) for i := 0; i &lt; 50; i++ &#123; work.Add(1) go testFunc(i, work) &#125; fmt.Println("waiting...") work.Wait() t.Log("done")&#125;func testFunc(i int, wg *WaitGroup) &#123; defer wg.Done() fmt.Println(time.Now().Format("2006-01-02T15:04:05Z07:00"), "output: ", i) time.Sleep(time.Second * 1) fmt.Println(time.Now().Format("2006-01-02T15:04:05Z07:00"), "output: ", i, "done")&#125; 输出: 12345678910111213141516172018-12-04T14:22:27+08:00 output: 32018-12-04T14:22:27+08:00 output: 12018-12-04T14:22:27+08:00 output: 02018-12-04T14:22:27+08:00 output: 22018-12-04T14:22:28+08:00 output: 3 done2018-12-04T14:22:28+08:00 output: 0 done2018-12-04T14:22:28+08:00 output: 1 done2018-12-04T14:22:28+08:00 output: 52018-12-04T14:22:28+08:00 output: 62018-12-04T14:22:28+08:00 output: 2 done2018-12-04T14:22:28+08:00 output: 72018-12-04T14:22:28+08:00 output: 42018-12-04T14:22:29+08:00 output: 4 done2018-12-04T14:22:29+08:00 output: 82018-12-04T14:22:29+08:00 output: 7 done2018-12-04T14:22:29+08:00 output: 6 done..... 这里还是要带上 sync.WaitGroup, 保证最后一次循环时携程不会过早退出]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx转发到go服务当中]]></title>
    <url>%2F2018%2F11%2F25%2Fgo-nginx-docker%2F</url>
    <content type="text"><![CDATA[通过docker-compose编排的容器总是有一些奇怪的问题 问题核心就是go-server和nginx所属不同的容器, 需要外界能访问到go的服务就需要进行转发了 如果是在同一个容器中只需要: 1234567891011121314151617181920212223242526server &#123; listen 80; server_name .a.com; charset utf-8; access_log /home/a.com.access.log; location /(css|js|fonts|img)/ &#123; access_log off; expires 1d; root &quot;/path/to/app_a/static&quot;; try_files $uri @backend; &#125; location / &#123; try_files /_not_exists_ @backend; &#125; location @backend &#123; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:8080; &#125;&#125; beego-nginx部署 那么如果是两个容器当中呢? 基于上面的例子, 我们需要用到upstream, 123456789101112131415161718192021222324252627282930313233upstream go_server_proxy &#123; # 这里的server 需要用到 容器名:端口 的形式 server go_server:9090;&#125;server &#123; listen 80; server_name localhost; root /var/www; index index.html; charset utf-8; access_log /var/log/nginx/def.access.log; location /(css|js|fonts|img)/ &#123; access_log off; expires 1d; root &quot;/var/www/static&quot;; try_files $uri @backend; &#125; location / &#123; try_files /_not_exists_ @backend; &#125; location @backend &#123; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_pass http://go_server_proxy; &#125;&#125; 这样做的原因是容器之间的ip并不固定, 使用容器名做host地址是更简单的选择]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
