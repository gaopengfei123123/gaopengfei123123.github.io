<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[__Callstatic]]></title>
      <url>%2F2017%2F06%2F23%2Fphp-callstatic%2F</url>
      <content type="text"><![CDATA[现在很多框架中调用方法都是Foo::bar()这种格式的,但是他们真的是静态方法吗? 这种情况在 larave 中尤其常见,但是开发过程中很明显这些有一部分不是静态的,比如你使用一个模型User,那么你每次实例化出来他都是一个全新的,互不影响,这里就用到了一个魔术方法__callStatic 举个栗子:123456789101112131415161718&lt;?phpclass Test&#123; public function __call($name, $arguments) &#123; echo 'this is __call'. PHP_EOL; &#125; public static function __callStatic($name, $arguments) &#123; echo 'this is __callStatic:'. PHP_EOL; &#125;&#125;$test = new Test();$test-&gt;hello();$test::hi();//this is __call:hello//this is __callStatic:hi 当然魔术方法也是很耗性能的一种方式,每次调用的时候后回先扫一遍class没找到方法时才会调用它,而为了代码的整洁和抽象这个方法也能给很大的帮助,在这之间去要有个权衡 下面实现的 log 类,采用的就是这种方法,将方法解耦出来,只要符合规定的接口就能调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpclass Test&#123; //获取 logger 的实体 private static $logger; public static function getLogger()&#123; return self::$logger?: self::$logger = self::createLogger(); &#125; private static function createLogger()&#123; return new Logger(); &#125; public static function setLogger(LoggerInterface $logger)&#123; self::$logger = $logger; &#125; public function __call($name, $arguments) &#123; call_user_func_array([self::getLogger(),$name],$arguments); &#125; public static function __callStatic($name, $arguments) &#123; forward_static_call_array([self::getLogger(),$name],$arguments); &#125;&#125;interface LoggerInterface&#123; function info($message,array $content = []); function alert($messge,array $content = []);&#125;class Logger implements LoggerInterface &#123; function info($message, array $content = []) &#123; echo 'this is Log method info' . PHP_EOL; var_dump($content); &#125; function alert($messge, array $content = []) &#123; echo 'this is Log method alert: '. $messge . PHP_EOL; &#125;&#125;Test::info('喊个口号:',['好好','学习','天天','向上']);$test = new Test();$test-&gt;alert('hello'); 输出:123456789101112this is Log method infoarray(4) &#123; [0]=&gt; string(6) &quot;好好&quot; [1]=&gt; string(6) &quot;学习&quot; [2]=&gt; string(6) &quot;天天&quot; [3]=&gt; string(6) &quot;向上&quot;&#125;this is Log method alert: hello 也许有的小伙伴已经看出来了,没错!这段代码就是仿照(抄)的 EasyWechat的日志部分,代码片段]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git-Error-Permission]]></title>
      <url>%2F2017%2F06%2F23%2Fgit-error-permission%2F</url>
      <content type="text"><![CDATA[这种情况在部署 webhook 的时候经常会碰到报错信息: git error insufficient permission for adding an object这种报错就是权限错误,把项目中的.git 文件整体改成你的执行权限就行 有一点要注意,如果你服务器上有一个 www 的角色在部署项目,那么你就不能再用root的角色去部署了,否则会在 .git/objects 目录下产生由 root所属的文件从而造成当www再次执行合并任务的时候因为权限不能操作部分commit的文件而造成合并失败]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[转 跨域请求时两次发送请求的问题]]></title>
      <url>%2F2017%2F06%2F23%2Faxios-cors%2F</url>
      <content type="text"><![CDATA[跨域的时候总会碰上各种各样的问题,这就是其中一种情况检查一下，两次请求分别的 Request Method:因为是跨域请求，客户端发先发送一个OPTIONS 请求Preflighted Requests是CORS中一种透明服务器验证机制。预检请求首先需要向另外一个域名的资源发送一个 HTTP OPTIONS 请求头，其目的就是为了判断实际发送的请求是否是安全的。 很有可能是这个问题，我现在用axios 作为我的网络请求库，也遇到了这个问题，跨域访问的时候 ，都会先发送一个OPTIONS请求，用来判断接下来的请求是否安全和被允许 我现在的做法是，在index.php 入口文件中，检测，是否为OPTIONS 请求，如果是就返回一个状态具体代码123456if ($_SERVER[&apos;REQUEST_METHOD&apos;]==&apos;OPTIONS&apos;) &#123; header(&quot;Access-Control-Allow-Origin: *&quot;); header(&quot;Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, Authorization&quot;); header(&apos;Access-Control-Allow-Methods: GET, POST, PUT,DELETE,OPTIONS,PATCH&apos;); return;&#125; 原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git同步所 Fork 的库代码]]></title>
      <url>%2F2017%2F06%2F17%2Fgit-fork-upstream%2F</url>
      <content type="text"><![CDATA[有时候我们 fork 了一个库进行开发,但是时间长了那个库已经添加了一些新的东西,这要怎么处理呢?先添加你 fork 的库的地址12git remote add FORK-sync https://github.com/xxx/yyy.gitgit remote -v 能看到类似的1234FORK-sync https://github.com/xxx/yyy.git (fetch)FORK-sync https://github.com/xxx/yyy.git (push)origin git@github.xxx/born-1.git (fetch)origin git@github.xxx/born-1.git (push) 然后接受所 fork 库的内容1git fetch FORK-sync 合并1git merge FORK-sync/master 再推送到你的远程仓库就行了1git push]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go操作 Json 文本]]></title>
      <url>%2F2017%2F06%2F05%2Fgo-json%2F</url>
      <content type="text"><![CDATA[一些简单的导入导出 事先准备一个 json 文件首先我们准备一个 json 文件,我直接就用的package.json里的一些字段12345678910111213141516&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "author": "GPF &lt;5173180@qq.com&gt;", "description": "A Vue.js project", "dependencies": &#123; "vue": "^2.2.6", "vue-router": "^2.3.1" &#125;, "browserslist": [ "&gt; 1%", "last 2 versions", "not ie &lt;= 8" ]&#125; 具体操作的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( "encoding/json" "fmt" "io/ioutil" "os" "reflect")type allStruct interface&#123;&#125;//定义了获取 json 的结构体type Package struct &#123; Mingzi string `json:"name"` Version string PrIvate bool Dependencies Depend Browserslist []string&#125;type Depend struct &#123; Vue string Router string `json:"vue-router"`&#125;func main() &#123; path := "./package.json" pkg := Package&#123;&#125; file, err := os.Open(path) checkError(err) defer file.Close() data, err := ioutil.ReadAll(file) checkError(err) //这个就是解析 json 格式内容的函数 json.Unmarshal(data, &amp;pkg) foreachStruct(pkg) //output // Mingzi -- hexo-site // Version -- 0.0.0 // PrIvate -- true // Dependencies -- &#123;^2.2.6 ^2.3.1&#125; // Browserslist -- [&gt; 1% last 2 versions not ie &lt;= 8]&#125;//检测错误的方法func checkError(err error) &#123; if err != nil &#123; panic(err) &#125;&#125;//遍历结构体的方法func foreachStruct(st interface&#123;&#125;) &#123; t := reflect.TypeOf(st) v := reflect.ValueOf(st) for k := 0; k &lt; t.NumField(); k++ &#123; key := t.Field(k).Name value := v.Field(k).Interface() fmt.Printf("%s -- %v \n", key, value) &#125;&#125; 这种写法是将 json 自动的赋值给定义好的 struct 上,自动赋值的条件是: 首先查找 tag 含有 jsonkey 值的可导出的 struct 字段(首字母大写),如: 1Mingzi string `json:&quot;name&quot;` //对应 json 中的 &quot;name:&quot; 其次查找字段名相同的可导出的 struct 字段 如: Version string //对应 json 中的 &quot;version:&quot; 然后查找可导出的大小写不敏感的字段 如: PrIvate bool //对应 json 中的 &quot;private&quot; 总之就是如果要求不高就建立 struct 的时候字段直接和 json 字段一一对应就好,但是一定要首字母大写 导入未知结构的 json 数据很多时候我们需要导入的 json 的不确定内容的,或者特别特别长,比如laravel 的 composer.json文件这个时候如果写结构体就很不灵活了,当然,像这种配置型的文件写一个长长的结构体也是可以的于是乎我们就是用 空接口 配合 断言 来实现未知格式json 的解析上代码:这里的composer.json文件可以参考 laravel的composer.json文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package mainimport ( "encoding/json" "fmt" "io/ioutil" "os" "github.com/bitly/go-simplejson")func main() &#123; filePath := "./composer.json" file, err := os.Open(filePath) checkError(err) defer file.Close() data, err := ioutil.ReadAll(file) // checkError(err) readJSON(data) js, err := simplejson.NewJson(data) checkError(err) //获取某个字段值 str, err := js.Get("name").String() checkError(err) fmt.Println("name -&gt; ", str) //多层级的key值 str2, err := js.Get("autoload").Get("classmap").GetIndex(0).String() checkError(err) fmt.Println("autoload.classmap[0] -&gt; ", str2) //判断字段是否存在 //源码内容 https://github.com/bitly/go-simplejson/blob/master/simplejson.go#L157 jType, ok := js.CheckGet("type") if ok &#123; str3, _ := jType.String() fmt.Println("type -&gt; ", str3) &#125; else &#123; fmt.Println("no exist") &#125; //数组 arr, err := js.Get("keywords").Array() checkError(err) for i, v := range arr &#123; fmt.Printf("arr index:%d value:%s \n", i, v) &#125; //字典 mp := js.Get("require").MustMap() fmt.Println("require's key:value is:") for key, value := range mp &#123; fmt.Printf("%s : %s \n", key, value) &#125;&#125;func checkError(err error) &#123; if err != nil &#123; panic(err) &#125;&#125;func readJSON(data []byte) &#123; //定义一个由空接口组成的字典用来承接解析出来的 json var f map[string]interface&#123;&#125; json.Unmarshal(data, &amp;f) //通过断言来判断字段类型 for k, v := range f &#123; switch v.(type) &#123; case string: fmt.Println(k, "is string ====&gt;", v) case int: fmt.Println(k, "is int ====&gt;", v) case []interface&#123;&#125;: fmt.Println(k, "is interface ====&gt;", v) default: fmt.Println(k, "is null type ====&gt;", v) &#125; &#125;&#125; 除了 空接口&amp;断言 这种万用的写法,社区里也是有不少成熟的轮子,我这里用的就是一个很不错的轮子simpleJson,以上给了几个示例,更全面的在轮子的 github中的测试文件中列举出来了 作为新手首要的目标就是先让项目跑起来,等有一定的代码量之后再去看轮子的源码,如果先看源码经常起到事倍功半的效果—-这是我说的 导出 json 格式文件知道了如何导入就要知道如何导出,接下来就是导出的一些需要注意的地方上代码12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( "encoding/json" "fmt")//Server is a json formattype Server struct &#123; ServerName string `json:"serverName"` ServerIP string `json:"serverIP"` Port int `json:"port,string"` // ,string 将 int,int64,bool,string 类型字段按 string 输出 Version string `json:"version,omitempty"` //添加了 ,omitempty 修饰符的意思就是如果该字段未空就不输出&#125;//Serverslice is a json formattype Serverslice struct &#123; ID string `json:"-"` // - 将不会处理 Servers []Server `json:"servers"`&#125;func main() &#123; var s Serverslice s.Servers = append(s.Servers, Server&#123;"beijing_vpn", "127.0.0.1", 22, "v0.0.1"&#125;) s.Servers = append(s.Servers, Server&#123;ServerName: "chegongzhuang", ServerIP: "127.0.0.2", Port: 443&#125;) b, err := json.Marshal(s) checkError(err) fmt.Println(string(b))&#125;func checkError(err error) &#123; if err != nil &#123; panic(err) &#125;&#125;//输出内容为://&#123;"servers":[&#123;"serverName":"beijing_vpn","serverIP":"127.0.0.1","port":"22","version":"v0.0.1"&#125;,&#123;"serverName":"chegongzhuang","serverIP":"127.0.0.2","port":"443"&#125;]&#125; 我们使用了encoding/json这个包,而且是将结构体转成的 json 格式,需要注意一下几点: 定义Struct的字段必须是首字母大写可导出的,如果不写tag的话将按照字段名来输出 tag中设置的自定义名称如json:&quot;serverName&quot;将优先于字段名用于 json 的字段当中按照我们刚才的例子就是 json 中输出 serverName 而不是 ServerName 如果 tag:&quot;-&quot; 将不对这个字段进行处理marshal 函数需要注意的问题: tag:&quot;xxx,omitempty&quot;这种修饰词就是如果字段为空时不输出 tag:&quot;xxx,string&quot;将 int,int64,bool,string 类型字段按 string 输出 json 对象只支持 string 作为 key,因此如果要编码一个 map 必须是map[string]T (T 代表任意类型) channel,complex和 function 不能被输出 指针在编码的时候会输出指针指向的内容,空指针输出null 参照七牛的sdk 文档就是一个很好的例子]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于使用 Git 的操作流程]]></title>
      <url>%2F2017%2F05%2F27%2Fgit-workflow%2F</url>
      <content type="text"><![CDATA[老夫的毕生功力都在这了… 通常我们工作时是这样操作说一下使用 git 做版本控制的时候的工作流程1234git add -A #需要添加到版本库中的文件 -A 就代表着所有文件(除开了 .gitignore忽略掉的文件)git commit -m &apos;本次提交的备注&apos;git pull #将远程的库和本地的库版本同步一下,因为远程库可能发生了修改(多人合作开发时)git push 这样操作的前提是本地远程都是同一个 master 分支上 最可能会碰到的问题以上操作前两步通常不会碰到问题,最容易发生问题的是 git pull 这一步因为多人开发时难免碰到同时修改了同一个文件,那么就会产生冲突git 是根据文件每行发生的修改进行的判定的,如果同时对同一文件的同一行发生了修改,就卡死到这一步上了 怎么解决这个问题我常用的是命令行和 phpstrom 中的版本控制工具,最推荐的是命令行操作,别的图形界面也是调的命令行接口直接学会git 的命令是学习成本最低的一种方式,一次学会到处可用啊! 命令行还有个强大的地方就是它的提示通常就是你解决问题的方法,照着提示打就行(要善用提示啊,别看见报错就慌了) 我们做一个实验,我自己的一个版本库本地和远程同时发生了修改,而且是操作的同一个文件,我直接进行 git push操作看到提示没?提示中的 hint 中说了,向远程库中更新被拒,因为远程有了修改而本地没有(说白了就是没同步),这通常发生在另一个版本库向远程推送了相同的文件(就是两个人在这个版本下同时操作了同一个文件),提示中给出原因之后紧接着给出了解决办法(e.g., &#39;git pull ...&#39;)before pushing again, 我们按着它给的提示操作一下通常如果两个人之间的操作不发生冲突比如同时修改了同一个文件的同一行的情况下就会进入commit的编辑界面了,但是我给他人为的造成一个错误,这个错误就是我们最常碰到的错误,合并冲突看到提示中的最后一行了没有?Automatic merge failed; fix conflicts and then commit the result.自动合并失败了,请修复冲突并再次提交 如果文件很多我怎么去找到它? 一种是靠界面工具主动把错误推到你面前 另一种就是自己去找了 第一种方法坑爹的地方就是好多工具他给你提示就提示一次,你如果给关了就不会再提示了,但是该提交不上去的还是提交不上去,而且如果是线上火速修复的时候你的编辑器是帮不到那么远的我们选第二种,肯定不是挨个文件去翻啊!会死人的 有一个很有用的命令1git status 标红的文件都给你了,而且还给你了需要执行的命令,你别假装看不到啊!当然这个时候直接git add &amp;&amp; git commit会出事的,你还没解决冲突呢!我们去这个冲突文件中解决掉冲突本地能跑通了再提交,而且这个错误提示会指名文件路径的,我这个冲突文件因为正好是在项目的根目录下才没有的 打开这个文件我们看到如下的内容:我这是在 phpstrom 中打开的文件,如果phpstrom 能读取到你项目中的 .git/ 目录是可以进行版本控制的这里phpstrom 就帮你把冲突文件标红了,多么醒目~当然这也是我们自己找的如果文件内容特别多但是就一两处冲突时我们直接搜索关键词 HEAD或者&lt;&lt;&lt;&lt;&lt;&lt;&lt;就行,你懂的…被尖角号扩起来的就是冲突的地方,接下来就是保孩子还是保大人解决冲突的时候了,找到谁和你改的同一处代码 什么?你说你找不到是谁?你没看到代码冲突块下的 779833d952d8a6557b2e8eba3bd192ede5cb6ca0这一段文字吗?你先别激动,这个点还不适合开车,这个是提交的 commit-id,你每次提交都会产生的一个标识要查看这到底是谁和我的代码冲突了就执行下面的命令1git log 779833d952d8a6557b2e8eba3bd192ede5cb6ca0 第一行就是你要的结果,如果直接git log -p 就是列出所有的提交记录 -p 就是显示出修改的地方 冲突块部分 HEAD就是你写的代码,下面的是别人写的,去掉其中一个把那些标签清理干净,测试一下没问题了再git add &amp;&amp; git commit &amp;&amp; git pull &amp;&amp; git push 这四连技好了,世界清净了 这合并的时候发生了什么?这是我在 segmentfault 中给出的答案: 比如你从一个git log为1,2,3,4,5,6的远程库拉取到了本地,另一个同事也拉取了同样的代码,而且你的同事先于你提交到远程了,此时远程的版本是1,2,3,4,5,6,7_new,8_new,而你当前只是本地的版本1,2,3,4,5,6,7_local,8_local,9_local从这里你就能看出你前一部分和远程的一样,后一部分和远程的不一样,这个时候你不能正常推送上去的,如果你采取git push origin master --force那么远程的版本就变成了1,2,3,4,5,6,7_local,8_local,9_local之前你同事推送的7_new,8_new这两次推送被覆盖了,这不是大家想要的情况因此需要git pull来将本地的版本合并成样1,2,3,4,5,6,7_new,7_local,8_local,8_new,9_local,10_commit_merge远程和本地的排序是按当时 commit 的时间来排的,最后一个10_commit_merge就是你本地和远程合并的标志,最后你推送到远程仓库的应该也是这个,因为你们操作的是同一个库始终要保持代码的同步,所以一旦版本库发生改动同一分支下的所有人都要跟着去同步他,因为各开发各的直接往上推 git 还没智能到帮你处理冲突的地步答案链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Laravel54初始化迁移失败]]></title>
      <url>%2F2017%2F05%2F24%2Flaravel54-migrate-error%2F</url>
      <content type="text"><![CDATA[在新版的 laravel 框架当中(v5.4.23) 出现了报错1234[Illuminate\Database\QueryException] SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was t oo long; max key length is 767 bytes (SQL: alter table `users` add unique ` users_email_unique`(`email`)) 错误重现: laravel 版本 5.4.23 配置好数据库链接,执行12php artisan make:authphp artisan migrate 就会出现错误 解决办法:打开文件 @yourApp/app/Prividers/AppserviceProvider.php123456use Illuminate\Support\Facades\Schema;function boot()&#123; Schema::defaultStringLength(191);&#125; 文章来源: laracast]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go-Mysql]]></title>
      <url>%2F2017%2F05%2F17%2Fgo-mysql%2F</url>
      <content type="text"><![CDATA[这里写一个go 操作 mysql 的 curd 的 demo 表结构是这样的123456create table test( id int primary key auto_increment, name varchar(20) default '', age int default 0, created_at int default 0) go 的文件是:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( "database/sql" "fmt" "time" _ "github.com/GO-SQL-Driver/MySQL")func checkErr(err error) &#123; if err != nil &#123; panic(err) &#125;&#125;func main() &#123; db, err := sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8") defer db.Close() checkErr(err) //insert stmt, err := db.Prepare("INSERT test SET name=? , age=? , created_at=?") checkErr(err) res, err := stmt.Exec("gaopengfei", 22, time.Now().Unix()) checkErr(err) //获取插入数据的 id id, err := res.LastInsertId() checkErr(err) fmt.Printf("insert id %d \n", id) //update stmt, err = db.Prepare("UPDATE test SET age=? WHERE id &lt; ?") checkErr(err) res, err = stmt.Exec(233, 4) checkErr(err) //输出受影响的条数 affect, err := res.RowsAffected() checkErr(err) fmt.Printf("affected num is %d \n", affect) //select rows, err := db.Query("SELECT * FROM test") checkErr(err) for rows.Next() &#123; var id int var name string var age int var createdAt int //go 不让使用下划线的方式定义变量,如果字段是 created_at 需要写成 createdAt 驼峰命名法 err = rows.Scan(&amp;id, &amp;name, &amp;age, &amp;createdAt) checkErr(err) //将int 转成 int64格式,方便格式化时间 var tm64 int64 tm64 = int64(createdAt) tm := time.Unix(tm64, 0) fmt.Printf("id is %d; name is %s; age is %d: created_at is %s \n", id, name, age, tm.Format("2006-01-02 03:04:05 PM")) &#125; //delete stmt, err = db.Prepare("DELETE FROM test WHERE id=?") checkErr(err) res, err = stmt.Exec(3) checkErr(err) affect, err = res.RowsAffected() checkErr(err) fmt.Printf("affected num is %d \n", affect)&#125; 这里使用了一个稳定的 mysql 包,因为 go 官方并没有实现 mysql 的实例,而是提供了数据操作的接口只要能实现就可以进行操作 文件头部 import 中出现了 _ &quot;github.com/GO-SQL-Driver/MySQL&quot; 这样的写法,意思是引用 _ 后面的包名而不直接使用其中的函数,变量等资源 另外不得不吐槽一下 go 的时间格式函数,我大 php 的格式化是这样的1date("Y-m-d H:i:s",time()) 这边的是 “Y-m-d H:i:s” 啊!,一眼就看出来格式是什么了,但是 go 里的格式是这样的1234timestamp := time.Now().Unix()tm := time.Unix(timestamp, 0)timer := tm.Format("2006-01-02 03:04:05 PM")fmt.Println(timer) 他的格式代表不是 Y,m,d,H,i,s 而是 2006,01,02,03,04,05 PM这个也好记,1234567891011121314151617月份 1,01,Jan,January日 2,02,_2时 3,03,15,PM,pm,AM,am分 4,04秒 5,05年 06,2006周几 Mon,Monday时区时差表示 -07,-0700,Z0700,Z07:00,-07:00,MST时区字母缩写 MST]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Php-Callback-Func]]></title>
      <url>%2F2017%2F05%2F11%2Fphp-callback-func%2F</url>
      <content type="text"><![CDATA[你知道茴香的茴有四种写法,那你知道 php 的回调也有四种写法吗? 匿名函数1234var $array = [1,2,3];array_map(function($item)&#123; return $item;&#125;,$array); 类静态调用12345678910class A&#123; static function test($req) &#123; echo "hello world"; &#125;&#125;var $array = [1,2,3];array_map('A::Test',$array);array_map(['A','Test'],$array); 函数12345function test($item)&#123; return 'hello world';&#125;var $array = [1,2,3];array_map('test',$array); 对象方法12345678910class A&#123; static function test($req) &#123; echo "hello world"; &#125;&#125;var $array = [1,2,3];$obj = new A();array_map([$obj,'test'],$array); 转载自:4种PHP回调函数风格-Swoole扩展-Swoole文档中心]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git-Askpass-Error]]></title>
      <url>%2F2017%2F05%2F08%2Fgit-askpass-error%2F</url>
      <content type="text"><![CDATA[git 的账号密码错误情况 error前段时间使用 phpstrom 中的 git 出现了一个错误1234Fetch failed error: unable to read askpass response from &apos;..\tmp\intellij-git-askpass.bat&apos; error: failed to execute prompt script (exit code 1) fatal: could not read Username for &apos;http://xxx:3000&apos;: No error 大体情况就是某一次操作的时候账户密码发生了变动,导致本地的 git 没权限去拉取远程库了(因为用的是 https)的方式 解决第一种(推荐): 将远程地址换成 ssh 地址,使用 ssh-key 登录 第二种: 实在不想换的话就是用这种方式1git remote set-url origin https://&lt;username&gt;:&lt;password&gt;@github.com/&lt;username&gt;/&lt;repo_name&gt;.git 将账号密码写入到请求地址当中比如我账户为: gaopengfei 密码为: 123456请求的库的地址是 https://github.com/gaopengfei123123/redis_lbs.git那么我的远程地址就是1git remote set-url origin https://gaopengfei:123456@github.com/gaopengfei123123/redis_lbs.git 参考issues]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue-Transition]]></title>
      <url>%2F2017%2F05%2F06%2Fvue-transition%2F</url>
      <content type="text"><![CDATA[对 vue 的渐变效果的简单使用 单个节点的渐变效果123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;动画测试&lt;/title&gt; &lt;link href="http://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet"&gt; &lt;script src="http://cdn.bootcss.com/vue/2.3.2/vue.js"&gt;&lt;/script&gt; &lt;style media="screen"&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="example"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;!-- 同一个节点的多个显隐效果 --&gt; &lt;transition mode="out-in" enter-active-class="animated fadeInDown" leave-active-class="animated fadeOutDown"&gt; &lt;p v-if="show" key="1"&gt;hello&lt;/p&gt; &lt;p v-else key="2"&gt;world&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; new Vue(&#123; el: '#example', data: &#123; show: true, &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 这里解释一下 &lt;transition&gt; 中的参数问题: mode=&quot;out-in&quot; 采用的切换模式是 先出后进,保证两个节点能平滑的切换显示, 还有一种是 in-out,如果没有指定mode将同时生效,两个元素的动画同时触发这不是我现在需要的 enter-active-class=&quot;animated fadeInDown&quot; 元素显示时添加的 class , 这里使用了 animate.css, leave-active-class=&quot;animated fadeOutDown&quot; 元素消失时显示的动画 key 相同标签名中必须的标识,否则 vue 将不能区分元素内容 一种运用 key 简化判断的一种写法123&lt;transition mode="out-in" enter-active-class="animated fadeInDown" leave-active-class="animated fadeOutDown"&gt; &lt;p :key="status"&gt;&#123;&#123; status &#125;&#125;&lt;/p&gt;&lt;/transition&gt; 它的效果等同于:12345678&lt;transition mode="out-in" enter-active-class="animated fadeInDown" leave-active-class="animated fadeOutDown"&gt; &lt;button v-if="status === 'show'" key="show"&gt; show &lt;/button&gt; &lt;button v-if="status === 'hidden'" key="hidden"&gt; hidden &lt;/button&gt;&lt;/transition&gt; 如果是多重的状态判断这个会很实用 多组件之间的状态过渡123456789101112131415161718192021222324252627&lt;div id="example"&gt; &lt;input type="radio" v-model="view" value="v-a"&gt; &lt;input type="radio" v-model="view" value="v-b"&gt; &lt;!-- 多个组件的过渡效果 --&gt; &lt;transition mode="out-in" enter-active-class="animated fadeInDown" leave-active-class="animated fadeOutDown"&gt; &lt;component v-bind:is="view"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; new Vue(&#123; el: '#example', data: &#123; view: 'v-a' &#125;, methods: &#123;&#125;, components: &#123; 'v-a': &#123; template: '&lt;div&gt;Component A&lt;/div&gt;' &#125;, 'v-b': &#123; template: '&lt;div&gt;Component B&lt;/div&gt;' &#125; &#125; &#125;) &lt;/script&gt; 这种情况下部需要添加 key 值了,因为每次动态渲染的时候都只有一个]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 Axios-Post 提交数据]]></title>
      <url>%2F2017%2F05%2F02%2Fvue-axios-post%2F</url>
      <content type="text"><![CDATA[继 vue-resource 之后, axios 是 vue 官方首推的网络请求组件 axios简介它的功能更强大,而且可以无痛迁移到新的项目当中,有尤大的原话就是: 最近团队讨论了一下，Ajax 本身跟 Vue 并没有什么需要特别整合的地方，使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果，vue-resource 提供的价值和其维护成本相比并不划算，所以决定在不久以后取消对 vue-resource 的官方推荐。已有的用户可以继续使用，但以后不再把 vue-resource 作为官方的 ajax 方案。这里可以去掉 vue-resource，文档也不必翻译了。原文链接 这里还有一份看两眼就是能用的手册 关于 csrf 攻击这篇文章想说的不是怎么用 axios,而是之前碰到了一种情况,就是在 php 框架当中,碰到了 csrf 验证的问题关于 csrf 攻击这里也不会讲,因为前辈们已经说的很详细了,比如这篇通俗易懂的文章 axios 与 csrf-token我常用的两个框架中 laravel 是支持在 header 中设置 csrf-token 的,而 yii 中的默认设置只是在表单提交的内容中检测 csrf-token 相关的字段,使用 axios 提交内容的时候默认并不会出现在 from-data内容当中,比如这样提交的12345678910111213let postUrl = '/route/to/action';let postData = &#123; id : 1, name: "xiaoming", _csrf_token : "&lt;?= Yii::$app-&gt;request-&gt;csrfToken ?&gt;"&#125;axios.post(postUrl,postData) .then(function(res)&#123; console.log(res) &#125;) .catch(function (error) &#123; console.log(error) &#125;) 但是这样的提交形式在 yii2.0 当中是接收不到提交的内容的,因为它的内容是存在了 request payload当中所以使用Yii::$app-&gt;request-&gt;post()是获取不到内容的,想要得到提交的内容需要这样:12345function requestPayload()&#123; $request_payload = file_get_contents('php://input'); return json_decode($request_payload,true);&#125;print_r(requestPayload()); 这样做的缺点就是获取请求都是自己去实现,而不是通过框架的 request 类去处理这么做的前提还是关闭所提交 controller 的 csrf-token 验证,不安全啊同志们! 那么问题来了,用什么样的姿势提交能让框架去识别并自动提取出来 csrf-token 呢? 说了那么多废话终于到正题了,关键就是这个类了:12345678910111213let postUrl = '/route/to/action';let postData = new FormData();postData.append('action', 'ADD');postData.append('param', 0);postData.append('_csrf_token', '&lt;?= Yii::$app-&gt;request-&gt;csrfToken ?&gt;');axios.post(postUrl,postData) .then(function(res)&#123; console.log(res) &#125;) .catch(function (error) &#123; console.log(error) &#125;) 在这之前 bb 了那么多也是想让自己的印象更清晰一点,边说边捋思路,这是当初找到答案的地方github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jquery 中$(This) 和 This 的区别]]></title>
      <url>%2F2017%2F05%2F02%2Fjquery-this%2F</url>
      <content type="text"><![CDATA[说一个常识性的东西,帮助自己回忆一下 一句话, $(this)是 jquery 的对象,而 this 是 html 元素对象 什么意思呢? $(this) 可以调用jquery 中的方法12$(this).val()$(this).addClass() 而 this 是属于 html 的对象,属于原生 js,因此不能用 jq 中一些封装好的方法12this.valuethis.id 这两者容易造成混淆的地方就是在调用 jq 方法时使用闭包的情景下:123$('#input').blur(function()&#123; inputCheck(this)&#125;); 在 inputCheck(param) 这个方法中在调用参数的时候就不能再使用 jqery 的方法了,会报函数找不到的错误,因此需要转换一下,一般情景下的转换关系是这样的:1$(this)[0] == this]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于 Ssh 的 25 条实用命令]]></title>
      <url>%2F2017%2F04%2F28%2Fssh-command%2F</url>
      <content type="text"><![CDATA[OpenSSH是SSH连接工具的免费版本。telnet，rlogin和ftp用户可能还没意识到他们在互联网上传输的密码是未加密的，但SSH是加密的，OpenSSH加密所有通信（包括密码），有效消除了窃听，连接劫持和其它攻击。此外，OpenSSH提供了安全隧道功能和多种身份验证方法，支持SSH协议的所有版本。 SSH是一个非常伟大的工具，如果你要在互联网上远程连接到服务器，那么SSH无疑是最佳的候选。下面是通过网络投票选出的25个最佳SSH命令，你必须牢记于心。 （注：有些内容较长的命令，在本文中会显示为截断的状态。如果你需要阅读完整的命令，可以把整行复制到您的记事本当中阅读。） 复制SSH密钥到目标主机，开启无密码SSH登录1ssh-copy-id user@host 如果还没有密钥，请使用ssh-keygen命令生成。 从某主机的80端口开启到本地主机2001端口的隧道1ssh -N -L2001:localhost:80 somemachine 现在你可以直接在浏览器中输入 http://localhost:2001访问这个网站。 将你的麦克风输出到远程计算机的扬声器1dd if=/dev/dsp | ssh -c arcfour -C username@host dd of=/dev/dsp 这样来自你麦克风端口的声音将在SSH目标计算机的扬声器端口输出，但遗憾的是，声音质量很差，你会听到很多嘶嘶声。 比较远程和本地文件1ssh user@host cat /path/to/remotefile | diff /path/to/localfile – 在比较本地文件和远程文件是否有差异时这个命令很管用。 通过SSH挂载目录/文件系统1sshfs name@server:/path/to/folder /path/to/mount/point 从http://fuse.sourceforge.net/sshfs.html下载sshfs，它允许你跨网络安全挂载一个目录。 通过中间主机建立SSH连接1ssh -t reachable_host ssh unreachable_host Unreachable_host 表示从本地网络无法直接访问的主机，但可以从 reachable_host 所在网络访问，这个命令通过到 reachable_host 的“隐藏”连接，创建起到 unreachable_host 的连接。 将你的SSH公钥复制到远程主机，开启无密码登录 – 简单的方法1ssh-copy-id username@hostname 直接连接到只能通过主机B连接的主机A1ssh -t hostA ssh hostB 当然，你要能访问主机A才行。 创建到目标主机的持久化连接1ssh -MNf &lt;user&gt;@&lt;host&gt; 在后台创建到目标主机的持久化连接，将这个命令和你~/.ssh/config中的配置结合使用：123Host hostControlPath ~/.ssh/master-%r@%h:%pControlMaster no 所有到目标主机的SSH连接都将使用持久化SSH套接字，如果你使用SSH定期同步文件（使用rsync/sftp/cvs/svn），这个命令将非常有用，因为每次打开一个SSH连接时不会创建新的套接字。 通过SSH连接屏幕1ssh -t remote_host screen –r 直接连接到远程屏幕会话（节省了无用的父bash进程）。 端口检测（敲门）1knock &lt;host&gt; 3000 4000 5000 &amp;&amp; ssh -p &lt;port&gt; user@host &amp;&amp; knock &lt;host&gt; 5000 4000 3000 在一个端口上敲一下打开某个服务的端口（如SSH），再敲一下关闭该端口，需要先安装knockd，下面是一个配置文件示例。 123456789101112[options]logfile = /var/log/knockd.log[openSSH]sequence = 3000,4000,5000seq_timeout = 5command = /sbin/iptables -A INPUT -i eth0 -s %IP% -p tcp –dport 22 -j ACCEPTtcpflags = syn[closeSSH]sequence = 5000,4000,3000seq_timeout = 5command = /sbin/iptables -D INPUT -i eth0 -s %IP% -p tcp –dport 22 -j ACCEPTtcpflags = syn 删除文本文件中的一行内容，有用的修复1ssh-keygen -R &lt;the_offending_host&gt; 在这种情况下，最好使用专业的工具。 通过SSH运行复杂的远程shell命令1ssh host -l user $(&lt;cmd.txt) 更具移植性的版本：1ssh host -l user “`cat cmd.txt`” 通过SSH将MySQL数据库复制到新服务器1mysqldump –add-drop-table –extended-insert –force –log-error=error.log -uUSER -pPASS OLD_DB_NAME | ssh -C user@newhost “mysql -uUSER -pPASS NEW_DB_NAME” 通过压缩的SSH隧道Dump一个MySQL数据库，将其作为输入传递给mysql命令，我认为这是迁移数据库到新服务器最快最好的方法。 删除文本文件中的一行，修复“SSH主机密钥更改”的警告1sed -i 8d ~/.ssh/known_hosts 从一台没有SSH-COPY-ID命令的主机将你的SSH公钥复制到服务器1cat ~/.ssh/id_rsa.pub | ssh user@machine “mkdir ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys” 如果你使用Mac OS X或其它没有ssh-copy-id命令的*nix变种，这个命令可以将你的公钥复制到远程主机，因此你照样可以实现无密码SSH登录。 实时SSH网络吞吐量测试1yes | pv | ssh $host “cat &gt; /dev/null” 通过SSH连接到主机，显示实时的传输速度，将所有传输数据指向/dev/null，需要先安装pv。 如果是Debian：1apt-get install pv 如果是Fedora：1yum install pv （可能需要启用额外的软件仓库）。 如果建立一个可以重新连接的远程GNU screen1ssh -t user@some.domain.com /usr/bin/screen –xRR 人们总是喜欢在一个文本终端中打开许多shell，如果会话突然中断，或你按下了“Ctrl-a d”，远程主机上的shell不会受到丝毫影响，你可以重新连接，其它有用的screen命令有“Ctrl-a c”（打开新的shell）和“Ctrl-a a”（在shell之间来回切换），请访问阅读更多关于screen命令的快速参考。 继续SCP大文件1rsync –partial –progress –rsh=ssh $file_source $user@$host:$destination_file 它可以恢复失败的rsync命令，当你通过VPN传输大文件，如备份的数据库时这个命令非常有用，需要在两边的主机上安装rsync。1rsync –partial –progress –rsh=ssh $file_source $user@$host:$destination_file local -&gt; remote 或1rsync –partial –progress –rsh=ssh $user@$host:$remote_file $destination_file remote -&gt; local 通过SSH W/ WIRESHARK分析流量1ssh root@server.com ‘tshark -f “port !22″ -w -&apos; | wireshark -k -i – 使用tshark捕捉远程主机上的网络通信，通过SSH连接发送原始pcap数据，并在wireshark中显示，按下Ctrl+C将停止捕捉，但也会关闭wireshark窗口，可以传递一个“-c #”参数给tshark，让它只捕捉“#”指定的数据包类型，或通过命名管道重定向数据，而不是直接通过SSH传输给wireshark，我建议你过滤数据包，以节约带宽，tshark可以使用tcpdump替代： 1ssh root@example.com tcpdump -w – ‘port !22′ | wireshark -k -i – 保持SSH会话永久打开1autossh -M50000 -t server.example.com ‘screen -raAd mysession’ 打开一个SSH会话后，让其保持永久打开，对于使用笔记本电脑的用户，如果需要在Wi-Fi热点之间切换，可以保证切换后不会丢失连接。 更稳定，更快，更强的SSH客户端1ssh -4 -C -c blowfish-cbc 强制使用IPv4，压缩数据流，使用Blowfish加密。 使用cstream控制带宽1tar -cj /backup | cstream -t 777k | ssh host ‘tar -xj -C /backup’ 使用bzip压缩文件夹，然后以777k bit/s速率向远程主机传输。Cstream还有更多的功能，请访问了解详情，例如：1echo w00t, i’m 733+ | cstream -b1 -t2 一步将SSH公钥传输到另一台机器1ssh-keygen; ssh-copy-id user@host; ssh user@host 这个命令组合允许你无密码SSH登录，注意，如果在本地机器的~/.ssh目录下已经有一个SSH密钥对，ssh-keygen命令生成的新密钥可能会覆盖它们，ssh-copy-id将密钥复制到远程主机，并追加到远程账号的~/.ssh/authorized_keys文件中，使用SSH连接时，如果你没有使用密钥口令，调用ssh user@host后不久就会显示远程shell。 将标准输入（stdin）复制到你的X11缓冲区1ssh user@host cat /path/to/some/file | xclip 你是否使用scp将文件复制到工作用电脑上，以便复制其内容到电子邮件中？xclip可以帮到你，它可以将标准输入复制到X11缓冲区，你需要做的就是点击鼠标中键粘贴缓冲区中的内容。 原文地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go-Http]]></title>
      <url>%2F2017%2F04%2F26%2Fgo-http%2F</url>
      <content type="text"><![CDATA[用于了解 http 包的一些运行机制 首先一个简单的例子123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "net/http" "strings" "log")func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() //解析参数,默认不解析 fmt.Println(r.Form) //在终端中打印出表单内容 fmt.Println("Path", r.URL.Path) fmt.Println("scheme", r.URL.Scheme) fmt.Println(r.Form["url_long"]) //输出指定的参数 for k,v := range r.Form&#123; //遍历打印出表单的值 fmt.Println("key",k) fmt.Println("val", strings.Join(v, "")) &#125; fmt.Fprint(w, "hello gpf!")&#125;func main()&#123; http.HandleFunc("/", sayhelloName) //绑定路由与方法 err := http.ListenAndServe(":9090", nil) //监听 tcp:9090 端口 if err != nil &#123; log.Fatal("ListenAndServe: ",err) &#125;&#125; 文件目录下 go build http.go ./http 再直接访问http://localhost:9090就能看到页面了 运行流程是什么呢?大体的运行流程是介样: 创建 Listen Socket,监听 tcp 协议的 9090 端口,等待请求 收到请求后创建一个 client socket 去解析请求(request) 将请求内容交给 handle request 去处理,处理后返回给 client socket(handler) client socket 收到后台的处理结果返回给用户(response) 我们80%的逻辑都是在第3步内进行的,其他的已经有底层包帮我们实现了 我们的路由绑定机制是怎么实现的?当走到以上的第3步的时候将会进入自己独立的 goroutine ,这也是用户访问互不影响的原因,这一点和 nginx 很像,都是异步非阻塞的处理方式用来应对高并发 在最开始的例子当中我们绑定路由是直接将路由和函数指定了的,这里面发生了什么呢?当调用1http.HandleFunc("/", sayhelloName) 时 因为没有对监听函数传递第二个参数,传了个 nil 进去1http.ListenAndServe(":9090", nil) nil 的位置本应该是一个 handler,如果为空的话,将调用默认的 handler ,即 DefaultServeMux,因为它实现了 Handler 接口所以能处理请求, Handler接口的内容是123type Handler interface&#123; ServeHTTP(ResponseWriter, *Request)&#125; 这个方法就是我们的路由实现器,我们所有的路由指向的方法都是在这里处理的, 可是为什么我的sayhelloName()并没有实现 Handler的接口但还是正常运行了,这怎么回事呢?这是因为 http.HandleFunc()帮你完成了这个接口的实现,文档 自己实现一个简易的路由1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( "fmt" "net/http")//设定一个空的接口体来承载接口type MyMux struct&#123;&#125;//实现 Handler 接口,在这里处理路由相关的内容func (p *MyMux) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; if r.URL.Path == "/" &#123; sayHello(w, r) return &#125; if r.URL.Path == "/login" &#123; loginPage(w, r) return &#125; http.NotFound(w, r) return&#125;func sayHello(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprint(w, "Hello route '/' !")&#125;func loginPage(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "this is login page")&#125;func main() &#123; //实例化结构体 mux := &amp;MyMux&#123;&#125; //当做 handler 注入到监听服务当中去 http.ListenAndServe(":9090", mux)&#125; 如果想自己实现路由的处理也可以这样试试,但是我不想平白的用一个空的 struct 去承载这个啊,我们可以试试这个 ServeMux12345678910111213141516171819package mainimport ( "fmt" "net/http")func main() &#123; mux := http.NewServeMux() mux.HandleFunc("/login", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "this is login page") &#125;) mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "hello your first page") &#125;) http.ListenAndServe(":9090", mux)&#125; 说了这么多其实还是云里雾里的,不过没关系,可以先放在这里,等用的多了自然也能想开了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go-Comma-Switch]]></title>
      <url>%2F2017%2F04%2F24%2Fgo-comma-switch%2F</url>
      <content type="text"><![CDATA[简单介绍下 comma-ok 和 switch 用来判定变量类型上篇博客介绍了接口,接口在实际应用中可以当做一个万用变量来用,可以用一个空接口来存储多种类型的变量但是,当我们需要取出来用的时候就要头疼一下取出的到底是哪种类型的数据了 comma-okvalue, ok := element.(type) element 就是我们要判断的变量,括号中是要判断的类型,value 就是变量的值,ok 是 bool 类型,true||false 123456789101112131415161718192021222324252627282930313233343536package mainimport ( "fmt" "strconv")type Element interface&#123;&#125; //定义一个空接口type List []Element //定义一个由空接口组成的数组类型type Person struct &#123; name string age int&#125;func (p Person) String() string &#123; return "&lt; " + p.name + "-" + strconv.Itoa(p.age) + "years old /&gt;"&#125;func main() &#123; list := make(List, 3) list[0] = 1 list[1] = "shakalaka" list[2] = Person&#123;"Gao", 25&#125; for index, element := range list &#123; if value, ok := element.(int); ok &#123; fmt.Printf("list[%d] is int and value is %d \n", index, value) &#125; else if value, ok := element.(string); ok &#123; fmt.Printf("list[%d] is string and value is %s \n", index, value) &#125; else if value, ok := element.(Person); ok &#123; fmt.Printf("list[%d] is Person and value is %s \n", index, value) &#125; else &#123; fmt.Printf("list[%d] is undefined", index) &#125; &#125;&#125; 这里就是调用 go 提供的内置函数, 在 php 当中就是 is_null,is_array这类的函数方法,这种写法判定单个类型的时候比较方便,但是类型一多就会出现多个 if-else 这样很不优雅,于是就有了下面的写法 switch用代码看是最直观的1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "fmt" "strconv")type Element interface&#123;&#125; //定义一个空接口type List []Element //定义一个由空接口组成的数组类型type Person struct &#123; name string age int&#125;func (p Person) String() string &#123; return "&lt; " + p.name + "-" + strconv.Itoa(p.age) + "years old /&gt;"&#125;func main() &#123; list := make(List, 3) list[0] = 1 list[1] = "shakalaka" list[2] = Person&#123;"Gao", 25&#125; for index, element := range list &#123; switch value := element.(type) &#123; case int: fmt.Printf("list[%d] is int and value is %d \n", index, value) case string: fmt.Printf("list[%d] is string and value is %s \n", index, value) case Person: fmt.Printf("list[%d] is Person and value is %s \n", index, value) default: fmt.Printf("list[%d] is undefined", index) &#125; &#125;&#125; 这样就能批量判定类型了这里需要注意一下, element.(type) 这种写法只能出现在 switch 当中,判定单个类型的时候还是老实的用 value , ok := element.(type) 这种写法看到这里我们发现其实调用的都是同一个内置函数,就是添加了一个 switch 这样的使用情景]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go-Interface]]></title>
      <url>%2F2017%2F04%2F19%2Fgo-interface%2F</url>
      <content type="text"><![CDATA[关于 go 语言接口的简单介绍接口对于 go 实现面向对象来说非常重要,如果没有它 go 的结构体(struct)也就只能存储一些信息,但是相关的方法将会变得非常麻烦 什么是接口?接口就是制定一个通用的规范,只要符合这个规范就能使用这个借口(听起来像是车轱辘话) 接口类型比如我定义了一个接口1234type example interface&#123; a() b()&#125; 他定义了两个方法,只要有结构体中含有 a(),b()两个方法就能实现这个接口,通过接口来统一调用,如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//package main//import "fmt"//定义一个基本的类type Human struct&#123; name string age int phone string&#125;type Student struct&#123; Human //继承 human 中的字段 school string loan float32&#125;type Employee struct&#123; Human company string money float32&#125;//Human 实现 Sayhi 方法func (h Human) Sayhi()&#123; fmt.Printf("hi my name is %s and my phone is %s \n", h.name,h.phone)&#125;//Human 实现 Sing 方法func (h Human) Sing(lyrics string) &#123; fmt.Println("galigaygay galigaygay ...",lyrics)&#125;//student 复写 Sayhi 方法func (sdt Student) Sayhi() &#123; fmt.Printf("my name is %s and my school is %s \n", sdt.name,sdt.school)&#125;//定义一个通用的接口type Men interface&#123; Sayhi() Sing(lyrics string)&#125;func main () &#123; //实例化两种类 mike := Student&#123;Human&#123;"mike",25,"18333636999"&#125;,"MIT",3.14&#125; jack := Employee&#123;Human&#123;"jack",30,"18333636998"&#125;,"hotcast",20000&#125; //定义一个接口变量 var i Men //接口实现了 Student 类的方法 fmt.Println("下面有请 mike 开始他的表演:") i = mike i.Sayhi(); i.Sing("dongci daci") //接口实现了 Employee 类的方法 fmt.Println("下面有请 mike 开始他的表演:") i = jack i.Sayhi(); i.Sing("haha haha haha")&#125; 这里的 Men 接口被所有继承了Human的结构体的方法所实现,所以这些实例化的结构体可以赋值给Men的接口变量上,我们在 go 语言中的面向对象开发可以说就是面向接口在开发,由接口来组成一个个的变量,这和 php 的接口有所不同,在 php 中,接口是需要被 class 来继承,然后class 中去实现 interface 中指定的方法,比如12345678910111213interface Human&#123; function sayHi(); function sing();&#125;class Student implements Human&#123; public function sayHi()&#123; // TODO: &#125; public function sing()&#123; // TODO: &#125;&#125; 这样子的, 每个类需要指定继承哪些接口才可以去实现接口,而 go 和 php 正好相反,是谁实现了我的规范谁就可以用我的接口,实现顺序正好倒过来了 再举一个接口的例子12345678910111213141516171819202122package mainimport ( "fmt" "strconv")type Human struct &#123; name string age int phone string&#125;// 这里需要把 int 类型转换成字符串,否则使用 + 来连接字符的时候报数据类型不匹配的错误func (h Human) String() string &#123; return "&lt;" + h.name + "-" + strconv.Itoa(h.age) + "years old ,phone is " + h.phone + "/&gt;"&#125;func main() &#123; Duck := Human&#123;"duck", 22, "110-120-119"&#125; fmt.Println("this human is :", Duck)&#125; 上述例子当中我们实现了 fmt.Println 中的一个接口```gotype Stringer interface { String() string} 这样之后,调用 Human 的 String() 函数就能被 fmt.Println() 所用了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go-Simple-Webserver-Demo]]></title>
      <url>%2F2017%2F04%2F18%2Fgo-simple-webserver-demo%2F</url>
      <content type="text"><![CDATA[用 go 写的一个简单的 http 服务 123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "net/http" "strings" "log")func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() //解析参数,默认不解析 fmt.Println(r.Form) //在终端中打印出表单内容 fmt.Println("Path", r.URL.Path) fmt.Println("scheme", r.URL.Scheme) fmt.Println(r.Form["url_long"]) //输出指定的参数 for k,v := range r.Form&#123; //遍历打印出表单的值 fmt.Println("key",k) fmt.Println("val", strings.Join(v, "")) &#125; fmt.Fprint(w, "hello gpf!")&#125;func main()&#123; http.HandleFunc("/", sayhelloName) //绑定路由与方法 err := http.ListenAndServe(":9090", nil) //监听 tcp:9090 端口 if err != nil &#123; log.Fatal("ListenAndServe: ",err) &#125;&#125; 打包运行之后访问 http://localhost:9090/index?url_long=aa&amp;url_long=23445&amp;name=gpf 将在页面和终端都有显示,前后台的逻辑也是在这里执行的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git-Submodule]]></title>
      <url>%2F2017%2F04%2F11%2Fgit-submodule%2F</url>
      <content type="text"><![CDATA[项目中经常会使用到第三方的 git 库,将三方库整合到项目中最简单的办法就是复制粘贴,但是如果这个库升级了一个很酷炫的功能,你要怎么整合进来呢?这就是本次要介绍的 git-submodule 操作,直接把第三方的版本库合并到自己的库中. 添加第三方库我这里是自己开了两个库做测试,主库叫 body,另一个库叫 leg 首先在本地的body库中添加leg123git clone https://git.oschina.net/gaofeifps/body.gitcd bodygit submodule add https://git.oschina.net/gaofeifps/leg.git 这时查看下状态会多两个文件123456789➜ body git:(master) ✗ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits)Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: .gitmodules new file: leg 这就多了一个 leg的库,和一个.gitmodules的文件,现在提交一下1git commit -am &quot;add leg&quot; 在其他地方使用合并后的版本库本地提交了版本之后可以提交到远程试一下1git push 这时去远程库中看的话库中的内容是这样的这里有个奇怪的 leg @ 6dec2fa,明明是没有的啊?点一下原来是一个快捷方式,直接给连接到了 leg库的地址,版本库中不会存第三方引入库的实体文件,而是通过 .gitmodules的方式存储三方的联系方式,当下载到本地运行的时候才会再拉取文件 而且这个时候在其他的地方安装body这个库的时候直接运行 git clone 是生成不了完整的文件的,缺少了 leg库的文件因为这个时候的 body/leg目录是空的需要多走一步,这时为什么呢?我们下面会讲到原因12345git clone https://git.oschina.net/gaofeifps/body.gitgit submodule init &amp;&amp; git submodule update#下面这一句的效果和上面三条命令的效果是一样的,多加了个参数 `--recursive`git clone https://git.oschina.net/gaofeifps/body.git --recursive 这时才是一个完整的库 将三方库同步到主线之前的一些步骤其实还不完整,因为 body/leg 这个目录中的文件并没有和主线在一条线上,这也是为什么在远程库的 leg 目录是空的,因为在 master 分支里面它确实是空的,文件是在另一个分支上,我们先去看一下1234cd path/to/body/leg➜ leg git:(6dec2fa) git branch* (HEAD detached at 6dec2fa) master 别的文件的分支都是 master 到这个文件的时候就是 6dec2fa分支了,其实这个值也是 leg库当前的 commitId而且如果不把第三方的库纳入自己的主线的话会非常的危险,因为你对项目中的三方库发生的任何改动都不会对主线产生任何影响,被主线遗忘了,因此我们还需要接下来的操作12cd path/to/body/leggit checkout master 更新第三方库这里有个问题就是如果body/leg发生了更新就首先在这个文件中提交一个commit,然后在body这个目录下再 commit一次第一次 commit 是为了更新 leg的版本控制,第二次更新是更新body的版本控制,同时更新 leg库在body的指针 如果更新的比较多,可以运行 批量更新第三方库假设你的项目当中引入了100个第三方的库,你需要同步的时候难道还要每一个都要执行:123cd module-dir/git checkout mastergit pull 是不是想起了小学被老师罚抄一百遍的恐惧当中了?少年,多看看文档准没错的,这些东西 git 早就帮你想好了具体操作可以看一下git help submodule有相关的介绍的不想看文档的就直接告诉你123git submodule foreach &lt;command&gt;比如:git submodule foreach git checkout master 这条命令就会按照 .gitmodules会根据path寻找所有的三方模块,并在每一个模块中都执行 foreach 后的命令,比如你想批量更新模块到最新的时候就:1git submodule foreach git submodule update 画个重点(敲黑板!)如果像让你引入的第三方库leg符合你自己的定制,你在里面发生了一些修改,但是这些修改并不能提交到远程去,因为你的提交会让第三方库的作者产生困扰:我写的好好的一个轮子你给定制成这样,还怎么去给其他的人用? 而且这个问题很严重,如果你本地的leg和body都更新了,但是 第三方的leg不能提交到远程,而body提交上去了,那么与你同使用一个版本库的小伙伴就会因为当前项目leg的指针地址找不到而产生报错 所以如果有定制的需要就得去fork这个项目到你自己的 github 上,然后自己想怎么折腾都随意了,但是怎么去既有定制,还能保持和轮子作者的版本同步呢? 怎么保持与作者同步?首先是自己有一个 fork 的三方项目,然后在自己本地添加一个三方的源123456789101112cd path/to/body/leg➜ leg git:(master) git remote -vorigin https://git.oschina.net/gaofeifps/leg.git (fetch)origin https://git.oschina.net/gaofeifps/leg.git (push)#添加第三方包的源地址➜ leg git:(master) git remote add dist_source https://git.oschina.net/xxxx/leg.git➜ leg git:(master) git remote -vdist_source https://git.oschina.net/xxxx/leg.git (fetch) #这个是三方的源地址dist_source https://git.oschina.net/xxxx/leg.git (push)origin https://git.oschina.net/gaofeifps/leg.git (fetch) #这个是你 fork 的项目地址origin https://git.oschina.net/gaofeifps/leg.git (push) 这样的话可以拉取源文件到本地并合并本地代码1git pull dist_source master 修复一下版本冲突的文件,确认没有问题之后提交到自己 fork 的库中1git push origin master 这样其他人就能正常使用了 写了这么多忽然发现:还是复制粘贴比较省事啊! 那么 怎么删除submodule?在当前 git 版本1.7.8之前,删除指定的 submodule 的命令是1git rm &lt;submodule-name&gt; 在新版的 git 下,则是运行以下命令1git submodule deinit &lt;submodule-name&gt; 查看本地有哪些三方模块可以查看 .gitmodules1234➜ body git:(master) cat .gitmodules[submodule &quot;leg&quot;] path = leg url = https://git.oschina.net/gaofeifps/leg.git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Npm-DTrace]]></title>
      <url>%2F2017%2F04%2F10%2Fnpm-DTrace%2F</url>
      <content type="text"><![CDATA[安装npm模块的时候有时候会提示Error: Cannot find module &#39;./build/Release/DTraceProviderBindings 虽然会正常运行但是总是报这个错也是很不爽的,查了下相关的 issues比较直接的解决方法是1sudo npm install dtrace-provider ubuntu 和 macos 上都有效 这是一个历史遗留的问题,开发者已经逐渐替代了这个模块,所以说影响不大,如果觉的终端总是报错很烦就这样试试吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker-Composer-Install]]></title>
      <url>%2F2017%2F04%2F10%2Fdocker-composer-install%2F</url>
      <content type="text"><![CDATA[安装 docker-composer123curl -L https://github.com/docker/compose/releases/download/1.1.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 可能会有被墙的情况,可以找一下国内的云服务商,比如 DaoCloud]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Brew-Update]]></title>
      <url>%2F2017%2F04%2F09%2Fbrew-update%2F</url>
      <content type="text"><![CDATA[brew更新软件时常用的操作 安装 brewruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/Go/install)&quot; 搜索brew search MySQL 查看程序具体信息brew info mysql 更新 brewbrew update 更新软件brew upgrade mysql如果不指定更新哪个则会更新所有可以更新的软件 清理缓存(更新完后的操作)brew cleanup 查看本地所有可更新的工具brew outdated]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Yii-Multi-Database]]></title>
      <url>%2F2017%2F04%2F08%2Fyii-multi-database%2F</url>
      <content type="text"><![CDATA[在项目中经常会碰到多个数据库的情况,在 yii 中也是可以快速设置的演示的版本是 basic 版,但是原理很好理解 编辑配置文件 @app/config/web.php1234......'db' =&gt; require(__DIR__ . '/db.php'), //框架提供的一个默认连接'localDb' =&gt; require(__DIR__ . '/db2.php'), //这个是我们新加的一个连接配置...... 在同目录下的 db2.php 内容格式和 db.php 格式一样,只是连接不同 修改 model 中需要使用的 connection id这时再在想改的 model 中复写 getDb() 方法1234567891011121314151617181920class Members extends \yii\db\ActiveRecord&#123; /** * @inheritdoc */ public static function tableName() &#123; return 'members'; &#125; /** * @return \yii\db\Connection the database connection used by this AR class. */ public static function getDb() &#123; return Yii::$app-&gt;get('localDb'); &#125; ......some functions.................&#125; 这个 model 中我们使用了 localDb 的链接配置,可以追踪代码 \yii\db\ActiveRecord中的 getDb() 方法,123456789101112//in \yii\db\ActiveRecord/** * Returns the database connection used by this AR class. * By default, the "db" application component is used as the database connection. * You may override this method if you want to use a different database connection. * @return Connection the database connection used by this AR class. */ public static function getDb() &#123; return Yii::$app-&gt;getDb(); &#125; 有这么一段,既然已经显示出来 Yii::$app 这种核心的东西了,说明已经离那个connection容器已经不远了再追踪到getDb() 显示的是 $this-&gt;get(&#39;db&#39;) 转换一下不就是默认使用的 Yii::$app-&gt;get(&#39;db&#39;) 吗? 于是回到最开始的 model 中,将其重写为 Yii::$app-&gt;get(&#39;localDb&#39;),之后我们再使用这个 model 的时候就是使用的id 为localDb的 connection 单例了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Json-Format]]></title>
      <url>%2F2017%2F04%2F08%2Fjson-format%2F</url>
      <content type="text"><![CDATA[如何将 json 格式化打印出来 想练手的可以手写一个出来,比如12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass Helper&#123; public static function jsonFormat($data, $indent=null)&#123; // 对数组中每个元素递归进行urlencode操作，保护中文字符 array_walk_recursive($data, [self::class,'jsonFormatProtect']); // json encode $data = json_encode($data); // 将urlencode的内容进行urldecode $data = urldecode($data); // 缩进处理 $ret = ''; $pos = 0; $length = strlen($data); $indent = isset($indent)? $indent : ' '; $newline = PHP_EOL; $prevchar = ''; $outofquotes = true; for($i=0; $i&lt;=$length; $i++)&#123; $char = substr($data, $i, 1); if($char=='"' &amp;&amp; $prevchar!='\\')&#123; $outofquotes = !$outofquotes; &#125;elseif(($char=='&#125;' || $char==']') &amp;&amp; $outofquotes)&#123; $ret .= $newline; $pos --; for($j=0; $j&lt;$pos; $j++)&#123; $ret .= $indent; &#125; &#125; $ret .= $char; if(($char==',' || $char=='&#123;' || $char=='[') &amp;&amp; $outofquotes)&#123; $ret .= $newline; if($char=='&#123;' || $char=='[')&#123; $pos ++; &#125; for($j=0; $j&lt;$pos; $j++)&#123; $ret .= $indent; &#125; &#125; $prevchar = $char; &#125; return $ret; &#125; public static function jsonFormatProtect(&amp;$val)&#123; if($val!==true &amp;&amp; $val!==false &amp;&amp; $val!==null)&#123; $val = urlencode($val); &#125; &#125;&#125;$array = [ 'key1' =&gt; 123, 'key2' =&gt; 'abc', 'key3' =&gt; '中文测试'];$json = Helper::jsonFormat($array);echo '&lt;/pre&gt;';print_r($json); 转自博客 原文 还有一种方法就是使用 json_encode() 函数,它再不断的添加参数来丰富它的功能,上面同样的操作可以简化成这样:12345678910&lt;?php$array = [ 'key1' =&gt; 123, 'key2' =&gt; 'abc', 'key3' =&gt; '中文测试'];$json = json_encode($$array, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES | JSON_NUMERIC_CHECK);echo '&lt;/pre&gt;';print_r($json); 想知道 json_encode更多的参数可以看文档 文档地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-Next-Title]]></title>
      <url>%2F2017%2F04%2F07%2Fhexo-next-title%2F</url>
      <content type="text"><![CDATA[hexo-next 是一个很完美的组合,这次我碰到的问题就是 title 不能显示&lt;hello-world/&gt; 这样的文本 比如你的网站配置文件_config.yml的内容是这样的123456# Sitetitle: &lt;hello-world/&gt;subtitle: 代码改变世界description: heyauthor: GPFlanguage: zh-Hans 如果这么写的话是根本不会正常输出出来的,于是我转换成实体格式12# Sitetitle: &amp;lt;hello-world/&amp;gt; 这里出现的问题是左边的不能正常显示出 &lt;而右边的可以正常显示&gt;,发现 title: 后不能出现&amp;特殊字符,看的比较匆暂时没理解是什么原因,但是这样写对于自己的感官上也不怎么好,于是就看了下模板的代码,原来是 swig 的模板引擎,虽然我擅长的是 php,但是我也是用过模板引擎的人! 这样就可以做很多事情了,再说 symfony 也是用的 swig. 于是乎进行一下操作: 打开@app/themes/next/layout/_partials/header.swig,找到 class=&quot;site-title&quot;,把这个标签改成这样:1&lt;span class=&quot;site-title&quot;&gt;&#123;&#123; config.title | escape &#125;&#125;&lt;/span&gt; 这样就行了 注意,如果是本地修改的 _config.yml文件需要重启 hexo server 才能显示效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deploymentadd git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Laravel-Auth]]></title>
      <url>%2F2017%2F04%2F01%2Flaravel-auth%2F</url>
      <content type="text"><![CDATA[原文出处 auth提供了很方便的登录体系，已经做到了开箱即用的便捷，但是任何方便的工具都是需要花费学习成本的，了解的过程就由些痛苦了：） 本着松鼠过冬的原则，自己是能写一点是一点，以后忘记的话也能立即捡起来 安装auth系统1php artisan make:auth 默认会安装基于user表的登录验证，现在我们需要增加另一个表的登录验证（比如后台的数据表）编辑config/auth.php,我们需要指定的就是guards和providers这两个数组，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?phpreturn [ /* |-------------------------------------------------------------------------- | Authentication Defaults |-------------------------------------------------------------------------- | | This option controls the default authentication &quot;guard&quot; and password | reset options for your application. You may change these defaults | as required, but they&apos;re a perfect start for most applications. | */ &apos;defaults&apos; =&gt; [ &apos;guard&apos; =&gt; &apos;web&apos;, &apos;passwords&apos; =&gt; &apos;users&apos;, ], /* |-------------------------------------------------------------------------- | Authentication Guards |-------------------------------------------------------------------------- | | Next, you may define every authentication guard for your application. | Of course, a great default configuration has been defined for you | here which uses session storage and the Eloquent user provider. | | All authentication drivers have a user provider. This defines how the | users are actually retrieved out of your database or other storage | mechanisms used by this application to persist your user&apos;s data. | | Supported: &quot;session&quot;, &quot;token&quot; | */ &apos;guards&apos; =&gt; [ //......// //这里新加的一组配置，provider的配置在下面有 &apos;admin&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;session&apos;, &apos;provider&apos; =&gt; &apos;admin&apos;, ], //.......// ], /* |-------------------------------------------------------------------------- | User Providers |-------------------------------------------------------------------------- | | All authentication drivers have a user provider. This defines how the | users are actually retrieved out of your database or other storage | mechanisms used by this application to persist your user&apos;s data. | | If you have multiple user tables or models you may configure multiple | sources which represent each model / table. These sources may then | be assigned to any extra authentication guards you have defined. | | Supported: &quot;database&quot;, &quot;eloquent&quot; | */ &apos;providers&apos; =&gt; [ //.............// //这就是新加的配置，我们指定了 Admin 这个模型 &apos;admin&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;eloquent&apos;, &apos;model&apos; =&gt; App\Models\Admin::class, ], //.............// ], /* |-------------------------------------------------------------------------- | Resetting Passwords |-------------------------------------------------------------------------- | | You may specify multiple password reset configurations if you have more | than one user table or model in the application and you want to have | separate password reset settings based on the specific user types. | | The expire time is the number of minutes that the reset token should be | considered valid. This security feature keeps tokens short-lived so | they have less time to be guessed. You may change this as needed. | */ &apos;passwords&apos; =&gt; [ &apos;users&apos; =&gt; [ &apos;provider&apos; =&gt; &apos;users&apos;, &apos;table&apos; =&gt; &apos;password_resets&apos;, &apos;expire&apos; =&gt; 60, ], ],]; 新建模型 App/Models/Admin1php artisan make:model Models/Admin -m 编辑模型123456789101112131415161718192021222324&lt;?phpnamespace App\Models;use Illuminate\Notifications\Notifiable;use Illuminate\Foundation\Auth\User as Authenticatable;//这里继承了auth的验证模型 其实和User的一样class Admin extends Authenticatable&#123; use Notifiable; protected $table=&apos;admin&apos;; public $timestamps = false; protected $primaryKey = &apos;id&apos;; protected $fillable = [ &apos;name&apos;, &apos;email&apos;, &apos;password&apos;, ]; protected $hidden = [ &apos;password&apos;, &apos;remember_token&apos;, ];&#125; 编辑数据迁移文件 database/migrations/xxxx_admin_table.php123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpuse Illuminate\Support\Facades\Schema;use Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;/*** Migration auto-generated by Sequel Pro Laravel Export* @see https://github.com/cviebrock/sequel-pro-laravel-export*/class CreateAdminTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::create(&apos;admin&apos;, function (Blueprint $table) &#123; $table-&gt;increments(&apos;id&apos;); $table-&gt;string(&apos;name&apos;); $table-&gt;string(&apos;email&apos;)-&gt;unique(); $table-&gt;string(&apos;password&apos;); $table-&gt;rememberToken(); $table-&gt;timestamps(); &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::dropIfExists(&apos;admin&apos;); &#125;&#125; 编辑数据填充文件，这一步懒得折腾可以直接手动添加数据 编辑 Faker 这个数据模拟的类 database/factories/ModelFactory.php 添加一下内容,是根据我们刚创建的Models/Admin模型而填充的内容 123456789101112//other code...........$factory-&gt;define(App\Models\Admin::class, function (Faker\Generator $faker) &#123; static $password; return [ &apos;name&apos; =&gt; $faker-&gt;name, &apos;email&apos; =&gt; $faker-&gt;safeEmail, &apos;password&apos; =&gt; $password ?: $password = bcrypt(&apos;secret&apos;), &apos;remember_token&apos; =&gt; str_random(10), ];&#125;); 编辑database/seeds/AdminTableSeeder.php123456789101112131415161718&lt;?phpuse Illuminate\Database\Seeder;class AdminsTableSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; factory(&apos;App\Models\Admin&apos;,3)-&gt;create([ &apos;password&apos; =&gt; bcrypt(&apos;123456&apos;) ]); &#125;&#125; 将自动填充文件写入总的Seeder文件当中123456789101112131415//in database/seeds/DatabaseSeeder.phpclass DatabaseSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; // $this-&gt;call(UsersTableSeeder::class); $this-&gt;call(AdminsTableSeeder::class); &#125;&#125; 执行数据库迁移操作 --seed 顺便执行数据填充操作1php artisan migrate --seed 好了,到这一步数据库就已经有了admin 这个表,而且里面出现了三条测试数据,我们接着看看控制器里是怎么操作的: 首先创建相应的控制器:12php artisan make:controller Admin/LoginControllerphp artisan make:controller Admin/HomeController Admin/LoginController.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpnamespace App\Http\Controllers\Admin;use App\Http\Controllers\Controller;use Illuminate\Http\Request;use Illuminate\Foundation\Auth\AuthenticatesUsers;class LoginController extends Controller&#123; /* |-------------------------------------------------------------------------- | Login Controller |-------------------------------------------------------------------------- | | This controller handles authenticating users for the application and | redirecting them to your home screen. The controller uses a trait | to conveniently provide its functionality to your applications. | */ use AuthenticatesUsers; /** * Where to redirect users after login / registration. * * @var string */ protected $redirectTo = &apos;/admin/dash&apos;; protected $username; /** * Create a new controller instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware(&apos;guest:admin&apos;, [&apos;except&apos; =&gt; &apos;logout&apos;]); $this-&gt;username = config(&apos;admin.global.username&apos;); &#125; /** * 重写登录视图页面 */ public function showLoginForm() &#123; return view(&apos;admin.login.index&apos;); &#125; /** * 自定义认证驱动 */ protected function guard() &#123; return auth()-&gt;guard(&apos;admin&apos;); &#125; /** * 重写方法，让验证字段改成name 而不是默认的email */// protected function username()&#123;// return &apos;name&apos;;// &#125;&#125; Admin/HomeController.php1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\Http\Controllers\Admin;use Illuminate\Http\Request;use App\Http\Requests;use App\Http\Controllers\Controller;use Auth;class HomeController extends Controller&#123; /** * Create a new controller instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware(&apos;auth.admin:admin&apos;); &#125; /** * Show the application dashboard. * * @return \Illuminate\Http\Response */ public function index() &#123; dd(&apos;后台首页，当前用户名：&apos;.auth(&apos;admin&apos;)-&gt;user()-&gt;name); &#125;&#125; 因为在LoginController中也使用了 guest这个中间件,而系统自带的那个也使用了它,因此需要在这个中间件里面做一下区分 编辑 app/Http/Kernel.php12345678910public function handle($request, Closure $next, $guard = null) &#123; if (Auth::guard($guard)-&gt;check()) &#123;// return redirect(&apos;/home&apos;); $url = $guard ? &apos;admin/dash&apos;:&apos;/home&apos;; return redirect($url); &#125; return $next($request); &#125; 而在 Admin/HomeController这里,因为验证需要登录才能进入,我们给他也加了一个验证中间件 AdminAuthMiddlware1php artisan make:middleware AdminAuthMiddlware 编辑AdminAuthMiddlware123456789101112131415161718192021222324252627&lt;?phpnamespace App\Http\Middleware;use Closure;use Illuminate\Support\Facades\Auth;class AdminAuthMiddleware&#123; /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next,$guard = null) &#123; //判定是否已经登录，如果没由登录则跳转到登录界面 if (Auth::guard($guard)-&gt;guest()) &#123; if ($request-&gt;ajax() || $request-&gt;wantsJson()) &#123; return response(&apos;Unauthorized.&apos;, 401); &#125; else &#123; return redirect()-&gt;guest(&apos;admin/login&apos;); &#125; &#125; return $next($request); &#125;&#125; 在路由文件里添加对应的路由12345678910// in routes/web.php//后台登录部分Route::group([&apos;prefix&apos; =&gt; &apos;admin&apos;,&apos;namespace&apos; =&gt; &apos;Admin&apos;],function ($router)&#123; $router-&gt;get(&apos;login&apos;, &apos;LoginController@showLoginForm&apos;)-&gt;name(&apos;admin.login&apos;); $router-&gt;post(&apos;login&apos;, &apos;LoginController@login&apos;); $router-&gt;any(&apos;logout&apos;, &apos;LoginController@logout&apos;); $router-&gt;get(&apos;dash&apos;, &apos;HomeController@index&apos;);&#125;); 做到这一步其实就已经算是完成了,剩下的视图部分可以按照resources/views/auth中的内容创建一个resource/views/admin目录,resource/views/admin/login/index.blade.php就是后台登录界面,注意这里的表单提交地址要按刚才路由文件中写的指向后台的登录控制器中,route(&#39;admin.login&#39;) 这一段是我按照原文操作一遍后自己写了一遍,算是了解了auth的大致运行过程,其后就是翻一下源码进行解析了,为了controller中的代码好看一点其后的运作并不少,但是解耦做的非常不错]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Laravel-Error-Log]]></title>
      <url>%2F2017%2F04%2F01%2Flaravel-error-log%2F</url>
      <content type="text"><![CDATA[laravel有一套方便的错误采集和报错机制，如果是开发api的时候我们不需要报错页面显示的那么详细，只想返回一些错误信息，而不用把所有的响应信息都返回到 controller 当中才行 之前的步骤是： 1router-&gt;beforeMiddlware-&gt;controller-&gt;someService-&gt;controller-&gt;afterMiddleware-&gt; yourInfo 我们想在这任何一个环节报错的时候都能停止掉运行流程直接返回信息 就需要接下来要说的一个类 Exception。 我们自定义的错误文件也是都放在 app/Exception 当中，比如我自定义一个 TestException1234567891011&lt;?phpnamespace App\Exceptions;class TestException extends \Exception&#123; public function responseJson()&#123; $msg = config('errors.user.'.$this-&gt;getMessage()); return \ApiResponse::error($msg); &#125;&#125; 这里面我自定义了一个responseJson()的方法，为了处理我返回的信息 然后我在同文件夹下的 Handler.php 我们返回的错误在这里集中处理 这里的两个方法report()和render() report()会优先执行，用于将错误发送到第三方服务中去，render()就是最终要返回的结果，我们的目标就是这个函数1234567891011121314/** * Render an exception into an HTTP response. * * @param \Illuminate\Http\Request $request * @param \Exception $e * @return \Illuminate\Http\Response */ public function render($request, Exception $e) &#123; if($e instanceof TestException)&#123; return $e-&gt;responseJson(); &#125; return parent::render($request, $e); &#125; 这里用了instanceof进行比较，如果是来自TestException的报错就会执行我们刚才自定义好的方法，内容当然也可以随便定义了 怎么使用呢？ 只需要在控制器中任何你需要报错的地方1throw new TestException(&apos;system_busy&apos;); 括号内的内容可以通过它的getMessage()方法获得 参考文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pip]]></title>
      <url>%2F2017%2F04%2F01%2Fpip%2F</url>
      <content type="text"><![CDATA[pip语言环境配置出错root@ubuntu:~# locale12345678910111213141516locale: Cannot set LC_ALL to default locale: No such file or directoryLANG=en_US.UTF-8LANGUAGE=LC_CTYPE=&quot;en_US.UTF-8&quot;LC_NUMERIC=zh_CN.UTF-8LC_TIME=zh_CN.UTF-8LC_COLLATE=&quot;en_US.UTF-8&quot;LC_MONETARY=zh_CN.UTF-8LC_MESSAGES=&quot;en_US.UTF-8&quot;LC_PAPER=zh_CN.UTF-8LC_NAME=zh_CN.UTF-8LC_ADDRESS=zh_CN.UTF-8LC_TELEPHONE=zh_CN.UTF-8LC_MEASUREMENT=zh_CN.UTF-8LC_IDENTIFICATION=zh_CN.UTF-8LC_ALL= root@ubuntu:~# export LC_ALL=C12345678910111213141516root@ubuntu:~# localeLANG=en_US.UTF-8LANGUAGE=LC_CTYPE=&quot;C&quot;LC_NUMERIC=&quot;C&quot;LC_TIME=&quot;C&quot;LC_COLLATE=&quot;C&quot;LC_MONETARY=&quot;C&quot;LC_MESSAGES=&quot;C&quot;LC_PAPER=&quot;C&quot;LC_NAME=&quot;C&quot;LC_ADDRESS=&quot;C&quot;LC_TELEPHONE=&quot;C&quot;LC_MEASUREMENT=&quot;C&quot;LC_IDENTIFICATION=&quot;C&quot;LC_ALL=C DONE! 原文[另一个参]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Brew权限问题]]></title>
      <url>%2F2017%2F03%2F31%2Fbrew-install%2F</url>
      <content type="text"><![CDATA[在一个新的环境下安装 homebrew 新装系统时难免会遇到权限的问题，在老版系统下（osx 10.10.* )需要一些权限设置，方式如下: 12345sudo chown -R $(whoami):admin /usr/localsudo chown -R $(whoami) /Library/Caches/Homebrewbrew doctorbrew prunebrew update]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-Next 的一些配置]]></title>
      <url>%2F2017%2F03%2F30%2Fwebconfig%2F</url>
      <content type="text"><![CDATA[目前对 hexo-next 添加的功能 搜索1$ npm install hexo-generator-searchdb --save 站点配置文件12345search: path: search.xml field: post format: html limit: 10000 next主题配置文件123# Local searchlocal_search: enable: true 生成 sitemap12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 支持 hexo deploy1$ npm install hexo-deployer-git --save 将 next 主题的依赖包由 bootcdn 提供在主题配置文件中1234567891011121314151617181920212223242526272829303132333435363738394041424344vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: //cdn.bootcss.com/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: //cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: //cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: //cdn.bootcss.com/velocity/1.2.1/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: //cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: //cdn.bootcss.com/UAParser.js/0.7.9/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: //cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: //cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js 谷歌字体主题配置文件，换成国内的一个cdn123456789101112131415161718192021222324252627282930313233343536373839404142434445# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: //fonts.css.network/icon?family=Lato:300,300italic,400,400italic,700,700italic&amp;subset=latin,latin-ext # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: 添加rss1$ npm install hexo-generator-feed --save 主题配置文件1rss: /atom.xml 代码中使用js使用 raw 标签包裹住就能让内容内容略过 markdown 解析12345&#123;% raw %&#125;&lt;script&gt; alert(12312)&lt;/script&gt;&#123;% endraw %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[震惊！彩票的随机机制竟然是这样的...]]></title>
      <url>%2F2017%2F03%2F24%2Fcaipiao%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728&lt;?php$lanList = [];$hongList = [];for($i=1;$i&lt;34;$i++)&#123; if($i&lt;16)&#123; array_push($lanList,$i); &#125; array_push($hongList, $i);&#125;$res = [ 'red' =&gt; [], 'blue' =&gt; []];for($i=0;$i&lt;=6;$i++)&#123; if($i==0)&#123; $res['blue'] = array_slice($lanList, mt_rand( 0,count($lanList)-1) ,1); &#125; $res['red'][] = array_splice($hongList, mt_rand( 0,count($hongList)-1),1)[0];&#125;sort($res['red']);echo 'red:'.implode(',',$res['red']).' blue:'.implode(',',$res['blue']).PHP_EOL;?&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Symfony-路由]]></title>
      <url>%2F2017%2F03%2F23%2Fsymfony-router%2F</url>
      <content type="text"><![CDATA[laravel的路由模块就是从这里封装起来的，咱们先了解下symfony的路由机制 使用注释定义一个路由symfony 的强大之处在于代码中的注释都参与到程序运行当中，这样强制的规范了注释排版，比如123456789101112class LuckyController extends Controller&#123; /** * @Route("/lucky/number") */ public function numberAction() &#123; $numbers = mt_rand(1,999); return new Response($numbers); &#125;&#125; 当输入 http://domain/app_dev.php/lucky/number 将会返回方法中的随机数 使用配置文件定义一个路由推荐这种写法，方便他人维护在 @app/config/routing.yml文件中，定义一个blog_show路由123blog_show: path: /blog/&#123;slug&#125; defaults: &#123; _controller: AppBundle:Lucky:show ,slug:2333&#125; 这里还有 {slug} 奇怪的写法，这代表着路由中传入 slug的自定义参数，从laravel过来的同学一定不会陌生 defaults 下指定了该路由指向哪个控制器，同时 slug 也有了默认值，在控制器中就是这样写：1234567891011// src: @src/AppBundle/LuckyControllerpublic function showAction($slug)&#123; $str = &apos;this is blog-&apos;.$slug; return new Response($str);&#125;#注释的写法就是/** * @Route(&quot;/blog/&#123;slug&#125;&quot;, defaults=&#123;&quot;slug&quot; = 1&#125;) */ 高级路由示例12345678910111213141516171819202122232425# in Controller/** * @Route( * "/articles/&#123;_locale&#125;/&#123;year&#125;/&#123;title&#125;.&#123;_format&#125;", * defaults=&#123;"_format": "html"&#125;, * requirements=&#123; * "_locale": "en|fr", * "_format": "html|rss", * "year": "\d+" * &#125; * ) */public function showAction($_locale, $year, $title)&#123;&#125;# in yaml# app/config/routing.ymlarticle_show: path: /articles/&#123;_locale&#125;/&#123;year&#125;/&#123;title&#125;.&#123;_format&#125; defaults: &#123; _controller: AppBundle:Article:show, _format: html &#125; requirements: _locale: en|fr _format: html|rss year: \d+ 这里对参数进行了正则筛选，如果不复合条件的也将报 404 错误 新出现的 requirements 部分就是对指定的参数筛分，使用的是正则的格式 在程序中生成路由和解析路由路由在系统中是双向映射，既能生成带参数的路由，又能反向解析成运行的函数123456789101112$params = $this-&gt;get('router')-&gt;match('/blog/my-blog-post');dump($params);// array(// 'slug' =&gt; 'my-blog-post',// '_controller' =&gt; 'AppBundle:Blog:show',// )$uri = $this-&gt;get('router')-&gt;generate('blog_show', array( 'slug' =&gt; 'my-blog-post'));dump($uri);// /blog/my-blog-post 在 generate 方法中，如果添加了路由中没设置的参数比如123456$uri = $this-&gt;get('router')-&gt;generate('blog_show', array( 'slug' =&gt; 'my-blog-post', 'author' =&gt; 'jack', 'type' =&gt; 'markdown'));// /blog/my-blog-post?author=jack&amp;type=markdown 会以 Query Strings 的形式添加到地址中 现在生成的是相对路径，如果是全路径的话需要加一个参数12345$uri = $this-&gt;get('router')-&gt;generate('blog_show', array( 'slug' =&gt; 'my-blog-post', 'author' =&gt; 'jack', 'type' =&gt; 'markdown'),UrlGenerator::ABSOLUTE_URL); UrlGenerator::ABSOLUTE_URL 这个参数也可以替换成 0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo构建博客]]></title>
      <url>%2F2017%2F03%2F22%2Finstall%2F</url>
      <content type="text"><![CDATA[本地搭建 hexo 构建hexo需要在本地安装node.js1brew install node 当前版本的node版本12node -vv7.7.3 全局安装 hexo1npm install -g hexo 国外镜像慢的话可以搜索找下淘宝的 cnmp 创建一个目录并且安装 hexo 1234mkdir hexo_blogcd hexo_bloghexo initnpm install 新建一个文章 1hexo new &quot;your-first-page&quot; 文件在 hexo_blog/source/_post/下进行编辑啊 然后就是生成静态文件12hexo generatehexo server 这时就可以访问 http://localhost:4000 来查看效果，这个时候hexo已经搭建成功了，但是我们需要外网能够访问，这就用到了今天的另一个主角：github page 将 hexo 放到github上 需要一个github账号，具体申请登录看 https://github.com 上的引导就行 创建一个新的 repository 名字格式是固定的，比如我的账户名是 gaopengfei123123 那么这个库的名字就是 gaopengfei123123.github.io 不能改的哦 为了可以直接提交远程文件需要添加 ssh 密匙本地操作123ssh-keygen -t rsa -C &quot;5173180@qq.com” -f ~/.ssh/github-rsacat ~/.ssh/github_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3K5mcQxH9mu1cUIu2+byK1iksES/7Tnfh23l2U6y1fOKO4XFhPLdAoMQdePnI51PAF4faXxucOYsiDb6IpQimWPwORKTkEkcglOiZ414eZZ829gY98RAldbFQeT2L9A0l2APfcan1fH4HvrCmZKlY8CNDQDDfRzXub9hfSX3LS5mQlgS9PHiFoXRfrS10hYweere9Cb9OFiEdkdCfMKUBr25ImGahqbaHxE8Vb3QzMT8Q5PBITaqFwYnIE/z6HU6Lok92EZ/uVG81SMJb9A5SQCZdsjWmyDqXj1eDZ1A2YyUlA+/6QM7JjCrLoZAAtZHTH+ylNAG79w9WG0eYAuL GaoPengFeiFiy@github.com 把这一段完整的复制到 https://github.com/settings/keys 这个地址下，添加一条新的ssh-key，这样就能免登录提交版本文件 现在编辑本地hexo根目录下的站点配置文件 path/to/hexo_blog/_config.yml查找字段 deploy 编辑成这样123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:gaopengfei123123/gaopengfei123123.github.io.git branch: master 设置好后，就将本地生成的静态文件发到github上1234hexo deploy#如果报错就可能是少个插件npm install hexo-deployer-git 进入 你的版本库地址/settings 比如我的就是 https://github.com/gaopengfei123123/gaopengfei123123.github.io/settings找到 github pages 设置块按照你的需求调整，这时访问 https://gaopengfei123123.github.io就能访问 hexo 上传的内容了 绑定一个自己的域名，通过它来访问github pages 我用的是阿里云的万网来举例 首先进入到万网云解析的页面 123记录类型：A主机记录：blog记录值：xxx.xxx.xxx #这里需要 ping -c 3 https://gaopengfei123123.github.io 获取ip地址 然后返回到 你的版本库地址/settings 这里，将 Custom domain 设置成你刚才解析的名字，与此同时在github上版本的根目录下添加一个文件 CNAME 内容是 12#in CNAMEblog.justwe.site 这时再返回settings中就能看的 github pages 部分的域名绑定的是你的域名了，到这里博客算是搭建成功了 hexo官网 hexo的next模版官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo和github-Pages发布博客]]></title>
      <url>%2F2017%2F03%2F22%2Fhexo-blog%2F</url>
      <content type="text"><![CDATA[本地搭建 hexo 构建hexo需要在本地安装node.js1brew install node 当前版本的node版本12node -vv7.7.3 全局安装 hexo1npm install -g hexo 国外镜像慢的话可以搜索找下淘宝的 cnmp 创建一个目录并且安装 hexo 1234mkdir hexo_blogcd hexo_bloghexo initnpm install 新建一个文章 1hexo new &quot;your-first-page&quot; 文件在 hexo_blog/source/_post/下进行编辑啊 然后就是生成静态文件12hexo generatehexo server 这时就可以访问 http://localhost:4000 来查看效果，这个时候hexo已经搭建成功了，但是我们需要外网能够访问，这就用到了今天的另一个主角：github page 将 hexo 放到github上 需要一个github账号，具体申请登录看 https://github.com 上的引导就行 创建一个新的 repository 名字格式是固定的，比如我的账户名是 gaopengfei123123 那么这个库的名字就是 gaopengfei123123.github.io 不能改的哦 为了可以直接提交远程文件需要添加 ssh 密匙本地操作123ssh-keygen -t rsa -C &quot;5173180@qq.com” -f ~/.ssh/github-rsacat ~/.ssh/github_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3K5mcQxH9mu1cUIu2+byK1iksES/7Tnfh23l2U6y1fOKO4XFhPLdAoMQdePnI51PAF4faXxucOYsiDb6IpQimWPwORKTkEkcglOiZ414eZZ829gY98RAldbFQeT2L9A0l2APfcan1fH4HvrCmZKlY8CNDQDDfRzXub9hfSX3LS5mQlgS9PHiFoXRfrS10hYweere9Cb9OFiEdkdCfMKUBr25ImGahqbaHxE8Vb3QzMT8Q5PBITaqFwYnIE/z6HU6Lok92EZ/uVG81SMJb9A5SQCZdsjWmyDqXj1eDZ1A2YyUlA+/6QM7JjCrLoZAAtZHTH+ylNAG79w9WG0eYAuL GaoPengFeiFiy@github.com 把这一段完整的复制到 https://github.com/settings/keys 这个地址下，添加一条新的ssh-key，这样就能免登录提交版本文件 现在编辑本地hexo根目录下的站点配置文件 path/to/hexo_blog/_config.yml查找字段 deploy 编辑成这样123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:gaopengfei123123/gaopengfei123123.github.io.git branch: master 设置好后，就将本地生成的静态文件发到github上1234hexo deploy#如果报错就可能是少个插件npm install hexo-deployer-git 进入 你的版本库地址/settings 比如我的就是 https://github.com/gaopengfei123123/gaopengfei123123.github.io/settings找到 github pages 设置块按照你的需求调整，这时访问 https://gaopengfei123123.github.io就能访问 hexo 上传的内容了 绑定一个自己的域名，通过它来访问github pages 我用的是阿里云的万网来举例 首先进入到万网云解析的页面 123记录类型：A主机记录：blog记录值：xxx.xxx.xxx #这里需要 ping -c 3 https://gaopengfei123123.github.io 获取ip地址 然后返回到 你的版本库地址/settings 这里，将 Custom domain 设置成你刚才解析的名字，与此同时在github上版本的根目录下添加一个文件 CNAME 内容是 12#in CNAMEblog.justwe.site 这时再返回settings中就能看的 github pages 部分的域名绑定的是你的域名了，到这里博客算是搭建成功了 hexo官网 hexo的next模版官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Laravel事务]]></title>
      <url>%2F2017%2F03%2F21%2Flaravel-trancate%2F</url>
      <content type="text"><![CDATA[laravel 事务的使用会忽略的地方 laravel开启事物有两种方法： 一种是闭包12345DB::transaction(function()&#123; DB::table('user')-&gt;insert(['username'=&gt;'xxx']); DB::table('comment')-&gt;insert(['content'=&gt;'zzz']);&#125;); 当闭包内发生错误就会自动回滚 另一种比较灵活1234567DB::beginTransaction();//这里执行一些数据库操作，包括 eloquent 的if(condition)&#123; DB::commit();&#125;else&#123; DB::rollback();&#125; 但是我有一次发现两种方法的事物都不起作用，在想掉几根头发之后想到了可能是不同数据库的原因！ 如果你采用的是分库存储不同逻辑的方式，执行事物的时候一定要加上连接信息 上面的就要这样写了：1234567DB::connection('admin_database')-&gt;beginTransaction();//这里执行一些数据库操作，包括 eloquent 的if(condition)&#123; DB::connection('admin_database')-&gt;commit();&#125;else&#123; DB::connection('admin_database')-&gt;rollback();&#125; 如果逻辑中的 eloquent 连接的数据库和开启事物的数据库不是一个库一样是不起作用的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go语言了解(3) 工作流程]]></title>
      <url>%2F2017%2F03%2F19%2Fgo-workflow%2F</url>
      <content type="text"><![CDATA[本章将的关键字有 defer,panic,recover,main,init,import defergo语言中有一个不错的设计，就是defer。尤其是调用资源时需要打开和关闭两个选项的时候就能凸显出来 它的作用是将指定的语句在函数结束时执行，没明白？咱们举个例子啊12345main () &#123; for i :=0;i &lt; 5 ; i++&#123; defer fmt.Println(&apos;输出：&apos;,i) &#125;&#125; 输出的结果不是01234而是相反的43210，这样就明白它的功能了吧？再举一个常用的例子12345678910111213141516func OpenFile() bool&#123; file.Open(&quot;file/path&quot;) if condition1 &#123; file.Close() return false &#125; if condition2 &#123; file.Close() return false &#125; file.Close() return true&#125; 在别的语言中我们打开文件的逻辑大体是这样的，你会发现打开一个文件需要在每个条件结束的时候去再声明关闭它，这显得语句很臃肿，而且如果我们哪个地方给忘了很可能就造成内存泄漏，但在go中它变的很简单123456789101112func OpenFile() bool&#123; file.Open(&quot;file/path&quot;) defer file.Close() if condition1 &#123; return false &#125; if condition2 &#123; return false &#125; return true&#125; 当函数按照从上往下执行的时，执行到最下面准备结束这个函数，go将会再从下往上执行一下标明的defer的命令 panic 和 recover这两个函数放在一起说，因为他们的作用是相对的 panic会中断控制流程的命令，是go语言的报错机制，一旦执行panic那么当前进程就会终止，但是我们刚才讲的defer命令还是会执行，等defer执行完了就会结束这个goroutine recover会恢复panic造成的中断，从而让进程继续进行，而且recover只能在defer中执行，同时在正常进程中执行的recover()将返回false 由于没想到十分合适的场景就先不举例了:p main 和 init这两个也能放在一起说 main只能有一个，而且只能在main package当中，而init()每个包里都可以有多个，也可以没有，为了方便维护，建议包里不超过一个init 这两个都是系统自动执行的函数，不用在文件中执行 在平时构建项目的时候我们会导入很多的包(package)，多个包中肯定会有重复的，但是不用担心，重复导入的包只会生效一次 从main package导入外界的包会优先执行外界包的init和变量初始化，如果外界的包也导入了第三方的包，那么优先执行外界包的第三方包的初始化，再执行外界包的初始化最后执行mian package的初始化 这也很好理解，我们引入包的时候这个包肯定要是完整的形态，为了让他完整就要优先满足它的条件，这也层层向外翻到了最边缘初始化完毕再一层层的向内完成初始化 importimport有几个很方便的特性比如:12345import( f &quot;fmt&quot; . &quot;fmt&quot; _ &quot;fmt&quot; ) 这三种写法 第一种是引入别名 fmt.Println 就可以简写成 f.Println 第二种更厉害了，直接就可以把包名给省去 可以当成自己的方法写成 Println 第三种其实是引入该包，不直接使用包里的函数，而是调用了该包的init函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go语言了解(2)--切片]]></title>
      <url>%2F2017%2F03%2F14%2Fgo-slice%2F</url>
      <content type="text"><![CDATA[切片是一种复合类型，可以是数组也可以是字符串 接下来是一个简单切片使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport &quot;fmt&quot;func slienceInfo(slience []int, str string) &#123; fmt.Println(&quot;\n&quot;, str, &quot;的长度是:&quot;, len(slience)) fmt.Println(str, &quot;的大小是:&quot;, cap(slience), &quot;\n&quot;) for i, v := range slience &#123; fmt.Println(str, &quot;下标&quot;, i, &quot;是&quot;, v) &#125;&#125;func main() &#123; //定义一个数组 var arr [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; //打印一下 for _, v := range arr &#123; fmt.Println(&quot;arr element is&quot;, v) &#125; //获取数组 arr 从0 到下标为5（不包含下标5) 的一个切片 mySlice := arr[:5] slienceInfo(mySlice, &quot;mySlice&quot;) //声明一个包含5个元素的数组切片 此时会创建一个匿名数组 elementSlience := []int&#123;1, 2, 2, 3, 4&#125; slienceInfo(elementSlience, &quot;elementSlience&quot;) //声明一个默认值0，长度5，预留长度10的切片 emptySlience := make([]int, 5, 10) slienceInfo(emptySlience, &quot;emptySlience&quot;) //向切片中添加元素 这时数组的长度和占用内存是一致的 emptySlience = append(emptySlience, 1, 2, 3, 4, 5) //如果超过分配的内存，会动态分配足够的内存空间 // emptySlience = append(emptySlience, 1, 2, 3, 4, 5) slienceInfo(emptySlience, &quot;emptySlience2&quot;) mySlice = append(mySlice, emptySlience...) slienceInfo(mySlice, &quot;mySlice2&quot;) //内容复制 slice1 := []int&#123;1, 2, 3, 4, 5&#125; slice2 := []int&#123;6, 6, 6&#125; //从slice2复制前三个元素到slice1当中，不同长度的按照较小的来 copy(slice1, slice2) slienceInfo(slice2, &quot;slice&quot;)&#125; 从示例中可以看出切片是动态分配内存大小的，我总结了一下几条规律 当切片源于一个已有的数组时，切片长度取决于截取的长度，切片分配的内存大小和源数组占用的内存大小一样 当直接生成一个切片数组时，可以定义长度和预留内存 当切片超出分配内存大小时，系统将会再分配一块足够大的内存 通常如果直到业务中明确的数组极限长度的时候，就分配足够大的内存，以缓解系统不断计算分配内存的压力，典型的空间换时间]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git标签操作]]></title>
      <url>%2F2017%2F03%2F13%2Fgit-tag%2F</url>
      <content type="text"><![CDATA[列出所有标签1git tag 添加标签(同时生成独立的版本库)12345# 给当前commit打标签git tag -a v0.0.1 -m &apos;第一次添加标签&apos;# 给指定的commit打标签，需要commit的headgit tag -a v0.0.1 0ed1dd07d324cb5aece243a95312187955619fcf 不加 -a 参数相当于是一个commit的引用 将标签推送到远程库1234# 推送本地所有标签git push origin --tags# 推送指定标签git push origin v0.0.1 跳转到指定标签1git checkout v0.0.1 和跳转到branch操作一样，但是因为是独立的版本库上，你在独立标签中的git branch和在主线中包含的branch显示的是不同的，独立版本库和分支的性质是不一样的 删除指定标签1git tag -d v0.0.1 删除远程分支1git push origin -d tag &lt;tagname&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Redis—geo Api实现搜索附近的人，自己写的一个composer包]]></title>
      <url>%2F2017%2F03%2F11%2Fcomposer-redis-lbs%2F</url>
      <content type="text"><![CDATA[git地址 安装需要使用composer，安装composer, composer中国镜像 如果是应用在项目当中的话找到根目录，需要和 composer.json同级 1composer require gaopengfei/redis_lbs #基本操作 初始化12require_once __DIR__.'/vendor/autoload.php';$lbs = new \LBS\Services\LBSService(); 添加123456789101112131415161718192021222324252627282930313233343536373839404142434445$add_params = [ [ 'name' =&gt; 'yabao_road', 'long' =&gt; '116.43620200729366', 'lat' =&gt; '39.916880160714435' ], [ 'name' =&gt; 'jianguomen', 'long' =&gt; '116.4356870231628', 'lat' =&gt; '39.908560377800676' ], [ 'name' =&gt; 'chaoyangmen', 'long' =&gt; '116.4345336732864', 'lat' =&gt; '39.924466658329585' ], [ 'name' =&gt; 'galaxy_soho', 'long' =&gt; '116.4335788068771', 'lat' =&gt; '39.921372916981106' ], [ 'name' =&gt; 'cofco', 'long' =&gt; '116.43564410781856', 'lat' =&gt; '39.92024564137184' ], [ 'name' =&gt; 'fesco', 'long' =&gt; '116.435182767868', 'lat' =&gt; '39.91811857809279' ],];/** * 在集合中新加一个坐标 * @param array $params * 结构是 ['name'=&gt;'xxx','long'=&gt;'1.2321','lat'=&gt;'1.3112']或者[['name'=&gt;'xxx','long'=&gt;'1.2321','lat'=&gt;'1.3112']] * @param null $key * @return int */$res = $lbs-&gt;add($add_params);返回int 6 删除1234567891011121314/** * 删除集合中指定元素 * @param $name * @param null $key 默认存在集合，可以指定 * @return int */$res = $lbs-&gt;del('gao1');返回int 0 或 1如果是指定的集合名就$res = $lbs-&gt;del('gao1','set-name'); 用坐标查询附近的单位123456789101112131415161718192021222324252627282930/** * 查询范围内元素，如果不转 key就用默认的 * @param $long 经度 * @param $lat 纬度 * @param $radius 范围 * @param $unit 单位 (仅支持 m,km,ft,mi) * @param null $key 集合名 * @return mixed */$search = $lbs-&gt;search('116.435182767868','39.91811857809279',500,'m');返回数组array:4 [▼ 0 =&gt; array:2 [▼ "name" =&gt; "fesco" "dist" =&gt; "0.1250" ] 1 =&gt; array:2 [▼ "name" =&gt; "yabao_road" "dist" =&gt; "162.8454" ] 2 =&gt; array:2 [▼ "name" =&gt; "cofco" "dist" =&gt; "239.7758" ] 3 =&gt; array:2 [▼ "name" =&gt; "galaxy_soho" "dist" =&gt; "386.9165" ]] 根据已有的位置查询1234567891011121314151617181920212223242526272829/** * 根据集合中的元素查询范围内元素，如果不转 key就用默认的 * @param $name 集合中的元素名 * @param $radius 范围 * @param $unit 单位 * @param null $key 集合名 * @return mixed */$search = $lbs-&gt;-&gt;searchByMembers('fesco',500,'m');返回数组array:4 [▼ 0 =&gt; array:2 [▼ "name" =&gt; "fesco" "dist" =&gt; "0.1250" ] 1 =&gt; array:2 [▼ "name" =&gt; "yabao_road" "dist" =&gt; "162.8454" ] 2 =&gt; array:2 [▼ "name" =&gt; "cofco" "dist" =&gt; "239.7758" ] 3 =&gt; array:2 [▼ "name" =&gt; "galaxy_soho" "dist" =&gt; "386.9165" ]] 列出集合的所有值（其实就是 zrange)123456789101112131415161718/** * 列出集合中的内容 * @param $key 集合的key * @param int $start 起始位置 * @param int $end 结束位置 -1 为直到末尾 * @return array */$list = $lbs-&gt;list($test-&gt;geoset_name,2,-1);返回数组array:6 [▼ 0 =&gt; "jianguomen" 1 =&gt; "yabao_road" 2 =&gt; "fesco" 3 =&gt; "cofco" 4 =&gt; "galaxy_soho" 5 =&gt; "chaoyangmen"]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LBS使用redis的解决方案--GEOHASH]]></title>
      <url>%2F2017%2F03%2F10%2Fredis-geohash-lbs%2F</url>
      <content type="text"><![CDATA[最近需要用到LBS距离测绘方面的东西，用于搜索附近的人，在网上搜了一下有一个比较通用的方案，就是采用 GEOHASH 算法 相关的参考资料 这套算法在 mongoDB 当中已经集成了，但是公司的业务中没有用到 mongodb 而是用了redis，本来打算自己造个轮子去实现，但是万幸翻看了一下redis的文档，它也在 3.* 版本后提供了GEO相关的api 相关文章 首先是添加命令 GEOADD1GEOADD key long lat name [long lat name1,long lat name2,long lat name3...] key GEOSET的名字 long 地点的经度 lat 地点的纬度 name GEOSET内的值的名字可以批量输入 举个栗子12GEOADD chaoyangqu 116.43620200729366 39.916880160714435 &quot;yabaolu&quot; 116.4356870231628 39.908560377800676 &quot;jianguomen&quot; 116.4345336732864 39.924466658329585 &quot;chaoyangmen&quot; 116.4335788068771 39.921372916981106 &quot;yinhesoho&quot; 116.43564410781856 39.92024564137184 &quot;zhongliang&quot;(integer) 5 返回值为1 说明是新添，返回0 说明是更新 错误的话就报错了 查看当前插入的内容123456zrange chaoyangqu 0 -11) &quot;jianguomen&quot;2) &quot;yabaolu&quot;3) &quot;zhongliang&quot;4) &quot;yinhesoho&quot;5) &quot;chaoyangmen&quot; 从这条命令也可以看出来 geoset 是属于有序集合 命令 GEORADIUS1GEORADIUS key long lat radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC] [COUNT count] key 集合的名字 long 指定的经度 lat 指定的纬度 radius 半径范围 unit 单位 可以说 m km ft(英尺) mi(英里)123GEORADIUS chaoyangqu 116.435182767868 39.91811857809279 300 m1) &quot;zhongliang&quot;2) &quot;yabaolu&quot; 带上参数可以显示更多位置信息，通常业务需要显示下距离和进行排序，添加 WITHDIST ASC12345GEORADIUS chaoyangqu 116.435182767868 39.91811857809279 300 m WITHDIST ASC1) 1) &quot;yabaolu&quot; 2) &quot;162.8454&quot;2) 1) &quot;zhongliang&quot; 2) &quot;239.7758&quot; 命令GEORADIUSBYMEMBER1GEORADIUSBYMEMBER key member radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC] [COUNT count] key 集合的名字 long 指定的经度 lat 指定的纬度 radius 半径范围 unit 单位 可以说 m km ft(英尺) mi(英里) 这个和 GEORADIUS 的区别就是 前者是指定坐标，后者是可以直接从集合中指定一个name做计算栗子123456GEORADIUSBYMEMBER chaoyangqu yinhesoho 300 m WITHDIST ASCGEORADIUSBYMEMBER chaoyangqu yinhesoho 300 m WITHDIST ASC1) 1) &quot;yinhesoho&quot; 2) &quot;0.0000&quot;2) 1) &quot;zhongliang&quot; 2) &quot;216.2817&quot; 排在第一位的肯定是自己啊，而且需要确定你要搜寻的名字已经存在集合中，否则会报错 命令GEOPOS1GEOPOS key elem1 elem2 ... elemN 列出集合中指定name的坐标栗子：123456GEOPOS chaoyangqu yabaolu yinhesoho xxx1) 1) &quot;116.43620342016220093&quot; 2) &quot;39.9168813345921123&quot;2) 1) &quot;116.43358021974563599&quot; 2) &quot;39.92137286048646416&quot;3) (nil) 说明如果 name 不存在set中就会返回nil 命令GEODIST12GEODIST key elem1 elem2 [unit]1. unit 单位可以说m lm ft mi 只能是两个元素之间的啊，不然三个元素就是语法错误，两个元素中有一个不存在则返回 nil栗子12GEODIST chaoyangqu yabaolu yinhesoho m&quot;547.4030&quot; 下面的几个命令做个了解，平时不常用到 GEOHASH key elem1 elem2 … elemN //获取指定name的hash值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker(3) 构建Dockerfile]]></title>
      <url>%2F2017%2F03%2F08%2Fdocker-dockerfile%2F</url>
      <content type="text"><![CDATA[上一章我们用的是 docker commit 命令创建的自己的库，虽然简单但是定制性比较差，因此我们采用另一种且更广泛的做法就是 docker build命令，先上手做个demo 1234cd $HOME/document/wwwmkdir build_democd build_demovi Dockerfile 下面是 Dockerfile 中的代码123456# Version 0.0.1FROM gaofeifiy/ubuntu-lastMAINTAINER GPF “5173180@qq.com”RUN touch /ReadMe.txtRUN echo &apos;hey your contain build success!&apos; &gt; /ReadMe.txtEXPOSE 80 然后在 $HOME/document/www/build_demo 目录下运行12345678910111213141516171819202122➜ lnmp_docker docker build -t=&quot;gaofeifiy/lnmp_server&quot; .# 下面是显示的Sending build context to Docker daemon 2.048 kBStep 1 : FROM gaofeifiy/ubuntu-last ---&gt; 6f8cfa1871b0Step 2 : MAINTAINER GPF ---&gt; Running in 3e442a5807f3 ---&gt; 8d0efc1cf9f7Removing intermediate container 3e442a5807f3Step 3 : RUN touch /ReadMe.txt ---&gt; Running in 91a7a049d18c ---&gt; b98309a7d5a4Removing intermediate container 91a7a049d18cStep 4 : RUN echo &apos;hey your contain build success!&apos; &gt; /ReadMe.txt ---&gt; Running in 0158f49fef8f ---&gt; 6416fe72ff4cRemoving intermediate container 0158f49fef8fStep 5 : EXPOSE 80 ---&gt; Running in 26e1d7df6ab7 ---&gt; c994cb02df6eRemoving intermediate container 26e1d7df6ab7Successfully built c994cb02df6e -t 就是我们新建镜像的标签 接下来我们查看一下本地的镜像列表里出现了什么1234➜ lnmp_docker docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgaofeifiy/lnmp_server latest c994cb02df6e 40 hours ago 227 MBgaofeifiy/ubuntu-last latest 6f8cfa1871b0 2 days ago 227 MB 我们刚刚创建的镜像已经出现到本地的列表里面了 输入 docker history c994cb02df6e 查看镜像的构建流程 我们回顾一下整个流程：刚才所有的操作都是在 Dockerfile 这个文件中进行的，我们用到以下命令 . FROM gaofeifiy/ubuntu-last 新建的库采用 gaofeifiy/ubuntu-last 这个镜像构建的(就是上一章我们建的那个，因为写这个的时候电脑没网… 其实应该是 ubuntu:16.04 这类的基础镜像). MAINTAINER GPF “5173180@qq.com” 指定了该镜像的作者和邮箱. RUN touch /ReadMe.txt 运行系统命令，创建一个ReadMe.txt 文件 其他的RUN命令欧式同样的道理. EXPOSE 80 指定镜像对外端口是80 下面介绍一下更多的Dockerfile相关的指令 . ENV 设置镜像中的环境变量 比如 ENV REFRESHED_AT 2017-02-22 设置缓存更新时间. CMD 和docker run 命令类似，是等容器启动后执行的命令，会被docker run指令干扰 例CMD [&quot;/bin/bash&quot;,&quot;-l&quot;] 这里推荐使用数组形式，防止出现-c参数的干扰. ENTRYPOINT 和CMD命令类似，但是不会被docker run的命令干扰，而且会把docker run后的指令当作 ENTRYPOINT的参数来用 例如：ENTRYPOINT [&quot;/usr/sbin/nginx&quot;,&quot;-g&quot;,&quot;demon off&quot;] 这条命令和 ENTRYPOINT [&quot;/usr/sbin/nginx&quot;] 加上 docker run -t -i xxx镜像 -g &quot;demon off&quot; 两条语句产生的作用相同. USER 指定镜像以什么用户去运行，默认是root 也可以docker run -u 来指定用户. VOLUME 创建一个容器的共享卷，这样的话多个镜像容器公用一套内容，相当于类中的静态变量. ADD 将本地文件添加到镜像当中，会解压 仅限在以Dockerfile文件为根目录的目录下. COPY 将本地文件拷贝到镜像当中，不会解压 仅限在以Dockerfile文件为根目录的目录下. ONBUILD 当其他镜像使用本镜像的时候触发的命令 例如ONBUILD RUN echo &#39;hello world&#39; 当别的镜像引用到这个镜像的时候就会执行这条命令]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go语言了解(1)]]></title>
      <url>%2F2017%2F03%2F08%2Fgo-info%2F</url>
      <content type="text"><![CDATA[有人说go和php有很多相似的地方，用惯了弱语言的php是时候换换口味了 声明变量go的声明变量的方式四种（茴香的茴有四种写法），开个玩笑，但是以下几种形式还是可以的 var ValueName type //直接声明一个，声明了就要用啊，不然编译的时候就会报错 var name1,name2,name3 type //类型就近原则，直接声明三个相同类型的变量 var ValueName type = value //声明了变量顺便赋值 var name1,name2,name3 type = value1,value2,value3 //批量赋值也可以，注意他们的类型是一样的 name1,name2,name3 := value1,value2,value3 //这才是常用的写法，用 : 来自动判断类型，单个的也是这个用法还有个特殊的变量名， _ 这代表占个位置但是赋给他的值会被丢弃，比如 _,a := 1,2 a的值为2 但是1就给丢了 这时的使用情景碰到再说 声明常量常量的关键词就不是 var 了 而是 const，和变量的区别是一旦定义就不能改了 const ValueName = value //直接赋值 const Pi float32 = 3.1415926 //也可以声明常量的类型 ###分组赋值在多个包里用到再赋值有的时候不利于debug，可以直接把要赋值的都放到一起 比如:1234567891011const&#123; ENV := true LOCAL := &apos;dev&apos; DATE := 20170307&#125;var&#123; i int pi float32 name string&#125; ##boolean类型true or false 默认为false ##数值类型go支持 int,uint可以定义的类型有rune,int8,int16,int32,int64,byte,uint8,uint16,uint16,uint32,uint64 其中 rune是int32的别称，byte是uint8的别称 不同类型的数不能相互赋值和操作 二进制的数不能和八进制的相加减 浮点型也有float32,float64两种，没有 float这个类型，默认 float64 ##字符串字符串的赋值方式遵循着上面的 声明变量 那一块说的。 Value1 := ‘string’ 和 Value1 := “string” 一个效果 &quot;&quot;代表的是一个空字符串也是占着内存的 字符串之间的拼接用 + 比如12345a,b :=&quot;hello&quot;,&quot;world&quot; c := a + bPrintf(&quot;%s\n&quot;,c) //输出 helloworld 字符串的修改不能直接修改，可以用切片的方式实现例如：123a := &apos;hello&apos;b := &apos;w&apos; + a[1:]//b 的值为 wello 什么是切片我们一会儿就会说到]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Go安装godoc]]></title>
      <url>%2F2017%2F03%2F07%2Fgo-doc%2F</url>
      <content type="text"><![CDATA[现在的版本(go version 1.8)下，go的开发工具已经都在git上上线了，可以直接安装 123git clone https://github.com/golang/tools $GOPATH/src/golang.org/x/toolsgo build golang.org/x/tools 就能生成 godoc 的二进制包了，注意需要把第三方的包放到 $GOPATH/src 目录下，这样才能让go能找到并构建]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装LiteIde配置]]></title>
      <url>%2F2017%2F03%2F07%2Fgo-liteide%2F</url>
      <content type="text"><![CDATA[这里设置 Liteide 的配置(环境macOS) Liteide 是一款专门为go开发的一款ide，省去了类似atom编辑器的一些麻烦的环境配置导致atom越来越臃肿，是不少go的开发者在推荐的一款ide 1.安装go1brew install go 下载Liteide 下载地址 选择一个适合系统的版本，推荐qt5的，版本高的不容易过时 打开编辑器 查看-&gt;编辑当前环境 列出我现在的环境1234567891011121314151617# native compiler darwin amd64GOROOT=/usr/local/Cellar/go/1.8/libexecGOPATH=$HOME/Documents/goGOBIN=GOARCH=amd64GOOS=darwinCGO_ENABLED=1PATH=$GOROOT/bin:$PATHLITEIDE_GDB=/usr/local/bin/gdbLITEIDE_MAKE=makeLITEIDE_TERM=/usr/bin/openLITEIDE_TERMARGS=-a TerminalLITEIDE_EXEC=/usr/X11R6/bin/xtermLITEIDE_EXECOPT=-e 上面这一块刚开始是注释掉的，需要我们自己填写，这个是每次运行编辑器的适合才会用到的配置，和安装时的系统配置不冲突 需要注意区分的就是 GOROOT 和 GOPATH 这两个变量 GOROOT 是go的执行目录，说白了就是go源码的安装目录，比如 import “fmt”这条命令就是从 GOROOT 给的路径中找加载的包 GOPATH 是工作目录，类似apache的www目录，你的项目代码都是放到 $GOPATH/src 目录下的同时我们通过 go get 获取的第三方package也是放在这里的为了能执行package里的文件也是需要把这个路径添加到环境变量当中，因此才会出现 PATH=$GOROOT/bin:$PATH 这样的配置 配置完成后运行个文件试一下12cd $HOME/Documents/go/srcmkdir hello &amp;&amp; cd hello 通过liteide编辑器打开目录，创建一个文件 main.go 文件内容如下1234567package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;Hello world!&quot;)&#125; 然后点击编辑器右上角的 BR(build and run) 就能在编辑器下面的信息框中看到输出内容了 ready go！ 参考1 参考2 ps:因为颜值我最后还是采用了 atom 的 go-plus 插件 :)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[转 HTML5上传文件显示进度]]></title>
      <url>%2F2017%2F03%2F06%2Fhtml5-ajax-process%2F</url>
      <content type="text"><![CDATA[使用ajax上传文件的时候为了通过 files api来获取文件信息，从而可以看到显示进度html 1234567891011121314151617&lt;div class="row"&gt; &lt;label for="file"&gt; Upload Image:&lt;/label&gt; &lt;input type="file" name="fileToUpload" id="fileToUpload" multiple="multiple" onchange="fileSelected();" /&gt; &lt;/div&gt; &lt;div id="fileName"&gt; &lt;/div&gt; &lt;div id="fileSize"&gt; &lt;/div&gt; &lt;div id="fileType"&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;input type="button" onclick="uploadFile()" value="Upload Image" /&gt; &lt;/div&gt; &lt;div id="progressNumber"&gt; &lt;/div&gt; js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function fileSelected() &#123; var file = document.getElementById(&apos;fileToUpload&apos;).files[0]; if (file) &#123; var fileSize = 0; if (file.size &gt; 1024 * 1024) fileSize = (Math.round(file.size * 100 / (1024 * 1024)) / 100).toString() + &apos;MB&apos;; else fileSize = (Math.round(file.size * 100 / 1024) / 100).toString() + &apos;KB&apos;; document.getElementById(&apos;fileName&apos;).innerHTML = &apos;Name: &apos; + file.name; document.getElementById(&apos;fileSize&apos;).innerHTML = &apos;Size: &apos; + fileSize; document.getElementById(&apos;fileType&apos;).innerHTML = &apos;Type: &apos; + file.type; &#125;&#125;function uploadFile() &#123; var fd = new FormData(); fd.append(&quot;fileToUpload&quot;, document.getElementById(&apos;fileToUpload&apos;).files[0]); var xhr = new XMLHttpRequest(); xhr.upload.addEventListener(&quot;progress&quot;, uploadProgress, false); xhr.addEventListener(&quot;load&quot;, uploadComplete, false); xhr.addEventListener(&quot;error&quot;, uploadFailed, false); xhr.addEventListener(&quot;abort&quot;, uploadCanceled, false); xhr.open(&quot;POST&quot;, &quot;Home/Upload&quot;); xhr.send(fd);&#125;function uploadProgress(evt) &#123; if (evt.lengthComputable) &#123; var percentComplete = Math.round(evt.loaded * 100 / evt.total); document.getElementById(&apos;progressNumber&apos;).innerHTML = percentComplete.toString() + &apos;%&apos;; &#125; else &#123; document.getElementById(&apos;progressNumber&apos;).innerHTML = &apos;unable to compute&apos;; &#125;&#125;function uploadComplete(evt) &#123; /* This event is raised when the server send back a response */ alert(evt.target.responseText);&#125;function uploadFailed(evt) &#123; alert(&quot;There was an error attempting to upload the file.&quot;);&#125;function uploadCanceled(evt) &#123; alert(&quot;The upload has been canceled by the user or the browser dropped the connection.&quot;);&#125; 这里加了一个监听事件，可以通过异步来不断获取上传信息，从而能正常的显示上传进度 文章来源另一个资料－使用 JavaScript File API 实现文件上传]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Centos65安装docker遇到的坑]]></title>
      <url>%2F2017%2F03%2F01%2Fcontentos-docker%2F</url>
      <content type="text"><![CDATA[在国内的云服务商提供的镜像内核都是2.6.*的，不能满足docker需要的3.1.*，因此首先需要升级一下内核 12345678#导入public keyrpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org#安装elrepo到内核为2.6.32的CentOS中rpm -Uvh http://www.elrepo.org/elrepo-release-6-6.el6.elrepo.noarch.rpm#安装kernel-lt(long term support)长期支持版本yum --enablerepo=elrepo-kernel install kernel-lt -y 如果yum安装的慢，可以通过rpm安装kernel-lt12访问http://elrepo.org/linux/kernel/el6/x86_64/RPMS/下载对应的rpm包，通过rpm方式安装：rpm -ivh kernel-lt-3.10.93-1.el6.elrepo.x86_64.rpm 安装完毕后编辑配置文件123456789101112131415161718192021222324vi /etc/grub.conf# grub.conf generated by anaconda## Note that you do not have to rerun grub after making changes to this file# NOTICE: You do not have a /boot partition. This means that# all kernel and initrd paths are relative to /, eg.# root (hd0,0)# kernel /boot/vmlinuz-version ro root=/dev/xvda1# initrd /boot/initrd-[generic-]version.img#boot=/dev/xvdadefault=0timeout=5splashimage=(hd0,0)/boot/grub/splash.xpm.gzhiddenmenutitle CentOS (3.10.105-1.el6.elrepo.x86_64) root (hd0,0) kernel /boot/vmlinuz-3.10.105-1.el6.elrepo.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-3.10.105-1.el6.elrepo.x86_64.imgtitle CentOS (2.6.32-573.22.1.el6.x86_64) root (hd0,0) kernel /boot/vmlinuz-2.6.32-573.22.1.el6.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-2.6.32-573.22.1.el6.x86_64.imgtitle CentOS (2.6.32-431.23.3.el6.x86_64) 我们用的 CentOS (3.10.105-1.el6.elrepo.x86_64)就排在第一个，因此改成 default=0 保存后重启系统12uname -aLinux iZm5eib1msf1eaxvrvhp60Z 3.10.105-1.el6.elrepo.x86_64 #1 SMP Fri Feb 10 10:48:08 EST 2017 x86_64 x86_64 x86_64 GNU/Linux 安装docker123yum install -y docker-engineservice docker startsudo docker version 如果出现 Cannot connect to the Docker daemon. Is &#39;docker -d&#39; running on this host? 这种提示，按以下解决步骤： 执行 service docker start 加上 sudo 执行 yum upgrade device-mapper 我是执行到第三步就可以正常运行了，如果还没解决问题的话就自己找去吧 资料1-centos安装docker升级内核到3.10 资料2-github/docker/issues/11356]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[beforeAction的一个示例]]></title>
      <url>%2F2017%2F02%2F28%2Fyii-beforeaction%2F</url>
      <content type="text"><![CDATA[1234567891011121314public function beforeAction($action)&#123; if(condition)&#123; Yii::$app-&gt;response-&gt;format = Response::FORMAT_JSON; Yii::$app-&gt;response-&gt;data = array( &apos;status&apos; =&gt; -1, &apos;message&apos; =&gt; &apos;请先登录&apos;, &apos;url&apos; =&gt; \Yii::$app-&gt;getHomeUrl() ); return false; &#125; return true;&#125; 这个函数只返回bool值，响应内容交给 response 原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[局部关闭Csrf验证]]></title>
      <url>%2F2017%2F02%2F28%2Fyii-csrf%2F</url>
      <content type="text"><![CDATA[简单理解 yii的 hehavior 就是代码实现了php54的 trait 特性创建一个hehavior1234567891011121314151617181920212223&lt;?phpuse Yii;use yii\base\ActionEvent;use yii\base\Behavior;use yii\web\Controller;class NoCsrf extends Behavior&#123; public $actions = []; public $controller; public function events() &#123; return [Controller::EVENT_BEFORE_ACTION =&gt; &apos;beforeAction&apos;]; &#125; public function beforeAction($event) &#123; $action = $event-&gt;action-&gt;id; if(in_array($action, $this-&gt;actions))&#123; $this-&gt;controller-&gt;enableCsrfValidation = false; &#125; &#125; &#125; 在controller中调用1234567891011121314&lt;?php public function behaviors() &#123; return [ &apos;csrf&apos; =&gt; [ &apos;class&apos; =&gt; NoCsrf::className(), &apos;controller&apos; =&gt; $this, &apos;actions&apos; =&gt; [ &apos;action-name&apos; ] ] ]; &#125; 这种方法是将控制器中指定的路由方法不经过csrf验证，如果是全局关闭csrf验证的话直接在 controller 添加12//关闭csrf验证public $enableCsrfValidation = false; 原文地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker(2) 创建属于自己的库]]></title>
      <url>%2F2017%2F02%2F19%2Fdocker-repo%2F</url>
      <content type="text"><![CDATA[上一章是了解了怎么创建一个容器，现在我们来把它做成我们自己的库，类似git那样的首先查看下自己的库有哪些12345➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4cd577624dd2 ubuntu &quot;/bin/bash&quot; 2 days ago Exited (127) 16 hours ago little_cat80ac1b1ba419 ubuntu &quot;/bin/bash&quot; 2 days ago Exited (0) 2 days ago determined_bhaskarace5104ceef1f ubuntu &quot;/bin/bash&quot; 4 days ago Exited (0) 4 days ago small_hugle 我们上次创建并操作的容器就是名字是little_cat 而且它的容器id为4cd577624dd2 正是我们需要的 接下来就是在docker官网上注册一个账号，过程也很简单，填个账户，邮箱，密码 邮箱再验证一下就好 本地我们登陆一下1➜ ~ docker ps -a 输入有效的账户信息就行，他会在 $HOME/.docker/config.json 文件中生成一条 auth 信息 登陆成功后，我们把指定的容器做成我们自己的库1➜ ~ docket commit 4cd577624dd2 gaofeifiy/ubuntu-base 这条命令的作用就是把 containerId 为 4cd577624dd2 (也就是 little_cat) 提交给 gaofeifiy/ubuntu-base 这个库，注意，这里commit的时候要用到id而不是容器的name，我自己试的时候就出现提交为none的情况，也许以后的版本会补上 这个有什么作用呢？ 我们查看一下images 12345➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgaofeifiy/ubuntu-base latest 6f8cfa1871b0 40 minutes ago 227 MBubuntu 16.04 f49eec89601e 4 weeks ago 129.5 MBubuntu latest f49eec89601e 4 weeks ago 129.5 MB 我们最早的 little_cat 已经在本地被做成一个基础的images了 直接用它创建一个容器123456➜ ~ docker run -t -i --name big_cat gaofeifiy/ubuntu-base /bin/bash➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES10ea9940c6d2 gaofeifiy/ubuntu-base &quot;/bin/bash&quot; 48 seconds ago Exited (0) 39 seconds ago big_cat 我们用刚才新建的image为基础创建了 big_cat 这个容器 要删除的话也是很简单，这里有两个命令 docker rm 和 docker rmi 12docker rm 10ea9940c6d2 这是用来删除容器(CONTAINER)的docker rmi 6f8cfa1871b0 这是用来删除镜像的(IMAGE) 的 有一点需要注意的就是如果要删除的image是有container在使用的话需要先把container给删除再删除image]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker(1)入门]]></title>
      <url>%2F2017%2F02%2F16%2Fdocker-info%2F</url>
      <content type="text"><![CDATA[开始首先在docker官网或者国内的daoCloud来下载工具，不推荐新手在直接通过brew来安装 docker-machine 根据安装导航安装好就行 刚接触一个新玩具最先要做的就是让他跑起来 打开命令行，输入命令1234567891011121314151617docker versionlient: Version: 1.12.3 API version: 1.24 Go version: go1.6.3 Git commit: 6b644ec Built: Wed Oct 26 23:26:11 2016 OS/Arch: darwin/amd64Server: Version: 1.12.3 API version: 1.24 Go version: go1.6.3 Git commit: 6b644ec Built: Wed Oct 26 23:26:11 2016 OS/Arch: linux/amd64 运行正常 接下来我们用到了几个命令12345docker run 运行一个主机docker ps 列出正在运行的主机docker attach 附着到指定的主机上docker pull 从远程拉下指定的容器docker images 列出下载到本地的容器 首先开启运行一个ubuntu容器1docker run -i -t ubuntu /bin/bash 解释一下命令含义： 运行ubuntu容器， -i 保证容器中的 STDIN 是开启的， -t 为容器生成一个伪tty终端 ubuntu 以ubuntu作为基础镜像，同理可以使用 centos，debain之类的 更多的命令 输入 docker run –help 可以查看 执行这条命令的时候，如果本地没有 ubuntu 的话会自动执行 docker pull ubuntu 拉取默认的ubuntu镜像到本地，执行完毕后就会进入容器中的bash界面，相当于一个ubuntu的虚拟机，执行 hostname 查看homeId执行 exit推出容器内部界面，当退出的时候容器也将停止运行 退出后到本地的终端界面12345678docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES572fd5bda011 ubuntu &quot;-i -t /bin/bash&quot; Less than a second ago Created hungry_franklin4cd577624dd2 ubuntu &quot;/bin/bash&quot; 58 minutes ago Exited (127) 9 minutes ago little_cat80ac1b1ba419 ubuntu &quot;/bin/bash&quot; About an hour ago Exited (0) 59 minutes ago determined_bhaskarace5104ceef1f ubuntu &quot;/bin/bash&quot; 47 hours ago Exited (0) 47 hours ago small_hugle 列出所有的容器，每次 docker run 都会新创建一个容器， 相当于每次运行的时候都是一个初始的容器 如果想接着上次退出的就执行12docker start 4cd577624dd2docker start little_cat 这两条执行的效果是一样的，都是指向同一个容器 但是这时只是开启了，我们想进入这个容器里怎么办？ 执行下一条命令1docker attach littlt_cat 这样就会进入到容器里面的界面 忘了说了，如果想创建一个指定名字的容器就添加一个 --name 参数 比如1docker run -d --name littl_cat ubuntu /bin/bash 这里的 -d 就是以守护进程的方式在后台运行 –name 就是指定了容器的名字，如果不指定的话也会随机分配一个]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Composer的一个小毛病]]></title>
      <url>%2F2017%2F02%2F13%2Fcomposer-debug%2F</url>
      <content type="text"><![CDATA[当环境中同时安装xdebug和composer的时候，会产生一个报错1You are running composer with xdebug enabled. This has a major impact on runtime performance. See Https://getcomposer.org/xdebug 其实作为开发环境来说，并没有太大的影响，也就是拖慢了composer的运行速度，大概3-4倍的样子。 当然，如果不想让那个 warning 再显示就先全局关闭xdebug 首先知道到php.ini的文件路径123➜ ~ php -i | grep &quot;php.ini&quot;Configuration File (php.ini) Path =&gt; /usr/local/etc/php/7.0Loaded Configuration File =&gt; /usr/local/etc/php/7.0/php.ini 编辑php.ini文件 找到xdebug扩展的位置给加上引号注释下就行123;[xdebug];zend_extension=&quot;/usr/local/opt/php70-xdebug/xdebug.so&quot;~ 如果php.ini文件当中没有这个模块的配置，就找找php.ini同级目录下的 conf.d 目录，那里也是加载php扩展的配置文件的 比如我的路径就是1cd /usr/local/etc/php/7.0/conf.d/ext-xdebug.ini 一样给注释掉就行 参考1 参考2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[科学上网Shadowsocks]]></title>
      <url>%2F2017%2F02%2F09%2Fshadowssocks%2F</url>
      <content type="text"><![CDATA[首先找个国外的服务器，比如 AWS 搬瓦工 这样的，然后开始安装 shadowsocks： 安装shadowsocks依赖1234561. sudo -s // 获取超级管理员权限2. apt-get update // 更新apt-get3. apt-get install python-pip // 安装python包管理工具pip4. pip install shadowsocks // 安装shadowsocks 当写好配置文件之后就可以开启了，配置文件内容在下面列出来了5. ssserver -c /etc/shadowsocks.json -d start // 启动shadowsocks 3 4 5 可以换成12343 apt install shadowsocks4 ssserver -c /etc/shadowsocks.json startapt我当时安装的shadowsocks没有开启守护进程的指令（-d），使用pip安装的可以 所以如果pip的正常安装就用那个 就是取消了守护进程开启 shadowskcks.json内容12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:开放的端口, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;访问密码&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false&#125; 或者12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;port_password&quot;: &#123; &quot;端口1&quot;: &quot;连接密码1&quot;, &quot;端口2&quot; : &quot;连接密码2&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 机器设置好后再修改防火墙规则，开放你在配置文件中设置的端口号 这时候在你要使用的 pc／mobile 上下载个shadowsocks 服务器地址就是你国外主机的地址，端口就是你配置文件中的端口，密码是配置文件中的密码 完]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git推送远程失败]]></title>
      <url>%2F2017%2F01%2F11%2Fgit-error%2F</url>
      <content type="text"><![CDATA[git push 的时候提示:12remote: Permission to ******/born.git denied to ******/.fatal: unable to access &apos;https://github.com/ ******//born.git/&apos;: The requested URL returned error: 403 是因为git的账号冲突，git误认为你使用的是另一个账号，解决办法也很简单 推送方式改成ssh的，这样即使是不同账号但是使用的是同一台设备，还不需要改动究竟和哪一个账号冲突了 查看本机ssh－key1cat ~/.ssh/id_rsa.pub 登录自己的github账户&gt;自己的头像&gt;Setting&gt;SSH and GPG keys&gt;New SSH key 把本机的那一串密码填里面就行 推送方式也改成ssh的地址1git remote set-url origin git@github.com:******/born.git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己封装一个Composer包玩玩]]></title>
      <url>%2F2017%2F01%2F11%2Fcomposer-package%2F</url>
      <content type="text"><![CDATA[how to build a composer package 参考文档 首先是完善 composer.json 这个是composer需要抓去的的东西，相当于这个composer包的名片 实现步骤是 创建一个git库 （不用说自己查） 初始化composer包命令 composer init 然后一路回车，生成的 composer.json 的样本如下（重点在这里） https://packagist.org 上注册顺着网站提示一路下去就行 库中引用在你想要使用库的项目中的 composer.json 的 require 中添加 &quot;gaopengfei/born&quot;:&quot;dev-master&quot; 然后运行 composer update ，你的包就出现在该项目中的依赖当中了，注意：require的时候一定要指明版本，不然会报错 1234567891011121314151617181920212223242526//composer.json&#123; &quot;name&quot;: &quot;gaopengfei/born&quot;, &quot;description&quot;: &quot;how to build a composer package&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;gaofeifiy&quot;, &quot;email&quot;: &quot;5173180@qq.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.3.0&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Body\\Arm\\&quot;: &quot;src/Body/Arm&quot;, &quot;Body\\Leg\\&quot;: &quot;src/Body/Leg&quot; &#125; &#125;, &quot;files&quot;: [ &quot;path/to/file.php&quot; ]&#125; files 是用于引入全局使用的帮助函数 想让文件能自动加载就靠 autoload 这块的配置了，这里选用了 psr-4 格式的命名规范，这里设置了你的命名空间生效的文件夹在哪里， 当我 use Body\Arm\** 的时候，composer 知道是从 ./src/Body/Arm 这个径下找对应的类名， psr-4规范的大体思想就是命名空间就是文件路径，类名就是文件名，这样设置完之后 运行 composer install 生成了 vendor／autoload.php 文件就能自动加载了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git强制将远程版本覆盖本地]]></title>
      <url>%2F2017%2F01%2F06%2Fgit-push-force%2F</url>
      <content type="text"><![CDATA[12git fetch --allgit reset --hard origin/master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Laravel服务容器延迟加载]]></title>
      <url>%2F2016%2F12%2F26%2Flaravel-lazy-load%2F</url>
      <content type="text"><![CDATA[laravel 注册的服务是可以延时加载的 很简单，在provider文件夹下指定的服务当中这样写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace App\Providers;use App\Repositories\RecommendRepository;use Illuminate\Support\ServiceProvider;class HotcastProvider extends ServiceProvider&#123; /** * 服务提供者加是否延迟加载. * * @var bool */ protected $defer = true; /** * Bootstrap the application services. * * @return void */ public function boot() &#123; // &#125; /** * Register the application services. * * @return void */ public function register() &#123; $this-&gt;app-&gt;bind('App\Repositories\Contract\RecommendInterface','App\Repositories\RecommendRepository'); $this-&gt;app-&gt;singleton('RecommendFacade',function ()&#123; return new RecommendRepository(); &#125;); &#125; /** * 获取由提供者提供的服务. * * @return array */ public function provides() &#123; return ['RecommendFacade','App\Repositories\Contract\RecommendInterface']; &#125;&#125; 把 defer 改为 true， 添加一个 provides方法，然后命令行执行php artisan clear-compiled 重新编译一下服务文件就OK了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通过Git Rebase来合并commit提交记录]]></title>
      <url>%2F2016%2F12%2F25%2Fgit-rebase%2F</url>
      <content type="text"><![CDATA[多人合作开发的时候就会因为本地的多个版本提交的很多杂乱的信息，导致git log查看的时候并不能很快的从一堆无意义的提交记录中找到我们想要的版本。做完一个小功能随时提交是一个好习惯，但是这写小记录推送到远程就是个不大不小的麻烦我们通过rebase命令将这些小版本合并成一个大的版本，然后推送到远程，前提是你的代码功能已经达到了。 查看log信息123456789101112131415161718commit 53097de5638d371da51bc6fef74a90ca1420d967Author: GPF &lt;5173180@qq.com&gt;Date: Sun Dec 25 22:46:13 2016 +0800 test3commit 830026adb43506d0bc1172432f84639f84dae087Author: GPF &lt;5173180@qq.com&gt;Date: Sun Dec 25 22:45:56 2016 +0800 test2commit 646f5be02ec285e30626f5682e6e7e9437762ac5Author: GPF &lt;5173180@qq.com&gt;Date: Sun Dec 25 22:45:43 2016 +0800 test1... 比如我们就合并这前三个提交记录 开启rebase脚本1git rebase -i HEAD~3 HEAD~3的意思就是最近的san tiao三条提交信息 编辑脚本执行步骤2的时候就会进入一个编辑脚本如下：12345678910111213141516171819202122pick 646f5be test1pick 830026a test2pick 53097de test3# Rebase dbaf38a..53097de onto dbaf38a (3 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 带#号的都是注释内容，这里提供了很多命令信息。最上面的三行就是我们要执行的命令，pick 查看注释是 use commit 可以简写成 p ， 而且你看排列commit记录的顺序是最早的排在最上面，我们这次是为了合并commit，因此我们要用的命令就是squash 简写成 s将脚本修改成这样：12345678910111213141516171819202122pick 646f5be test1s 830026a test2s 53097de test3# Rebase dbaf38a..53097de onto dbaf38a (3 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 我们合并最早的两个到test1版本当中然后:wq退出，注意合并记录的时候，不能pick最近的一条，会产生报错，如果把报错的话就输入命令git rebase --abort终止这次执行就好 接下来会直接进入一个commit记录编辑界面，#都是注释过的，将非注释的内容编辑成我们想要的然后:wq保存就完毕了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[再来个Facade吧]]></title>
      <url>%2F2016%2F12%2F19%2Flaravel-facade%2F</url>
      <content type="text"><![CDATA[参照上一篇的文章laravel 的 Repository 模式 都已经注册了服务也可以使用 Facade了 首先创建一个 Facade文件，还是在 app/Repositories这里，创建HelloFacade.php 名字无所谓，路径也是无所谓的，关键是能够正确引入文件就行12345678910111213141516171819&lt;?php/** * Created by PhpStorm. * User: gpf * Date: 2016/12/19 * Time: 下午10:48 */namespace App\Repositories;use Illuminate\Support\Facades\Facade;class HelloFacade extends Facade&#123; protected static function getFacadeAccessor() &#123; return 'Hello'; &#125;&#125; 然后再在之前创建的namespace App\Providers\HelloProvider中作出一些改动123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\Providers;use Illuminate\Support\ServiceProvider;use App\Repositories\Hello;use App\Repositories\HelloRepository;class HelloProvider extends ServiceProvider&#123; /** * Bootstrap the application services. * * @return void */ public function boot() &#123; // &#125; /** * Register the application services. * * @return void */ public function register() &#123; $this-&gt;app-&gt;bind(&apos;App\Repositories\Hello&apos;,&apos;App\Repositories\HelloRepository&apos;); $this-&gt;app-&gt;singleton(&apos;Hello&apos;,function()&#123; return new HelloRepository(); &#125;); &#125;&#125; $this-&gt;app-&gt;singleton就是为了去绑定facade 现在已经成功了一半了，接下来去配置文件中注册一下就能正常使用了 在config/app.php中12345678910&apos;providers&apos; =&gt; [ .... App\Providers\HelloProvider::class, ....],&apos;aliases&apos; =&gt; [ ... &apos;Hello&apos; =&gt; \App\Repositories\HelloFacade::class, ...] 这样注册过后就能在文件中直接类似123use Hello;Hello::say(); 这一类的调用了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows构建node,npm,gulp工具(测试可用)]]></title>
      <url>%2F2016%2F12%2F13%2Fwin-node-npm%2F</url>
      <content type="text"><![CDATA[windows 安装 node 其实很简单 原文地址 第一步到官网下载页下载nodejs，并默认安装，安装成功后打开cmd， 运行node -v即可查看当前node.js版本。 第二步安装windows git工具，本机已经安装好git bash，可自行百度安装。 第三步安装npm，打开git bash，进入自定义的文件夹下，然后执行 12git config --system http.sslcainfo /bin/curl-ca-bundle.crtgit clone --recursive git://github.com/isaacs/npm.git 克隆成功后，进入npm文件夹下，执行1node cli.js install npm -gf 第四步用npm安装gulp 12$ npm install --global gulp$ npm install --save-dev gulp 第五步安装gulp插件 1npm install gulp-util gulp-imagemin gulp-ruby-sass gulp-minify-css gulp-jshint gulp-uglify gulp-rename gulp-concat gulp-clean gulp-livereload tiny-lr --save-dev 第六步测试gulp，创建一个名为 gulpfile.js 的配置文件在当前目录下，并输入下面的代码，这里创建了一个空的任务（仅作为用于测试gulp是否正常工作） 1234var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; // place code for your default task here&#125;); 最后，执行1$ gulp 运行gulp，如果正确输出类似下面的信息，则说明gulp 已经正确安装并运行。1234$ gulp[11:13:17] Using gulpfile xxx\gulpfile.js[11:13:17] Starting &apos;default&apos;...[11:13:17] Finished &apos;default&apos; after 44 μs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swoole构建聊天室demo]]></title>
      <url>%2F2016%2F12%2F10%2Fwebsocket-demo%2F</url>
      <content type="text"><![CDATA[websocket文档 原文出处 后端代码12345678910111213141516171819202122232425//websocket.php&lt;?php$server = new swoole_websocket_server("0.0.0.0", 9501);$server-&gt;on('open', function (swoole_websocket_server $server, $request) &#123; file_put_contents( __DIR__ .'/log.txt' , $request-&gt;fd);&#125;);$server-&gt;on('message', function (swoole_websocket_server $server, $frame) &#123; global $client; $data = $frame-&gt;data; $m = file_get_contents( __DIR__ .'/log.txt'); for ($i=1 ; $i&lt;= $m ; $i++) &#123; echo PHP_EOL . ' i is ' . $i . ' data is '.$data . ' m = ' . $m; $server-&gt;push($i, $data ); &#125;&#125;);$server-&gt;on('close', function ($ser, $fd) &#123; echo "client &#123;$fd&#125; closed\n";&#125;);$server-&gt;start(); 前端代码123456789101112131415161718192021//index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;script type="text/javascript"&gt; var exampleSocket = new WebSocket("ws://0.0.0.0:9501"); exampleSocket.onopen = function (event) &#123; exampleSocket.send("亲爱的服务器！我连上你啦！"); &#125;; exampleSocket.onmessage = function (event) &#123; console.log(event.data); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="content"&gt;&lt;button onclick="exampleSocket.send( document.getElementById('content').value )"&gt;发送&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 现在在本地命令行运行1php websocket.php 查看浏览器的console就可以测试了,swoole官方example中有个示例，这个demo就是为了抢先体验一下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装Swoole的记录]]></title>
      <url>%2F2016%2F12%2F10%2Fphp-swoole%2F</url>
      <content type="text"><![CDATA[源码地址 因为swoole已经加入官方扩展包中，可以直接用pecl安装1pecl install swoole 也可以通过源码安装： 首先确认php的安装路径1which php 这个大部分都是指向的/usr/local/bin/php这个地址，但这些文件都是链接，顺着这个就能找到文件真正所在了 去这里是为了找到 phpize 这个工具,在文件安装目录中的 bin 目录中找有没有 phpize 这个快捷方式如果没有的话，就运行如下命令：12yum install php-dev注意版本问题 之后有了 phpize 工具就好说了123456sudo apt-get install php5-devgit clone https://github.com/swoole/swoole-src.gitcd swoole-srcphpize./configuremake &amp;&amp; make install 这一段是官方提供的安装命令，安装完毕后留意一下他的安装路径，或者指定路径 可以在编译前的 ./configure --help查看，比如----prefix=/your/wanted/path 之后就是在运行的php.ini文件中添加配置了12#查看php运行的php.iniphp -i | grep php.ini 编辑 php.ini 直接添加一行1extension= swoole.so 保存退出后1php -m | grep swoole 出现了就说明已经安装上了，high起来！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[centos上安装git2.2]]></title>
      <url>%2F2016%2F12%2F03%2Fcentos-install-git%2F</url>
      <content type="text"><![CDATA[centos自带的git版本太低了,安装个新吧 安装依赖环境12&gt;# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidoc&gt;# yum install gcc perl-ExtUtils-MakeMaker error: ```/utf8.c:463: undefined reference to `libiconv&apos; wget http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gztar zxvf libiconv-1.14.tar.gzcd libiconv-1.14./configure –prefix=/usr/local/libiconvmake &amp;&amp; make install1### 卸载Centos自带的git1.7.1 yum remove git1### 下载git2.2.1并将git添加到环境变量中 wget https://github.com/git/git/archive/v2.2.1.tar.gztar zxvf v2.2.1.tar.gzcd git-2.2.1make configure./configure –prefix=/usr/local/git –with-iconv=/usr/local/libiconvmakeall docmake install install-doc install-htmlecho”export PATH=$PATH:/usr/local/git/bin” &gt;&gt; /etc/bashrcsource /etc/bashrc1### 查看版本号 git –versiongit version2.2.1```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git删除已提交入库的文件]]></title>
      <url>%2F2016%2F11%2F29%2Fgit-rm-cache%2F</url>
      <content type="text"><![CDATA[将git已经提交的文件移除出库（针对的就是 .idea 和 .DS_Store）12345678git rm -r --cache .idea/git rm --cache .DS_Store在 .gitignore 文件中添加相应禁止的东西git commit -m &apos;we didnt want to see you any more!&apos;git pullgit push 这是将指定的文件从库中删除而不影响实际使用的文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git更换远程地址]]></title>
      <url>%2F2016%2F11%2F29%2Fgit-remote%2F</url>
      <content type="text"><![CDATA[关键就是移除本地的远程连接路径，替换成我们需要传到的路径将本地库的远程地址更改1git remote set-url origin nideyuanchengdizhi 接下来正常推送就好]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git本地建库推送远程]]></title>
      <url>%2F2016%2F11%2F29%2Fgit-push%2F</url>
      <content type="text"><![CDATA[本地新建库12345678910111213#初始化git initgit add -Agit commit -m &apos;init it&apos;#删除本地远程连接git remote rm origingit remote add origin https://git.oschina.net/gaofeifps/laravel53.git#自动合并远程文件git pull origin master#推送到远程git push --set-upstream origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql5.7版本初始化设置]]></title>
      <url>%2F2016%2F11%2F15%2Fmysql57-config%2F</url>
      <content type="text"><![CDATA[5.7版本有了一些新的变动，首先就是密码部分和之前有了较大的区别。它对数据的安全性方面做了较大的提升。其次的是数据对json的支持，数据库添加时自带计算等等一些更加方便的玩意 当第一次安装完毕的时候，要注意安装提示，会给你串字符串那就是系统给的默认密码这个是重点。 登录后进行查库操作会有这样的提示ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.，需要重设密码，步骤如下：12345SET PASSWORD = PASSWORD(‘your new password’);ALTER USER ‘root’@‘localhost’ PASSWORD EXPIRE NEVER;flush privileges; 将mysql添加到环境变量当前我的mac版本是10.10 OS X Yosemite,属于Bourne Shell的变种,这样就简单了 对于系统自带的终端是这样的：1234567sudo vim ~/.bash_profile#对文件中编辑export PATH=$&#123;PATH&#125;:/usr/local/mysql/bin#保存退出:/wq#解析文件立即生效source ~/.bash_profile 如果用的~/.zshrc的这样配置的也是同样的操作步骤,如果有.zshrc这样的文件优先它，否则上面配置的环境变量会被它覆盖，结果就是上面的配置好了关闭终端再重进就又失效了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[lumen5.3正常使用dd()函数]]></title>
      <url>%2F2016%2F11%2F15%2Flumen-dd%2F</url>
      <content type="text"><![CDATA[主用laravel的已经习惯了dd函数的方便，但是放到lumen5.3的时候就变成了悲催的var_dump,查看了下源码12345678910111213141516if (! function_exists('dd')) &#123; /** * Dump the passed variables and end the script. * * @param mixed * @return void */ function dd() &#123; array_map(function ($x) &#123; (new Dumper)-&gt;dump($x); &#125;, func_get_args()); die(1); &#125;&#125; 再找Dumper这个类，1234567891011121314151617181920212223242526&lt;?phpnamespace Illuminate\Support\Debug;use Symfony\Component\VarDumper\Dumper\CliDumper;use Symfony\Component\VarDumper\Cloner\VarCloner;class Dumper&#123; /** * Dump a value with elegance. * * @param mixed $value * @return void */ public function dump($value) &#123; if (class_exists(CliDumper::class)) &#123; $dumper = &apos;cli&apos; === PHP_SAPI ? new CliDumper : new HtmlDumper; $dumper-&gt;dump((new VarCloner)-&gt;cloneVar($value)); &#125; else &#123; var_dump($value); &#125; &#125;&#125; 发现当它查不到CliDumper::class这个类的时候就会使用php自带的var_dump函数，因此我们需要加载一个clidumper1composer require symfony/var-dumper 这样的话哪怕不用的lumen，只要composer能够自动加载就可以直接使用dump()方法，而在lumen当中就是dd()辅助函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七牛云javascriptSDK的demo]]></title>
      <url>%2F2016%2F11%2F12%2Fqiniujs-demo%2F</url>
      <content type="text"><![CDATA[使用oss的话碰到用户上传的场景建议优先使用的js上传到oss，不需要经过服务端，也算减轻了服务器的压力，缺点就是有的sdk不支持文件类型的筛分，但这些都是可以规避的 七牛js的sdkdemo 这里用的laravel框架和vuejs，里面涉及到的语法就算 @ 和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Plupload使用指南&lt;/title&gt; &lt;!-- 七牛云存储文件 --&gt; &lt;script src="http://cdn.staticfile.org/Plupload/2.1.1/plupload.full.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.staticfile.org/qiniu-js-sdk/1.0.14-beta/qiniu.min.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.bootcss.com/vue/2.0.3/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 这里我们只使用最基本的html结构：一个选择文件的按钮，一个开始上传文件的按钮(甚至该按钮也可以不要) --&gt;&lt;p id="container"&gt; &lt;button id="browse"&gt;选择文件&lt;/button&gt; &lt;button id="start_upload"&gt;开始上传&lt;/button&gt;&lt;/p&gt;&lt;div id="info"&gt; &lt;p&gt;上传进度@&#123;&#123; loaded &#125;&#125;&lt;/p&gt; &lt;div v-bind:style="&#123; color: 'black', width: percent + 'px' ,height : '10px'&#125;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var data = &#123; percent : 0, speed : 0, loaded : 0, lastTime : '--:--' &#125;; var vm = new Vue(&#123; el : '#info', data : data &#125;); var uploader = Qiniu.uploader(&#123; runtimes: 'html5,flash,html4', // 上传模式,依次退化 browse_button: 'browse', // 上传选择的点选按钮，**必需** // 在初始化时，uptoken, uptoken_url, uptoken_func 三个参数中必须有一个被设置 // 切如果提供了多个，其优先级为 uptoken &gt; uptoken_url &gt; uptoken_func // 其中 uptoken 是直接提供上传凭证，uptoken_url 是提供了获取上传凭证的地址，如果需要定制获取 uptoken 的过程则可以设置 uptoken_func uptoken : '&#123;&#123; $token &#125;&#125;', // uptoken 是上传凭证，由其他程序生成 // uptoken_url: '/uptoken', // Ajax 请求 uptoken 的 Url，**强烈建议设置**（服务端提供） // uptoken_func: function(file)&#123; // 在需要获取 uptoken 时，该方法会被调用 // // do something // return uptoken; // &#125;, get_new_uptoken: false, // 设置上传文件的时候是否每次都重新获取新的 uptoken // downtoken_url: '/downtoken', // Ajax请求downToken的Url，私有空间时使用,JS-SDK 将向该地址POST文件的key和domain,服务端返回的JSON必须包含`url`字段，`url`值为该文件的下载地址 unique_names: true, // 默认 false，key 为文件名。若开启该选项，JS-SDK 会为每个文件自动生成key（文件名） // save_key: true, // 默认 false。若在服务端生成 uptoken 的上传策略中指定了 `sava_key`，则开启，SDK在前端将不对key进行任何处理 domain: 'og3uiutra.bkt.clouddn.com', // bucket 域名，下载资源时用到，**必需** container: 'container', // 上传区域 DOM ID，默认是 browser_button 的父元素， max_file_size: '200mb', // 最大文件体积限制 flash_swf_url: 'http://cdn.staticfile.org/Plupload/2.1.1/Moxie.swf', //引入 flash,相对路径 max_retries: 3, // 上传失败最大重试次数 dragdrop: true, // 开启可拖曳上传 drop_element: 'container', // 拖曳上传区域元素的 ID，拖曳文件或文件夹后可触发上传 chunk_size: '4mb', // 分块上传时，每块的体积 auto_start: true, // 选择文件后自动上传，若关闭需要自己绑定事件触发上传, //x_vars : &#123; // 自定义变量，参考http://developer.qiniu.com/docs/v6/api/overview/up/response/vars.html // 'time' : function(up,file) &#123; // var time = (new Date()).getTime(); // do something with 'time' // return time; // &#125;, // 'size' : function(up,file) &#123; // var size = file.size; // do something with 'size' // return size; // &#125; //&#125;, init: &#123; 'FilesAdded': function(up, files) &#123; plupload.each(files, function(file) &#123; console.log(file); // 文件添加进队列后,处理相关的事情 &#125;); &#125;, 'BeforeUpload': function(up, file) &#123; // 每个文件上传前,处理相关的事情 &#125;, 'UploadProgress': function(up, file) &#123; console.log(file); console.log(file.percent); vm.percent = file.percent; vm.spead = file.spead; vm.loaded = file.loaded; // 每个文件上传时,处理相关的事情 &#125;, 'FileUploaded': function(up, file, info) &#123; // 每个文件上传成功后,处理相关的事情 // 其中 info 是文件上传成功后，服务端返回的json，形式如 // &#123; // "hash": "Fh8xVqod2MQ1mocfI4S4KpRL6D98", // "key": "gogopher.jpg" // &#125; // 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html // var domain = up.getOption('domain'); // var res = parseJSON(info); // var sourceLink = domain + res.key; 获取上传成功后的文件的Url alert('success') &#125;, 'Error': function(up, err, errTip) &#123; console.log(errTip); //上传出错时,处理相关的事情 &#125;, 'UploadComplete': function() &#123; //队列文件处理完毕后,处理相关的事情 &#125;, 'Key': function(up, file) &#123; // 若想在前端对每个文件的key进行个性化处理，可以配置该函数 // 该配置必须要在 unique_names: false , save_key: false 时才生效 var key = ""; // do something with key here return key &#125; &#125; &#125;); // domain 为七牛空间（bucket)对应的域名，选择某个空间后，可通过"空间设置-&gt;基本设置-&gt;域名设置"查看获取 // uploader 为一个 plupload 对象，继承了所有 plupload 的方法，参考http://plupload.com/docs&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里需要后台传给一个token,token内容是 这里 ,或者通过异步请求来token 这里有一个bug当七牛oss的存储空间选择的是华北区的话，目前版本(v1.0.17.1)需要修改以下js文件的上传地址，不然会出现 请求报文格式错误。(400：incorrect region, please use up-z1.qiniu.com) 报错，需要下载最新的(v1.0.17.1) qiniu.js 文件，同时要修改的地方如下，别的地方正常使用。1234567891011121314151617var qiniuUploadUrl; if (window.location.protocol === 'https:') &#123; qiniuUploadUrl = 'https://up.qbox.me'; &#125; else &#123; //qiniuUploadUrl = 'http://upload.qiniu.com'; qiniuUploadUrl = 'http://up-z1.qiniu.com'; &#125; /** * qiniu upload urls * 'qiniuUploadUrls' is used to change target when current url is not avaliable * @type &#123;Array&#125; */ var qiniuUploadUrls = [ "http://upload-z1.qiniu.com", "http://up-z1.qiniu.com" ];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小程序(2)]]></title>
      <url>%2F2016%2F11%2F07%2Fwxcx-2%2F</url>
      <content type="text"><![CDATA[由上篇博客可以了解小程序运行的一个大体过程,首先app.json进行配置路由和基本的样式调整,其次可以在对应的路由指向的目录下添加 .wxml .wxss .js 这三种文件,只要指定一个路径框架就会对他们自行加载 接下来我们开始了解小程序的一些细节问题: 注册程序在根目录下有app.js这个文件,里面涉及了小程序整体的一些事件响应,代码如下:123456789101112131415161718App(&#123; //当小程序初始化完成时，会触发onLaunch（全局只触发一次） onLaunch: function () &#123; console.log(&apos;App Launch&apos;) &#125;, //当小程序启动，或从后台进入前台显示，会触发onShow onShow: function () &#123; console.log(&apos;App Show&apos;) &#125;, //当小程序从前台进入后台，会触发onHide onHide: function () &#123; console.log(&apos;App Hide&apos;) &#125;, //以及其他的自定义的方法 globalData: &#123; hasLogin: false &#125;&#125;) 这里的前后台转换的前提都是系统没有将小程序销毁,要注意一个概念进入后台不意味着资源被销毁,只有进入后台有一段时间或者系统内存不足的时候小程序才会被回收资源 App() 这个函数是注册小程序的函数,我们进行的操作都是在它里面运行的 App.prototype.getCurrentPage()getCurrentPage()函数用户获取当前页面的实例。 getApp()我们提供了全局的getApp()函数，可以获取到小程序实例。 123// other.jsvar appInstance = getApp()console.log(appInstance.globalData) // I am global data 注意:App()必须在app.js中注册，且不能注册多个。 不要在定义于App()内的函数中调用getApp()，使用this就可以拿到app实例。 不要在onLaunch的时候调用getCurrentPage()，此时page还没有生成。 通过getApp获取实例之后，不要私自调用生命周期函数。 注册页面上篇博客的例子中我们也运用到了怎么对我们要构建的页面进行js操作,这里用到了Page()方法,里面的结果真的和Vue很像,简直就是它的简化版,这里给出了一些api123456789101112131415161718192021222324252627//index.jsPage(&#123; data: &#123; text: &quot;This is page data.&quot; &#125;, onLoad: function(options) &#123; // Do some initialize when page load. &#125;, onReady: function() &#123; // Do something when page ready. &#125;, onShow: function() &#123; // Do something when page show. &#125;, onHide: function() &#123; // Do something when page hide. &#125;, onUnload: function() &#123; // Do something when page close. &#125;, // Event handler. viewTap: function() &#123; this.setData(&#123; text: &apos;Set some data for updating view.&apos; &#125;) &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多维数组排序]]></title>
      <url>%2F2016%2F11%2F03%2Fphp-array-1%2F</url>
      <content type="text"><![CDATA[123456789101112131415$testArr = [ ['id'=&gt;1,'msg'=&gt;'aaa'], ['id'=&gt;2,'msg'=&gt;'bbb'], ['id'=&gt;3,'msg'=&gt;'ccc'], ['id'=&gt;4,'msg'=&gt;'ddd'], ];$roler = [2,1,3,4];usort($testArr,function($a,$b) use($roler)&#123; return (array_search($a['id'], $roler) &lt; array_search($b['id'], $roler)) ? -1 : 1;&#125;);var_dump($testArr);die(); 输出结果：反正成功了 还有就是 第一层要是索引数组]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git本地拉取远程分支]]></title>
      <url>%2F2016%2F10%2F28%2Fgit-pull%2F</url>
      <content type="text"><![CDATA[首先git clone一个git库，其次在本地新建一个分支1git checkout -b devlocal 然后设置本地git文件，将本地分支和远程分支关联起来 （我有个远程分支叫做dev）1git branch --set-upstream-to=origin/dev devlocal 再git pull 就能获取到远程git dev分支上的东西到本地的devlocal这个分支上了 还有一个是将本地分支推送到远程分支前要做的处理（远程不存在该分支）1git push --set-upstream origin new]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Yii2路由重写方案]]></title>
      <url>%2F2016%2F10%2F27%2Fyii-rewrite%2F</url>
      <content type="text"><![CDATA[yii2 关于 apache 和 nginx 的路由重写配置 apache路由重写12345678910Options +FollowSymLinksIndexIgnore */*RewriteEngine on# if a directory or a file exists, use it directlyRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-d# otherwise forward it to index.phpRewriteRule . index.php 从yiichina那里推荐的apache路由重写方案直接改服务器的配置文件影响太大了,我们需要把它限制在这个项目里,这样更方便操作了 需要开启 apache 的 rewrite 模块 参考了一下laravel的路由重写方案,首先在你的根目录下 your-app/web创建一个文件 .htaccess文件内容如下123456789&lt;IfModule mod_rewrite.c&gt; # 开启 mod_rewrite 用于美化 URL 功能的支持（译注：对应 pretty URL 选项） RewriteEngine on # 如果请求的是真实存在的文件或目录，直接访问 RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d # 如果请求的不是真实文件或目录，分发请求至 index.php RewriteRule . index.php&lt;/IfModule&gt; nginx路由重写12345location / &#123; if (!-e $request_filename)&#123; rewrite ^/(.*) /index.php last; &#125; &#125; conf/web.php 中的 ‘components’数组是这样的 123456&apos;urlManager&apos; =&gt; [ &apos;enablePrettyUrl&apos; =&gt; true, &apos;showScriptName&apos; =&gt; false, &apos;rules&apos; =&gt; [ ], ],]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小程序初次接触(1)]]></title>
      <url>%2F2016%2F10%2F24%2Fwxcx%2F</url>
      <content type="text"><![CDATA[刚开始接触vue.js没多久就收到小程序内侧的信息,看了看文档两者关联性很强,于是就两者一块学了 首先安装小程序的开发工具,虽然我们没有邀请id但是我们可以通过熟悉操作来达到快速上手,更多的功能体验可以等到正式发布的时候去进行拓展 安装微信开发工具下载网址 目录结构12345app----image---utils---pages---app.json 首先必备的就是app.json文件,这是小程序的配置文件,里面配置了路由,底部菜单,窗口标题等等一些最重要的东西123456789101112131415161718192021222324252627&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;微信小练习&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &#125;, &quot;tabBar&quot;: &#123; &quot;backgroundColor&quot;:&quot;#000000&quot;, &quot;list&quot;: [&#123; &quot;iconPath&quot;:&quot;image/wechat.png&quot;, &quot;selectedIconPath&quot;:&quot;image/wechatHL.png&quot;, &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;iconPath&quot;:&quot;image/record.png&quot;, &quot;selectedIconPath&quot;:&quot;image/play.png&quot;, &quot;pagePath&quot;: &quot;pages/about/about&quot;, &quot;text&quot;: &quot;我的&quot; &#125;] &#125;, &quot;debug&quot; : true&#125; 这个文件的内容可读性也是很不错,各个项目是做什么的让人一目了然, pages块的就是注册前端路由了,比如pages/index/index就是需要引用 pages/index 目录下的 index.wxml index.js index.wxss 我们不需要指定后缀,这都是自动完成的 其他的关于引入文件路径的问题都和这个是一类的 接下来就是关于页面的布局在 pages/index目录下创建 index.wxml文件12345678910111213141516&lt;!--文章列表模板 begin--&gt;&lt;template name=&quot;itmes&quot;&gt; &lt;view class=&quot;imgs&quot;&gt;&lt;image src=&quot;&#123;&#123;imgURL&#125;&#125;&quot; class=&quot;in-img&quot; background-size=&quot;cover&quot; model=&quot;scaleToFill&quot;&gt;&lt;/image&gt;&lt;/view&gt; &lt;view class=&quot;infos&quot;&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;date&quot;&gt;&#123;&#123;time&#125;&#125;&lt;/view&gt; &lt;view class=&quot;classification&quot;&gt;&#123;&#123;classification&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;view&gt;hello world&lt;/view&gt;&lt;/template&gt;&lt;!--文章列表模板 begin--&gt;&lt;block wx:for=&quot;&#123;&#123;newList&#125;&#125;&quot;&gt; &lt;template is=&quot;itmes&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot; /&gt;&lt;/block&gt; 在这里, &lt;template&gt;这标签块内的东西只是一个模板,而不会实际显示出来,真正显示的是下面 &lt;block&gt;这个标签对里的东西,他在这里调用了上面的 template 模板, 当然此时是没有东西的,因为我们指定的变量还没有建立 赶紧在同级目录下创建 index.js1234567891011121314151617//获取应用实例var app = getApp()Page(&#123; data: &#123; newList:[&#123;url:&quot;baidu.com&quot;,title:&quot;111&quot;,classification:&quot;ss&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;222&quot;,classification:&quot;ss&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;333&quot;,classification:&quot;12&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;444&quot;,classification:&quot;333&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;555&quot;,classification:&quot;44&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;666&quot;,classification:&quot;44&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;777&quot;,classification:&quot;32&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;888&quot;,classification:&quot;123&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;999&quot;,classification:&quot;456&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125;, &#123;url:&quot;baidu.com&quot;,title:&quot;000&quot;,classification:&quot;454&quot;,time:&quot;2016-10-17&quot;,imgURL:&quot;../../image/test.png&quot;&#125; ] &#125;,&#125;) 这个时候重新解析一下调试界面就能看到效果了,这个时候我们还没用到 .wxss 的文件,所以样式还是裸奔状态]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Larvel ORM模型中的一些方法和变量的作用]]></title>
      <url>%2F2016%2F10%2F21%2Flaravel-orm%2F</url>
      <content type="text"><![CDATA[用代码说话 相关命令： 创建迁移文件 php artisan make:migration Pate_table 进行迁移 php artisan migrate 创建模型文件 php artisan make:model Page 把如下文件内容复制到对应的文件下，就可以按照注释进行测试了。控制器的代码就需要自己动手一遍了，用一次就会了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class Page extends Model&#123; //可批量注入的字段 protected $fillable = ['*']; //不可批量注入的字段 protected $guarded = []; //声明时间字段,这些字段可以调用Carbon,dateTime实例 //如: //$page = Page::find(1); //dd($page-&gt;created_at-&gt;getTimestamp()); protected $dates = ['created_at', 'updated_at']; //设置时间字段属性// protected $dateFormat = 'U'; //当使用 toArray() 和 toJson() 时要隐藏的字段 protected $hidden = ['body']; //$hidden是隐藏 它是显示 两者存在一个就好// protected $visible = ['first_name', 'last_name']; //定义字段调用时的所用的格式 //比如下面的$page-&gt;body 将自动json转array 存储的时候array自动转json protected $casts = [ 'body' =&gt; 'array', ]; //append添加字段是当需要对数据添加不存在的字段的时候,在这里声明一下, //需要配合 getFooAttribute 方法使用, //注意:不要在这里写可调用的字段 // 比如下面的 getTitleAttribute 这个, //如果 $append 数组中存在 title的话则会因为获取不到 $value 参数去执行方法内容 且会将结果覆盖到原有的字段 protected $appends = ['other']; //当类似$page-&gt;title的时候调用该方法, //已发现的问题是在使用select foo as title的时候也会调用这个方法 public function getTitleAttribute($value) &#123; return strtolower($value).'+salt'; &#125; public function getOtherAttribute() &#123; return 'this is other ziduan'; &#125; //当添加或更新title字段的时候将调用该方法, //例如$page-&gt;title = 'foo'; foo将作为参数传递到这里, public function setTitleAttribute($value) &#123; $this-&gt;attributes['title'] = strtoupper($value); &#125;&#125; 相关的表结构如下：12345678910111213141516171819202122232425262728293031323334&lt;?phpuse Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;class CreatePagesTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::create('pages', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('title'); $table-&gt;string('slug')-&gt;nullable(); $table-&gt;text('body')-&gt;nullable(); $table-&gt;integer('user_id'); $table-&gt;timestamps(); &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::drop('pages'); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Webuploader插件]]></title>
      <url>%2F2016%2F10%2F12%2Fwebupload-demo%2F</url>
      <content type="text"><![CDATA[通过这个插件让我感觉到大百度还仍然是技术公司 说了句废话,开始正题.这里用的是插件提供的源码 插件官网传送门 demo就是拿的源码的 image-upload 示例,就是把代码中我们需要了解的给摘了出来 html代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;WebUploader演示&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; asset(&apos;webuploaderDemo/css/webuploader.css&apos;) &#125;&#125;&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; asset(&apos;webuploaderDemo/examples/image-upload/style.css&apos;) &#125;&#125;&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;wrapper&quot;&gt; &lt;h1 id=&quot;stopBtn&quot;&gt;暂停&lt;/h1&gt; &lt;h1 id=&quot;continueBtn&quot;&gt;继续&lt;/h1&gt; &lt;h1 id=&quot;cancleBtn&quot; attr=&quot;&quot;&gt;取消&lt;/h1&gt; &lt;div id=&quot;container&quot;&gt; &lt;!--头部，相册选择和格式选择--&gt; &lt;div id=&quot;uploader&quot;&gt; &lt;div class=&quot;queueList&quot;&gt; &lt;div id=&quot;dndArea&quot; class=&quot;placeholder&quot;&gt; &lt;div id=&quot;filePicker&quot;&gt;&lt;/div&gt; &lt;p&gt;或将文件拖动到这里,支持格式:mp4,rmvb,上限3个&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;statusBar&quot; style=&quot;display:none;&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;span class=&quot;text&quot;&gt;0%&lt;/span&gt; &lt;span class=&quot;percentage&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;info&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btns&quot;&gt; &lt;div id=&quot;filePicker2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;uploadBtn&quot;&gt;暂停&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; asset(&apos;webuploaderDemo/examples/image-upload/jquery.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; asset(&apos;webuploaderDemo/dist/webuploader.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; asset(&apos;webuploaderDemo/examples/image-upload/upload3.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254(function( $ )&#123; // 当domReady的时候开始初始化 $(function() &#123; var $wrap = $(&apos;#uploader&apos;), // 图片容器 $queue = $( &apos;&lt;ul class=&quot;filelist&quot;&gt;&lt;/ul&gt;&apos; ) .appendTo( $wrap.find( &apos;.queueList&apos; ) ), // 状态栏，包括进度和控制按钮 $statusBar = $wrap.find( &apos;.statusBar&apos; ), // 文件总体选择信息。 $info = $statusBar.find( &apos;.info&apos; ), // 上传按钮 $upload = $wrap.find( &apos;.uploadBtn&apos; ), // 没选择文件之前的内容。 $placeHolder = $wrap.find( &apos;.placeholder&apos; ), $progress = $statusBar.find( &apos;.progress&apos; ).hide(), // 添加的文件数量 fileCount = 0, // 添加的文件总大小 fileSize = 0, // 优化retina, 在retina下这个值是2 ratio = window.devicePixelRatio || 1, // 缩略图大小 thumbnailWidth = 110 * ratio, thumbnailHeight = 110 * ratio, // 可能有pedding, ready, uploading, confirm, done. state = &apos;pedding&apos;, // 所有文件的进度信息，key为file id percentages = &#123;&#125;, // 判断浏览器是否支持图片的base64 isSupportBase64 = ( function() &#123; var data = new Image(); var support = true; data.onload = data.onerror = function() &#123; if( this.width != 1 || this.height != 1 ) &#123; support = false; &#125; &#125; data.src = &quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==&quot;; return support; &#125; )(), // 检测是否已经安装flash，检测flash的版本 flashVersion = ( function() &#123; var version; try &#123; version = navigator.plugins[ &apos;Shockwave Flash&apos; ]; version = version.description; &#125; catch ( ex ) &#123; try &#123; version = new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;) .GetVariable(&apos;$version&apos;); &#125; catch ( ex2 ) &#123; version = &apos;0.0&apos;; &#125; &#125; version = version.match( /\d+/g ); return parseFloat( version[ 0 ] + &apos;.&apos; + version[ 1 ], 10 ); &#125; )(), supportTransition = (function()&#123; var s = document.createElement(&apos;p&apos;).style, r = &apos;transition&apos; in s || &apos;WebkitTransition&apos; in s || &apos;MozTransition&apos; in s || &apos;msTransition&apos; in s || &apos;OTransition&apos; in s; s = null; return r; &#125;)(), // WebUploader实例 uploader; if ( !WebUploader.Uploader.support(&apos;flash&apos;) &amp;&amp; WebUploader.browser.ie ) &#123; // flash 安装了但是版本过低。 if (flashVersion) &#123; (function(container) &#123; window[&apos;expressinstallcallback&apos;] = function( state ) &#123; switch(state) &#123; case &apos;Download.Cancelled&apos;: alert(&apos;您取消了更新！&apos;) break; case &apos;Download.Failed&apos;: alert(&apos;安装失败&apos;) break; default: alert(&apos;安装已成功，请刷新！&apos;); break; &#125; delete window[&apos;expressinstallcallback&apos;]; &#125;; var swf = &apos;./expressInstall.swf&apos;; // insert flash object var html = &apos;&lt;object type=&quot;application/&apos; + &apos;x-shockwave-flash&quot; data=&quot;&apos; + swf + &apos;&quot; &apos;; if (WebUploader.browser.ie) &#123; html += &apos;classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; &apos;; &#125; html += &apos;width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline:0&quot;&gt;&apos; + &apos;&lt;param name=&quot;movie&quot; value=&quot;&apos; + swf + &apos;&quot; /&gt;&apos; + &apos;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;&apos; + &apos;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&apos; + &apos;&lt;/object&gt;&apos;; container.html(html); &#125;)($wrap); // 压根就没有安转。 &#125; else &#123; $wrap.html(&apos;&lt;a href=&quot;http://www.adobe.com/go/getflashplayer&quot; target=&quot;_blank&quot; border=&quot;0&quot;&gt;&lt;img alt=&quot;get flash player&quot; src=&quot;http://www.adobe.com/macromedia/style_guide/images/160x41_Get_Flash_Player.jpg&quot; /&gt;&lt;/a&gt;&apos;); &#125; return; &#125; else if (!WebUploader.Uploader.support()) &#123; alert( &apos;Web Uploader 不支持您的浏览器！&apos;); return; &#125; // 实例化 uploader = WebUploader.create(&#123; auto: true, //开启自动上传 pick: &#123; //点击选择文件按钮 id: &apos;#filePicker&apos;, label: &apos;点击选择文件&apos;, multiple : false //是否开起同时选择多个文件能力。 &#125;, formData: &#123; //上传时的文本内容 uid: 5173180, filename : &apos;filename_test&apos; &#125;, dnd: &apos;#dndArea&apos;, //文件可拖拽范围 paste: &apos;#uploader&apos;, //可通过粘贴添加到文件框内 swf: &apos;../../dist/Uploader.swf&apos;, //flash文件 chunked: true, //开启分片上传 chunkSize: 512 * 1024, //分片大小 512k server : &apos;http://testlaravel/web/uploader&apos;, //后端处理函数 // runtimeOrder: &apos;flash&apos;, accept: &#123; //限制文件类型 title: &apos;Video&apos;, extensions: &apos;mp4,rmvb&apos;, mimeTypes: &apos;video/*&apos; &#125;, disableGlobalDnd: true, // 禁掉全局的拖拽功能。这样不会出现图片拖进页面的时候，把图片打开。 fileNumLimit: 1, //限制上传一个文件 fileSizeLimit: 1024 * 1024 * 1024, // 1 G fileSingleSizeLimit: 1024 * 1024 * 1024, // 单个最大文件 1G method : &apos;POST&apos; //指定上传方法 &#125;); //// 拖拽时不接受 js, txt 文件。 uploader.on( &apos;dndAccept&apos;, function( items ) &#123; var denied = false, len = items.length, i = 0, // 修改js类型 unAllowed = &apos;text/plain;application/javascript &apos;; for ( ; i &lt; len; i++ ) &#123; // 如果在列表里面 if ( ~unAllowed.indexOf( items[ i ].type ) ) &#123; denied = true; break; &#125; &#125; return !denied; &#125;); var oldTime = new Date().getTime(); uploader.on( &apos;uploadProgress&apos;, function( file, percentage ) &#123; console.log(&apos;上传进度:&apos;+ percentage * 100 + &apos;%&apos;); var currentTime = new Date().getTime(); var cha = currentTime - oldTime; var chunkSize = 512; //设置网速 var ws = (chunkSize/cha)*1000; console.log(&apos;当前网速:&apos; + ws + &apos;kb/s&apos;); oldTime = currentTime; &#125;); //接收服务器返回信息 //这里才是接收服务器信息的地方,如果有出错就 `return false` 来停止上传 uploader.on( &apos;uploadAccept&apos;, function( file, response ) &#123; var str = response._raw; var info = eval(&apos;(&apos; + str + &apos;)&apos;); console.log(info); //if ( hasError ) &#123; // // 通过return false来告诉组件，此文件上传有错。 // return false; //&#125; &#125;); uploader.onFileQueued = function( file ) &#123; console.log(&apos;添加文件动作&apos;); $(&apos;#cancleBtn&apos;).attr(&#123;&apos;attr&apos;: file.id&#125;); &#125;; uploader.onUploadFinished = function()&#123; console.log(&apos;完成上传&apos;); &#125; $(&apos;#stopBtn&apos;).on( &apos;click&apos;, function() &#123; console.log(&quot;暂停上传...&quot;); uploader.stop(true); &#125;); $(&apos;#continueBtn&apos;).on( &apos;click&apos;, function() &#123; console.log(&quot;继续&quot;); uploader.upload(); &#125;); $(&apos;#cancleBtn&apos;).on( &apos;click&apos;, function() &#123; console.log(&quot;取消上传&quot;); var id = $(this).attr(&apos;attr&apos;); //指定取消的文件id uploader.cancelFile(id); &#125;); &#125;);&#125;)( jQuery ); 后端php部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public function testSaveWebUploader(Request $request)&#123; //强制浏览器不缓存 header(&quot;Expires: Mon, 26 Jul 1997 05:00:00 GMT&quot;); header(&quot;Last-Modified: &quot; . gmdate(&quot;D, d M Y H:i:s&quot;) . &quot; GMT&quot;); header(&quot;Cache-Control: no-store, no-cache, must-revalidate&quot;); header(&quot;Cache-Control: post-check=0, pre-check=0&quot;, false); header(&quot;Pragma: no-cache&quot;); //指定提交方式 if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &apos;OPTIONS&apos;) &#123; exit; // finish preflight CORS requests here &#125; //当出现debug判断服务器报错 if ( !empty($_REQUEST[ &apos;debug&apos; ]) ) &#123; $random = rand(0, intval($_REQUEST[ &apos;debug&apos; ]) ); if ( $random === 0 ) &#123; header(&quot;HTTP/1.0 500 Internal Server Error&quot;); exit; &#125; &#125; @set_time_limit(5 * 60); //临时文件夹和存放文件的文件夹 $targetDir = &apos;upload_tmp&apos;; $uploadDir = &apos;upload&apos;; $cleanupTargetDir = true; // Remove old files $maxFileAge = 5 * 3600; // Temp file age in seconds // 检测文件夹是否存在 if (!file_exists($targetDir)) &#123; @mkdir($targetDir); &#125; if (!file_exists($uploadDir)) &#123; @mkdir($uploadDir); &#125; // 重新设置文件名 $fileName = $this-&gt;renameFile(); $filePath = $targetDir . DIRECTORY_SEPARATOR . $fileName; $uploadPath = $uploadDir . DIRECTORY_SEPARATOR . $fileName; // 是否分片 $chunk = isset($_REQUEST[&quot;chunk&quot;]) ? intval($_REQUEST[&quot;chunk&quot;]) : 0; $chunks = isset($_REQUEST[&quot;chunks&quot;]) ? intval($_REQUEST[&quot;chunks&quot;]) : 1; // 删除过期文件 if ($cleanupTargetDir) &#123; if (!is_dir($targetDir) || !$dir = opendir($targetDir)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 100, &quot;message&quot;: &quot;Failed to open temp directory.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; while (($file = readdir($dir)) !== false) &#123; $tmpfilePath = $targetDir . DIRECTORY_SEPARATOR . $file; // 忽略当前临时文件 if ($tmpfilePath == &quot;&#123;$filePath&#125;_&#123;$chunk&#125;.part&quot; || $tmpfilePath == &quot;&#123;$filePath&#125;_&#123;$chunk&#125;.parttmp&quot;) &#123; continue; &#125; // 过期文件删除 if (preg_match(&apos;/\.(part|parttmp)$/&apos;, $file) &amp;&amp; (@filemtime($tmpfilePath) &lt; time() - $maxFileAge)) &#123; @unlink($tmpfilePath); &#125; &#125; closedir($dir); &#125; // 打开缓存文件 if (!$out = @fopen(&quot;&#123;$filePath&#125;_&#123;$chunk&#125;.parttmp&quot;, &quot;wb&quot;)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 102, &quot;message&quot;: &quot;Failed to open output stream.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; if (!empty($_FILES)) &#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;] || !is_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;])) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 103, &quot;message&quot;: &quot;Failed to move uploaded file.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; // Read binary input stream and append it to temp file if (!$in = @fopen($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;rb&quot;)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 101, &quot;message&quot;: &quot;Failed to open input stream.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; &#125; else &#123; if (!$in = @fopen(&quot;php://input&quot;, &quot;rb&quot;)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 101, &quot;message&quot;: &quot;Failed to open input stream.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; &#125; while ($buff = fread($in, 4096)) &#123; fwrite($out, $buff); &#125; @fclose($out); @fclose($in); //重命名文件名 rename(&quot;&#123;$filePath&#125;_&#123;$chunk&#125;.parttmp&quot;, &quot;&#123;$filePath&#125;_&#123;$chunk&#125;.part&quot;); $index = 0; $done = true; for( $index = 0; $index &lt; $chunks; $index++ ) &#123; if ( !file_exists(&quot;&#123;$filePath&#125;_&#123;$index&#125;.part&quot;) ) &#123; $done = false; break; &#125; &#125; if ( $done ) &#123; if (!$out = @fopen($uploadPath, &quot;wb&quot;)) &#123; die(&apos;&#123;&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : &#123;&quot;code&quot;: 102, &quot;message&quot;: &quot;Failed to open output stream.&quot;&#125;, &quot;id&quot; : &quot;id&quot;&#125;&apos;); &#125; if ( flock($out, LOCK_EX) ) &#123; for( $index = 0; $index &lt; $chunks; $index++ ) &#123; if (!$in = @fopen(&quot;&#123;$filePath&#125;_&#123;$index&#125;.part&quot;, &quot;rb&quot;)) &#123; break; &#125; while ($buff = fread($in, 4096)) &#123; fwrite($out, $buff); &#125; @fclose($in); @unlink(&quot;&#123;$filePath&#125;_&#123;$index&#125;.part&quot;); &#125; flock($out, LOCK_UN); &#125; @fclose($out); die(&quot;&#123;&apos;jsonrpc&apos; : &apos;2.0&apos;, &apos;result&apos; : &apos;done&apos;, &apos;chunk&apos; : &apos;&#123;$chunk&#125;&apos;, &apos;chunks&apos;: &apos;&#123;$chunks&#125;&apos;&#125;&quot;); &#125; // Return Success JSON-RPC response die(&quot;&#123;&apos;jsonrpc&apos; : &apos;2.0&apos;, &apos;result&apos; : &apos;success&apos;, &apos;chunk&apos; : &apos;&#123;$chunk&#125;&apos;, &apos;chunks&apos;: &apos;&#123;$chunks&#125;&apos;&#125;&quot;); &#125; protected function renameFile()&#123; //获取后缀 $ext = pathinfo($_FILES[&quot;file&quot;][&quot;name&quot;], PATHINFO_EXTENSION); //文件名 if (isset($_REQUEST[&quot;name&quot;])) &#123; $fileName = isset($_REQUEST[&quot;filename&quot;]) ? $_REQUEST[&quot;filename&quot;] : $_REQUEST[&quot;name&quot;]; &#125; elseif (!empty($_FILES)) &#123; $fileName = $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125; else &#123; $fileName = uniqid(&quot;file_&quot;); &#125; $key = isset($_REQUEST[&apos;uid&apos;]) ? $_REQUEST[&apos;uid&apos;] : &apos;hotcast&apos;; $fileName = md5($fileName.$key); return $fileName.&apos;.&apos;.$ext; &#125; 最后相关的代码已经贴出来了,事件调用在js部分找,后端处理的大体思路就是保存分片上传过来的文件,当文件上传完毕后就通过fwrite或者file_put_content这类的函数给按顺序怼到一个文件当中//如果真的懒需要源码的话 我这有 , 写在了laravel框架里面了,但是代码可以单独拿出来,依赖性并不高]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js获取地址信息]]></title>
      <url>%2F2016%2F10%2F10%2Fjs-href%2F</url>
      <content type="text"><![CDATA[js获取api的一系列API接口12345window.location.hostdocument.domain(vue下会发生错误)//全地址window.location.href 补充:获取当前域名信息 代码如下123456789thisTLoc = top.location.href;thisPLoc = parent.document.location;thisTHost = top.location.hostname;thisHost = location.hostname;strwrite = ” thisTLoc: [" + thisTLoc + "]”strwrite += ” thisPLoc: [" + thisPLoc + "]”strwrite += ” thisTHost: [" + thisTHost + "]”strwrite += ” thisHost: [" + thisHost + "]”document.write( strwrite );]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Laravel的定时任务]]></title>
      <url>%2F2016%2F10%2F09%2Flaravel-cron%2F</url>
      <content type="text"><![CDATA[了解下 laravel 定时任务是怎么使用的首先在linux上创建一个crontab命令.crontab -e第一次用的时候会选择编辑器,默认nano然后在crontab文件中添加一行命令:1***** php /path/to/artisan schedule:run 1&gt;&gt;/dev/null2&gt;&amp;1 linux上的操作就完毕了,接下来是在框架中的操作: 在 app/Console/Kernel.php文件中12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\Console;use Illuminate\Console\Scheduling\Schedule;use Illuminate\Foundation\Console\Kernel as ConsoleKernel;use App\Http\Controllers\SystemConf\SiteVisitorController;class Kernel extends ConsoleKernel&#123;/** * The Artisan commands provided by your application. * * @var array */protected $commands = [//这里是注册自定义命令的,如果不想调用控制器方法就把cron任务写到命令中,也是很方便Commands\Inspire::class, ];/** * Define the application's command schedule. * * @param \Illuminate\Console\Scheduling\Schedule $schedule * @return void */protected function schedule(Schedule $schedule)&#123; //这条命令是测试用的,通过检查是否添加了数据迁移文件来看cron是否已经正常运行 $schedule-&gt;command('make:migration test') //-&gt;everyMinute() //每分钟执行 -&gt;cron('* * * * *'); //linux上cronTab的周期格式 //当调用控制器的方法的时候,一定要把命名空间写全,不然是找不到的, //在文件中用了 use 也没用,因为传入的是字符串 $schedule-&gt;call('App\Http\Controllers\SystemConf\SiteVisitorController@test') -&gt;cron('* * * * *');&#125; 这里仅仅是用artisan命令做了一个测试,实际也可以调用服务,有了这个例子再结合文档来看对小白来说估计就稍微不那么蒙圈了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Laravel的报错处理]]></title>
      <url>%2F2016%2F10%2F09%2Flaravel-error%2F</url>
      <content type="text"><![CDATA[有很多时候我们需要有404 500 这类的错误页面,在逻辑层里写这些又有些太繁琐,干脆从上游去搞一下 在 app/exceptions/handler.php中 判定$e是属于 http异常还是其他的类似model或者pdo异常，这样就根据异常的类型返回对应的页面，http异常就返回404（其实可以按照状态码分好多） 服务器异常不想显示报错信息就返回一个页面这样的 如果为了方便开发时查看报错信息，需要再添加一层输出debug的配置判定12345678910111213141516171819202122232425/** * Render an exception into an HTTP response. * * @param \Illuminate\Http\Request $request * @param \Exception $e * @return \Illuminate\Http\Response */public function render($request, Exception $e)&#123;// return parent::render($request, $e); if(Config('app.debug'))&#123; if ($e instanceof ModelNotFoundException) &#123; $e = new NotFoundHttpException($e-&gt;getMessage(), $e); &#125; return parent::render($request, $e); &#125; if($e instanceof NotFoundHttpException) &#123; return response()-&gt;view('errors.404', ['message'=&gt;'找不到页面'], 404); &#125; else &#123; return response()-&gt;view('errors.500', ['message'=&gt;'服务器发生未知错误'], 500); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue的初识]]></title>
      <url>%2F2016%2F10%2F09%2Fvue-1%2F</url>
      <content type="text"><![CDATA[照着下面的代码打一遍体会一下vue的优雅1234567891011121314151617181920212223242526272829&lt;div class="mytest"&gt;&#123;&#123;--直接调取js中定义好的值--&#125;&#125;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&#123;&#123;--和模型绑定,这样的话输入框和上面的值能够同步更改--&#125;&#125;&lt;input v-model="message"&gt; &lt;ul&gt;&#123;&#123;--vue中的遍历,和php的遍历相反, items是这个模型中存入的值,todo是遍历出来的单个元素,--&#125;&#125;&lt;li v-for="todo in items"&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123;// 这里是筛选器获取目标classel: '.mytest',// 这里是目标中的变量和变量值,json格式数据data: &#123;message:'this is my test',items: [ &#123;text:'first'&#125;,&#123;text:'second'&#125;,&#123;text:'third'&#125;,] &#125; &#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[laravel5.1使用stmp邮箱服务]]></title>
      <url>%2F2016%2F10%2F09%2Flaravel-stmp%2F</url>
      <content type="text"><![CDATA[这里主要使用的qq邮箱来举例 流程:登录qq邮箱-&gt;进入账户设置-&gt;开通stmp服务 laravel配置.env文件当中：123456MAIL_DRIVER=smtp //服务驱动MAIL_HOST=smtp.qq.com //服务器地址MAIL_PORT=465 //端口MAIL_USERNAME=5173180@qq.com //账户MAIL_PASSWORD=fgxhrahbayzvcai //你账户的授权码，在开通stmp服务的时候获取到MAIL_ENCRYPTION=ssl //安全协议 以上的内容如果不因环境变化可直接写入到config/mail.php文件内config/mail.php内要修改的1&apos;from&apos; =&gt; [&apos;address&apos; =&gt; &apos;5173180@qq.com&apos;, &apos;name&apos; =&gt; &apos;GsMail&apos;], 这样基本配置就算配置好了 测试一下使用 php artisan tinker12345 Mail::send('emails.test',['testVar'=&gt;'LaravelAcademy.org'], function($message)&#123; $message-&gt;to('5173180@qq.com')-&gt;subject('测试邮件 '); &#125;); send的参数分别是发送过去的邮件视图，向邮件视图内绑定的参数，一个回调函数$message变量在视图模板当中恒定存在相关$message的方法有：12345678910111213$message-&gt;from($address, $name = null);$message-&gt;sender($address, $name = null);$message-&gt;to($address, $name = null);$message-&gt;cc($address, $name = null);$message-&gt;bcc($address, $name = null);$message-&gt;replyTo($address, $name = null);$message-&gt;subject($subject);$message-&gt;priority($level);$message-&gt;attach($pathToFile, array $options = []);// 从$data字符串追加文件...$message-&gt;attachData($data, $name, array $options = []);// 获取底层SwiftMailer消息实例...$message-&gt;getSwiftMessage();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[唉~被Ie坑了一次又一次]]></title>
      <url>%2F2016%2F10%2F08%2Ffuck-ie%2F</url>
      <content type="text"><![CDATA[最近的网站项目当中用上了vue,结果ie低版本的不支持es5的写法,导致各种报错,而且一些很实用的api也不能用了..还有webGL的支持也是让人心碎,于是乎就有了下面的一段代码1234567891011121314$uarowser=$_SERVER['HTTP_USER_AGENT'];if(strstr($uarowser, 'MSIE 6') || strstr($uarowser, 'MSIE 7') || strstr($uarowser, 'MSIE 8'))&#123;echo '&lt;div id="ie-alertBox"&gt;&lt;div id="ie-infoBar"&gt;&lt;h1&gt;对不起，本站不支持低版本ie浏览器！&lt;/h1&gt;&lt;p&gt;请使用ie9或更高的版本&lt;/p&gt;&lt;p&gt;试试火狐啊谷歌什么的超好用的，如果你对IE是真爱......那么请关闭本站吧。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="ie-overlay"&gt;&lt;/div&gt;&lt;style type="text/css"&gt;#ie-alertBox&#123;width: 600px;margin-top: 160px;margin-right: auto;margin-bottom: 0px;margin-left: auto;padding: 20px;border: 1px solid #CCCCCC;text-align: center;font-family: "Microsoft YaHei", Verdana, sans-serif; line-height: 30px;&#125; #ie-infoBar h1&#123;font-size: 22px;color: #ff0000;line-height: 60px;&#125;&lt;/style&gt;';exit;&#125; 当使用万恶的ie的时候可以加上下面段1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; 优先使用chrome渲染,如果碰到ie就用浏览器支持的最高版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F10%2F07%2Fhello-world%202%2F</url>
      <content type="text"><![CDATA[接触编程输出的第一句话就是hello world,这是信仰;终于决定整个博客写点东西了,这里的主要用处就是发牢骚和记录点日常收获;向着大牛匍匐前进;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Laravel-Session]]></title>
      <url>%2F2016%2F06%2F01%2Flaravel-session%2F</url>
      <content type="text"><![CDATA[前置条件首先需要有redis的支持 session_driver=database 的另说 1composer require predis/predis 1.0.* 文件配置在.env 文件下的app_key1234APP_KEY=Lajq5EFWYq1COgmgltYM5TlSfRaTxLq1CACHE_DRIVER=redisSESSION_DRIVER=redis config/database.php1234567891011121314'redis' =&gt; [ 'cluster' =&gt; false, //...其它一些配置...// 'session' =&gt; [ 'host' =&gt; env('REDIS_HOST', '8b9a53cd4dc044e7.redis.rds.aliyuncs.com'), 'port' =&gt; 6379, 'database' =&gt; 4, 'password' =&gt; env('REDIS_PASSWORD', 'Hotcast123'), ], ], config/session.php1234567'driver' =&gt; env('SESSION_DRIVER', 'file'),//向指定当session驱动使用redis时指定redis的配置方案（就是上面的那个数组）'connection' =&gt; 'session',//必须指定共同的域名 否则session无法共享'domain' =&gt; '.yourWebName.com', config/cache.php12345'redis' =&gt; [ 'driver' =&gt; 'redis', //这里就是将cache和session的redis配置共用 'connection' =&gt; 'session', ], 示例在 a.yourWebName.com 的route.php12345678Route::get('/test-set-cache-session',function()&#123; Cache::put('cache1','cache1-value',1); Cache::put('cache2','cache2-value',1); Session::put('session1','session1-value',1); Session::put('session2','session2-value',1); return Session::getId();&#125;);//此条路由分别用 Cache 设置两条数据和两条 Session 数据，最后返回 SessionId 在 b.yourWebName.com 的route.php中1234567891011Route::get('/test-get-cache-session',function()&#123; $data = [ 'cache1'=&gt;Cache::get('cache1'), 'cache2'=&gt;Cache::get('cache2'), 'session1'=&gt;Session::get('session1'), 'session2'=&gt;Session::get('session2'), 'session_id'=&gt;Session::getId() ]; return $data;&#125;);//此条路由分别获取获取两条 Cache 数据和两条 Session 数据及 SessionId ,最后返回数据 总结同步session有以下关键点： app_key两者要一样 session配置指向的redis库要一样，这样方便两个程序找到共享的session位置 所属项目需要支持redis扩展包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Laravel-Repository]]></title>
      <url>%2F2016%2F04%2F01%2Flaravel-repository%2F</url>
      <content type="text"><![CDATA[laravel版本5.1+ 首先创建测试文件1php artisan make:controller TestController 修改路由文件route.php或者routes/web.php1Route::get('test', 'TestController@index'); 创建服务提供者文件,这个文件的作用就是用来注册自定义的服务容器1php artisan make:provider HelloProvider 我们再创建一个容器文件夹app/Repositories这里存放相应的接口和应用类，现在上我们的主角12345678910111213141516&lt;?php//app/Repositories/Hello.php/** * Created by PhpStorm. * User: gpf * Date: 2016/12/18 * Time: 下午9:30 */namespace App\Repositories;interface Hello&#123; function say();&#125; 123456789101112131415161718&lt;?php//app/Repositories/HelloRepository.php/** * Created by PhpStorm. * User: gpf * Date: 2016/12/18 * Time: 下午9:17 */ namespace App\Repositories;class HelloRepository implements Hello&#123; public function say()&#123; return 'hello baby'; &#125;&#125; 还记得刚才我们创建的HelloProvider吗？现在我们在这里注册一下服务1234567891011121314151617181920212223242526272829&lt;?php//app/Provider/HelloProvider.phpnamespace App\Providers;use Illuminate\Support\ServiceProvider;use App\Repositories\Hello;class HelloProvider extends ServiceProvider&#123; /** * Bootstrap the application services. * * @return void */ public function boot() &#123; // &#125; /** * Register the application services. * * @return void */ public function register() &#123; $this-&gt;app-&gt;bind('App\Repositories\Hello','App\Repositories\HelloRepository'); &#125;&#125; 接下来是最重要的一步，那就是去注册这个服务，你发现每次安装一个依赖包的时候都会操作一个文件，那就是config/app.php，在providers这个数组中添加服务1234'providers' =&gt; [ //other providers... App\Providers\HelloProvider::class, ], 现在就可以使用这个啦！进入我们的TestController1234567891011121314151617181920&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;use App\Repositories\Hello;class TestController extends Controller&#123; public $provider = null; public function __construct(Hello $hello) &#123; $this-&gt;provider = $hello; &#125; public function index()&#123; return $this-&gt;provider-&gt;say(); &#125;&#125; 访问 http://your-domain/test就能看到效果了 这里要记住，我们在控制器中调用的是接口，而接口已经通过provider已经注册绑定了一个符合接口规范的实例，这样的话我们只调用接口提供的外部方法，这样一个好处就是在控制器中我们就专注流程，具体的实现交给服务，内部需要什么依赖就服务自己去解决，而且服务是通用的，每个控制器都能调用，代码的可复用性和可维护性，这一点项目初期可能会感觉不到，但是一旦发生变动的时候，重复改动的地方就会非常多，项目经营时间越长这个变动的代价就会越高 试想一下，如果你是每个controller中都写相同的调度逻辑，有一天你的产品经理对你说：这里这里改一下，添加个字段而已很简单的……你会不会有砍死他的冲动？如果用上了服务仓库，你完全可以先看一下仓库中需要改动的方法到底怎么样再考虑砍人的事情 ：）]]></content>
    </entry>

    
  
  
</search>
