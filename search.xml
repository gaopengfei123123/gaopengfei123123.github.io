<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker中 Arg 和 Env 的区别]]></title>
    <url>%2F2018%2F06%2F28%2Fdocker-arg-env%2F</url>
    <content type="text"><![CDATA[在使用 docker-compoe 构建镜像的时候会感觉 ARG 和 ENV 的作用很相似, 但是这两个存在就肯定有它的原因 它们起作用的时机 arg 是在 build 的时候存在的, 可以在 Dockerfile 中当做变量来使用 env 是容器构建好之后的环境变量, 不能在 Dockerfile 中当参数使用 从这里可以看出来 ARG 就是专门为构建镜像而生的 拿一个具体的例子12345678910111213# DockerfileFROM redis:3.2-alpineLABEL maintainer="GPF &lt;5173180@qq.com&gt;"ARG REDIS_SET_PASSWORD=developerENV REDIS_PASSWORD $&#123;REDIS_SET_PASSWORD&#125;VOLUME /dataEXPOSE 6379CMD ["sh", "-c", "exec redis-server --requirepass \"$REDIS_PASSWORD\""] 这是一个构建 redis 的文件, 中间有这么一句12ARG REDIS_SET_PASSWORD=developerENV REDIS_PASSWORD $&#123;REDIS_SET_PASSWORD&#125; 它是为1CMD ["sh", "-c", "exec redis-server --requirepass \"$REDIS_PASSWORD\""] 这一句服务的, 这句就是在启动 redis 的时候设置密码, 因为当执行 CMD 的时候,说明容器已经构建成功运行了起来,此时 CMD是在容器中执行容器中的命令, 因此 CMD 中的变量是用的环境变量而不是在 Dockerfile 中的变量,因此需要把 ARG 中的值在构建的时候赋值给 ENV 另一个使用 ARG 的例子1234567891011121314151617181920212223FROM nginx:1.13.1-alpineLABEL maintainer="GPF &lt;5173180@qq.com&gt;"#https://yeasy.gitbooks.io/docker_practice/content/image/build.htmlRUN mkdir -p /etc/nginx/cert \ &amp;&amp; mkdir -p /etc/nginx/conf.d \ &amp;&amp; mkdir -p /etc/nginx/sitesCOPY ./nginx.conf /etc/ngixn/nginx.confCOPY ./conf.d/ /etc/nginx/conf.d/COPY ./cert/ /etc/nginx/cert/COPY ./sites /etc/nginx/sites/ARG PHP_UPSTREAM_CONTAINER=php-fpmARG PHP_UPSTREAM_PORT=9000RUN echo "upstream php-upstream &#123; server $&#123;PHP_UPSTREAM_CONTAINER&#125;:$&#123;PHP_UPSTREAM_PORT&#125;; &#125;" &gt; /etc/nginx/conf.d/upstream.confVOLUME ["/var/log/nginx", "/var/www"]WORKDIR /usr/share/nginx/html 这里就只是用了ARG123ARG PHP_UPSTREAM_CONTAINER=php-fpmARG PHP_UPSTREAM_PORT=9000RUN echo "upstream php-upstream &#123; server $&#123;PHP_UPSTREAM_CONTAINER&#125;:$&#123;PHP_UPSTREAM_PORT&#125;; &#125;" &gt; /etc/nginx/conf.d/upstream.conf 这里的变量用的就是 ARG 而不是 ENV了,因为这条命令运行在 Dockerfile 当中的, 像这种临时使用一下的变量没必要存环境变量的值就很适合使用 ARG]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-composer</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git调整 Ssh 登录参数]]></title>
    <url>%2F2018%2F06%2F23%2Fgit-sshcommand%2F</url>
    <content type="text"><![CDATA[指定 ssh 命令使用时的签名文件进入 app的.git/config 文件下12345678910111213141516 Engine:[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true # 添加一行这个就行 sshCommand = ssh -i ~/.ssh/id_rsa_gayhuber[remote "origin"] url = git@github.com:gayhuber/php-fpm.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 Gii 模板]]></title>
    <url>%2F2018%2F05%2F23%2Fyii-gii%2F</url>
    <content type="text"><![CDATA[开发是需要用到 gii,但是 gii 并不是完全符合自己的开发需求,所以需要对他做一点改造 这里先拿 basic 版举例, advance版同理 1.修改配置文件 web.php12345678910111213141516171819202122232425262728// file path: @app/config/web.phpif (YII_ENV_DEV) &#123; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'debug'; $config['modules']['debug'] = [ 'class' =&gt; 'yii\debug\Module', ]; $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'yii\gii\Module', // 这里把原来的 model generator 给覆盖成自己的 'generators' =&gt; [ 'model' =&gt; [ // 自定义的模板生成器 'class' =&gt; 'app\common\gii\model\Generator', //设置我们自己的模板 'templates' =&gt; [ //模板名 =&gt; 模板路径 'default' =&gt; '@app/common/gii/model/default', 'original' =&gt; '@app/common/gii/model/original_tpl', ] ] ], ];&#125; 现在在配置中指定了两种model 生成模板了 2.设置自定义的 Geneartor 和 template现在进@app/vendor/yiisoft/yii2-gii/src/generators/model把这个目录拷贝到 @app/common/gii/这里,位置随意, 只要保证 config 中能找到这个路径就行,现在我们就在 @app/common/gii/model这里操作 因为 Generator 继承的 \yii\gii\Generator, 需要实现两个方法, 一个是 getName() 另一个是 generate(), 我们主要修改的就是 generate(),12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// file path: @app/common/gii/model/Generatornamespace app\common\gii\model;use Yii;use yii\db\ActiveQuery;use yii\db\ActiveRecord;use yii\db\Connection;use yii\db\Schema;use yii\db\TableSchema;use yii\gii\CodeFile;use yii\helpers\Inflector;use yii\base\NotSupportedException;class Generator extends \yii\gii\Generator&#123; /** some code ..... */ /** * &#123;@inheritdoc&#125; */ public function generate() &#123; $files = []; $relations = $this-&gt;generateRelations(); $db = $this-&gt;getDbConnection(); foreach ($this-&gt;getTableNames() as $index =&gt; $tableName) &#123; // model : $modelClassName = $this-&gt;generateClassName($tableName); $queryClassName = ($this-&gt;generateQuery) ? $this-&gt;generateQueryClassName($modelClassName) : false; $tableSchema = $db-&gt;getTableSchema($tableName); $params = [ &apos;tableName&apos; =&gt; $tableName, &apos;className&apos; =&gt; $modelClassName, &apos;queryClassName&apos; =&gt; $queryClassName, &apos;tableSchema&apos; =&gt; $tableSchema, &apos;properties&apos; =&gt; $this-&gt;generateProperties($tableSchema), &apos;labels&apos; =&gt; $this-&gt;generateLabels($tableSchema), // 这是新增的 &apos;constMap&apos; =&gt; $this-&gt;generateConstMap($tableSchema), &apos;rules&apos; =&gt; $this-&gt;generateRules($tableSchema), &apos;relations&apos; =&gt; isset($relations[$tableName]) ? $relations[$tableName] : [], ]; // 同一个库中只生成一个 Model.php 之后的 model 都要继承这个 model if ($index == 0) &#123; $files[] = new CodeFile( Yii::getAlias(&apos;@&apos; . str_replace(&apos;\\&apos;, &apos;/&apos;, $this-&gt;ns)) . &apos;/Model.php&apos;, $this-&gt;render(&apos;cModel.php&apos;, $params) ); &#125; $files[] = new CodeFile( Yii::getAlias(&apos;@&apos; . str_replace(&apos;\\&apos;, &apos;/&apos;, $this-&gt;ns)) . &apos;/&apos; . $modelClassName . &apos;.php&apos;, $this-&gt;render(&apos;model.php&apos;, $params) ); &#125; return $files; &#125; protected function generateConstMap($table)&#123; // some code &#125; /** some code ..... */&#125; 在generate() 这个方法里的 $params 这里就是给模板准备参数, new CodeFile这里就是生成指定的模板 现在我们在模板中搞一下 3.设置 model 模板在@app/common/gii/model目录下有一个default目录,就是默认的 template,咱们在config.php中设置了12345'templates' =&gt; [ //模板名 =&gt; 模板路径 'default' =&gt; '@app/common/gii/model/default', 'original' =&gt; '@app/common/gii/model/original_tpl', ] 这两个, 把 default/ 复制一份叫 original_tpl/ 这在 gii 页面端选模板的时候能看到这写别名,如果是console模式的话只能使用default模板了 1234567891011121314151617181920212223242526272829303132// path: @app/common/gii/default/model.php&lt;?php/** * This is the template for generating the model class of a specified table. *//* @var $this yii\web\View *//* @var $generator yii\gii\generators\model\Generator *//* @var $tableName string full table name *//* @var $className string class name *//* @var $queryClassName string query class name *//* @var $tableSchema yii\db\TableSchema *//* @var $properties array list of properties (property =&gt; [type, name. comment]) *//* @var $labels string[] list of attribute labels (name =&gt; label) *//* @var $rules string[] list of validation rules *//* @var $relations array list of relations (name =&gt; relation declaration) *//* @var $constMap string[] list of attribute labels (name =&gt; label) */echo "&lt;?php\n";?&gt;namespace &lt;?= $generator-&gt;ns ?&gt;;use Yii;/** * This is the model class for table "&lt;?= $generator-&gt;generateTableName($tableName) ?&gt;". *&lt;?php foreach ($properties as $property =&gt; $data): ?&gt;...底下一些乱七八糟的代码.... 这里就看着办吧,就是正常的渲染模板 因为在generate()中还设置了一个1234567// 同一个库中只生成一个 Model.php 之后的 model 都要继承这个 modelif ($index == 0) &#123; $files[] = new CodeFile( Yii::getAlias('@' . str_replace('\\', '/', $this-&gt;ns)) . '/Model.php', $this-&gt;render('cModel.php', $params) );&#125; 新增了一个cModel.php,这个是我自己的业务需求, 同库的 model 全部继承这个 model, 这里只是设置了一下getDb()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/** * This is the template for generating the model class of a specified table. *//* @var $this yii\web\View *//* @var $generator yii\gii\generators\model\Generator *//* @var $tableName string full table name *//* @var $className string class name *//* @var $queryClassName string query class name *//* @var $tableSchema yii\db\TableSchema *//* @var $properties array list of properties (property =&gt; [type, name. comment]) *//* @var $labels string[] list of attribute labels (name =&gt; label) *//* @var $rules string[] list of validation rules *//* @var $relations array list of relations (name =&gt; relation declaration) *//* @var $constMap string[] list of attribute labels (name =&gt; label) */$date = date('Y/m/d H:i');$date = explode(' ', $date);$model = &lt;&lt;&lt;str&lt;?php/** * Created by Gii. * TemplatePath: @app\common\gii\model\default\cModel.php * Date: &#123;$date[0]&#125; * Time: &#123;$date[1]&#125; */namespace &#123;$generator-&gt;ns&#125;;use yii\db\ActiveRecord;use Yii;/** * 同文件夹下都要继承一下这个 model,目前是用来改库的链接地址 * Class Model * @package app\modules\v1\models\passport */class Model extends ActiveRecord&#123; /** * 重写表所对应的数据库链接信息 (如果函数不存在则默认为 db 的配置) * @return \yii\db\Connection */ public static function getDb() &#123; return Yii::\$app-&gt;get('&#123;$generator-&gt;db&#125;'); &#125;&#125;str;echo $model;?&gt; 这样依赖 gii 的模板自定义就算是完事了 4. console 模式下的 gii照例首先需要设置console.php的配置 12345678910111213141516//path @app/console.phpif (YII_ENV_DEV) &#123; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'app\common\gii\Module', 'generators' =&gt; [ 'model' =&gt; [ // 自定义的模板生成器 'class' =&gt; 'app\common\gii\model\Generator', //设置我们自己的模板 console 默认就是 default 模板 'templates' =&gt; [] ] ], ];&#125; generators 和 之前的配置一样,区别就是 module 下的 class 设置成自己的 Module 这里把@app/vendor/yiisoft/yii2-gii/src/Module.php复制一份到@app/common/gii/Module.php 改一下命名空间并且继承\yii\gii\Module 毕竟咱们是定制的, 这个代码不能在 vendor 中改,不然以后你再装新的 composer 包的时候会非常麻烦 12345678910111213141516171819202122232425// path: @app/common/gii/Module.php/**代码块*/ public function bootstrap($app) &#123; if ($app instanceof \yii\web\Application) &#123; $app-&gt;getUrlManager()-&gt;addRules([ ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id, 'route' =&gt; $this-&gt;id . '/default/index'], ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id . '/&lt;id:\w+&gt;', 'route' =&gt; $this-&gt;id . '/default/view'], ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id . '/&lt;controller:[\w\-]+&gt;/&lt;action:[\w\-]+&gt;', 'route' =&gt; $this-&gt;id . '/&lt;controller&gt;/&lt;action&gt;'], ], false); &#125; elseif ($app instanceof \yii\console\Application) &#123; $app-&gt;controllerMap[$this-&gt;id] = [ // 这里改成自己定制的 consoleController 'class' =&gt; 'app\common\gii\console\GenerateController', 'generators' =&gt; array_merge($this-&gt;coreGenerators(), $this-&gt;generators), 'module' =&gt; $this, ]; &#125; &#125;/**代码块*/ 只用把 console 的 GenerateController 指向咱们自定义的控制器, 复制目录@app/vendor/yiisoft/yii2-gii/src/console/ 到 @app/common/gii/console/, 这时我们就能对 gii console 模式下的代码进行调整了 可能在@app/common/gii/console/GenerateController.php中的代码让你摸不到头脑, 这里是在 actions()来着注册 router, 具体的 action 实现则是在 class 中指定了 1234567891011121314151617181920// path: @app/common/gii/console/GenerateController.php public function actions() &#123; $actions = []; foreach ($this-&gt;generators as $name =&gt; $generator) &#123; $actions[$name] = [ 'class' =&gt; 'yii\gii\console\GenerateAction', 'generator' =&gt; $generator, ]; // 依赖model generator 重新定义一个 gii 命令 if($name == 'model') &#123; $actions['all'] = [ 'class' =&gt; 'app\common\gii\console\GenerateAllAction', 'generator' =&gt; $generator, ]; &#125; &#125; return $actions; &#125; 因为所有的 Generator 都实现了 getName() 和 generate()这两个方法,action 也是只使用了这两个方法,可以自己翻下代码,这里就不详细讲了]]></content>
      <categories>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>gii</tag>
        <tag>yii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十进制与二进制,八进制,十六进制的换算]]></title>
    <url>%2F2018%2F05%2F23%2Fconversion-calculation%2F</url>
    <content type="text"><![CDATA[复习一下二进制,八进制,十六进制之间的互相转换和怎么用十进制去转换它们 首先做一个定义： B(Binary)表示二进制，O(Octal)表示八进制，D(Decimal)或不加表示十进制，H(Hexadecimal)表示十六进制，比如：(101011)B=(53)O=(43)D=(2B)H 十进制转换成二进制除二取余法二进制说白了就是 0 和 1 啊，在十进制的时候就是2的次方 以十进制的(43)D为例：123456743/2=21%121/2=10%110/2=5 %05 /2=2 %12 /2=1 %01 /2=0 %1以上把余数倒着排就是二进制的结果了，即101011 阶段相减法（适合低次方的速算）每次都减去最大的值，还是拿(42)D举例：42-32-8-2-1=0， 对应以下的表格为： 64 32 16 8 4 2 1 2^6 2^5 2^4 2^3 2^2 2^1 2^0 0 1 0 1 0 1 1 结果就是： 101011 十进制转二进制以 (101011)B 举例：11*2^0 + 1*2^1 + 1*2^3 + 1*2^5 = 43 十进制转八进制和十六进制都是用的除8或16取余法，不做赘述了，有点区别就是16进制的9以后就是abcd…代替的这等式就自己进行一下验算好了: (101011)B=(53)O=(43)D=(2B)H 二进制转八进制、十六进制先复习一个等式: 2^0 * 2^1 * 2^2 = 2^3， 那么二进制转八进制就是将二进制的数三个为一组合并一下：1101|011 =&gt; 53 同理， 二进制转16进制就是按四个为一组合并一下：10010|1011 =&gt; 2b 十六进制和八进制之间转换都是先转换成二进制，然后再转成想要的进制]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Rabbitmq实现的延时队列(golang版)]]></title>
    <url>%2F2018%2F05%2F14%2Fgo-rabbitmq-delay-queue%2F</url>
    <content type="text"><![CDATA[虽然 rabbitmq 没有延时队列的功能,但是稍微变动一下也是可以实现的 实现延时队列的基本要素 存在一个倒计时机制:Time To Live(TTL) 当到达时间点的时候会触发一个发送消息的事件:Dead Letter Exchanges（DLX） $~~$基于第一点,我利用的是消息存在过期时间这一特性, 消息一旦过期就会变成dead letter,可以让单独的消息过期,也可以设置整个队列消息的过期时间而rabbitmq会有限取两个值的最小值 $~~$基于第二点,是用到了rabbitmq的过期消息处理机制:. x-dead-letter-exchange 将过期的消息发送到指定的 exchange 中. x-dead-letter-routing-key 将过期的消息发送到自定的 route当中 在这里例子当中,我使用的是 过期消息+转发指定exchange 在 golang 中的实现首先是消费者comsumer.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package mainimport ( "log" "github.com/streadway/amqp")func failOnError(err error, msg string) &#123; if err != nil &#123; log.Fatalf("%s: %s", msg, err) &#125;&#125;func main() &#123; // 建立链接 conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/") failOnError(err, "Failed to connect to RabbitMQ") defer conn.Close() ch, err := conn.Channel() failOnError(err, "Failed to open a channel") defer ch.Close() // 声明一个主要使用的 exchange err = ch.ExchangeDeclare( "logs", // name "fanout", // type true, // durable false, // auto-deleted false, // internal false, // no-wait nil, // arguments ) failOnError(err, "Failed to declare an exchange") // 声明一个常规的队列, 其实这个也没必要声明,因为 exchange 会默认绑定一个队列 q, err := ch.QueueDeclare( "test_logs", // name false, // durable false, // delete when unused true, // exclusive false, // no-wait nil, // arguments ) failOnError(err, "Failed to declare a queue") /** * 注意,这里是重点!!!!! * 声明一个延时队列, ß我们的延时消息就是要发送到这里 */ _, errDelay := ch.QueueDeclare( "test_delay", // name false, // durable false, // delete when unused true, // exclusive false, // no-wait amqp.Table&#123; // 当消息过期时把消息发送到 logs 这个 exchange "x-dead-letter-exchange":"logs", &#125;, // arguments ) failOnError(errDelay, "Failed to declare a delay_queue") err = ch.QueueBind( q.Name, // queue name, 这里指的是 test_logs "", // routing key "logs", // exchange false, nil) failOnError(err, "Failed to bind a queue") // 这里监听的是 test_logs msgs, err := ch.Consume( q.Name, // queue name, 这里指的是 test_logs "", // consumer true, // auto-ack false, // exclusive false, // no-local false, // no-wait nil, // args ) failOnError(err, "Failed to register a consumer") forever := make(chan bool) go func() &#123; for d := range msgs &#123; log.Printf(" [x] %s", d.Body) &#125; &#125;() log.Printf(" [*] Waiting for logs. To exit press CTRL+C") &lt;-forever&#125; 然后是生产者productor.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( "log" "os" "strings" "github.com/streadway/amqp")func failOnError(err error, msg string) &#123; if err != nil &#123; log.Fatalf("%s: %s", msg, err) &#125;&#125;func main() &#123; conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/") failOnError(err, "Failed to connect to RabbitMQ") defer conn.Close() ch, err := conn.Channel() failOnError(err, "Failed to open a channel") defer ch.Close() body := bodyFrom(os.Args) // 将消息发送到延时队列上 err = ch.Publish( "", // exchange 这里为空则不选择 exchange "test_delay", // routing key false, // mandatory false, // immediate amqp.Publishing&#123; ContentType: "text/plain", Body: []byte(body), Expiration: "5000", // 设置五秒的过期时间 &#125;) failOnError(err, "Failed to publish a message") log.Printf(" [x] Sent %s", body)&#125;func bodyFrom(args []string) string &#123; var s string if (len(args) &lt; 2) || os.Args[1] == "" &#123; s = "hello" &#125; else &#123; s = strings.Join(args[1:], " ") &#125; return s&#125; 运行一下:12go run comsumer.gogo run productor.go $~~$具体看代码和注释就行, 这里的关键点就是将要延时的消息发送到过期队列当中, 然后监听的是过期队列转发到的 exchange 下的队列正常情况就是始终监听一个队列,然后把过期消息发送到延时队列中,当消息到达时间后就把消息发到正在监听的队列 一个自己写的mq工具]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关 Restful 借口规范踩到的坑]]></title>
    <url>%2F2018%2F05%2F09%2Fphp-restful%2F</url>
    <content type="text"><![CDATA[使用 restful 接口规范开发时我碰到的几个槽点… restful提供了一种接口规范,本意是让路由变得更加易懂,不过既然是规则那么就有束缚,想在项目中采用这个的同学们可以参考一下 路由嵌套太要命$~~$如果存在这种city/3/zoo/2/animal/1这样的查询路由你怎么说? 多层嵌套在我看来反而不如?city=3&amp;zoo=2&amp;animal=1这种 query 来的方便直接,尤其是在后台的开发中这种目录结构会让人痛不欲生,而且很多情况下我们进行列表展示的时候数据不是从一个表里取出来的,有时甚至需要跨业务或者调第三方的进行组合,这种情况下路由是不是要很长? restful路由里需要显示出要操控的资源,这资源种类一多url 就会变得长长长,反而不如像select/animal-list这样来的简单直接 权限问题$~~$这是由于上个问题引申出来的, 像city/{cid}/zoo/{zid}/animal/{aid}这种路由规则的权限怎么去维护? 而且 rbac 在国内的应用来说很是常见,我们目前的解决方案也是12345$route = [ 'select/animal' =&gt; 'city/&#123;cid&#125;/zoo/&#123;zid&#125;/animal/&#123;aid&#125;', //.....]; 这样给这类的路由出一个给机器看的路由,长期下来如果当前开发人员走了后续接手的程序员会很绝望 路由规则让人头秃$~~$restful的路由命名核心就是将动词转换成名词,这个就看你的词汇量能不能跟上业务了,最典型的就是用户登录注册,user/login和user/register这种明显不符合啊,如果用session/{id}这种路由又显得怪怪的 如果出现文件类型接口的怎么办?$~~$举个例子就是如果我有导出 excel 或者生成二维码的需求,那么这个路由算是文档操作里面的还是业务资源底下的?这一类的操作大部分都是查的居多,增删改几乎没有,这种接口都是单独写路由规则的.还有一点,我们这边采取的前后端分离通常都是 application/json 格式传输数据,当碰到文件上传的时候还是老老实实的用multipart/form-data,请求方式要单独写,php56的还会提示$HTTP_RAW_POST_DATA即将被php://input替换 回归到参数提取的问题$~~$还是查找这一块,路由很受限,举个例子:我需要查当前某个动物园的动物种类,按名字首字母降序排序,那么我应该是GET /zoo/3/animal?sort=-1&amp;slabel=name, 需要组成这个路由首先要前端兄弟把指定的 id 给拼出来,然后其他的参数拼到后面,或者其他的参数放到header里面,那么后台兄弟就要先把路由中的参数给剔出来,然后再去某个地方把剩余的参数给拿到…累不累? 查询条件多的情况下是不是还和原来一样,而且还多了提取url中参数的操作? 理论上在查询的时候是可以指定显示字段的$~~$GET /zoo?field=name,id,desc 查询的路由把暴露字段的权利开放给了调用方,那么如果有人操作不规范或者直接就是是坏,每次请求我都取全量字段内容,那么我的带宽不要钱啊?mysql 的 I/O 也是压力啊 总结$~~$restful接口在猛一看很美好,但是需要结合自己实际业务是不是适配这套规则,不要强行为了restful而restful, 一些小而美的工具可以用这种规范,中大型的业务真的要慎重考虑]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php开发过程中不常碰到的error]]></title>
    <url>%2F2018%2F04%2F26%2Fphp-unsual-mistakes%2F</url>
    <content type="text"><![CDATA[这里做一些备注,以防再次碰到 url 当中的参数有 &amp;timestamp=1234567890这样的字段会被转义成xtamp=1234567890这个不仅存在于页面解析当中,当使用 curl 请求时拼接的参数有这种格式的也会发生转义解决方法有两个: 把 timestamp 这个参数放在 urlQuery 的最前面, ?timestamp=1234567890 这样避免出现 &amp;time发生转义的情况 将&amp;用&amp;amp;来代替 Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.出现这句话通常说明你在用的 php 版本是5.6.而且在php&lt;=5.6的时候,进行 application/json格式的 post 提交会把数据放在$HTTP_RAW_POST_DATA这个系统变量里面,在php&gt;=7的时候这个变量被移除了,统统归总到php://input这里解决方法: 根据系统提示的走: Although that indeed would be technically impossible (as $HTTP_RAW_POST_DATA is populated in the bootstrapping phase of the PHP process) allow one to override the setting by means of calling ini_set. 要确保自己的系统中没有使用 HTTP_RAW_POST_DATA这个变量,直接在php.ini里面禁掉它的设置,但是容易出现系统中又打开的情况(在框架中很常见) 改一下自己的提交方式, 使用 application/form-data或者application/x-www-form-urlencoded这种格式的提交, 然后在后端接收数据的时候再转成自己需要的格式(通常是数组) 参考资料 Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’这种情况出现在平时运行的好好的, 但是突然换 cli 模式后这个配置就出问题了,原因在当 host=localhost时走的是 unix:socket 链接, 当host=127.0.0.1走的是 tcp 链接,这在php-fpm和php-cli中有点区别,尤其是本地没有安装 mysql 的时候解决方法有三种: 将本地链接配置统一成 127.0.0.1 查看 MySQL 中的user表, host=localhost和host=127.0.0.1是不是用的同一个账号密码 配置php.ini文件中的pdo_mysql.default_socket= 写上完整的 socket 路径以上三种方法都可以试一下参考资料 常驻内存时发生的事情这个是 phper 很少碰到但是很常见的情况, 比如用 swoole 启动了一个常驻进程的服务, 那么就一定要小心使用静态变量,在同步模式下会发生变量污染, 还有就是 redis,mysql 这类的链接,你会发现长时间静置以后就会出现一些摸不着头脑的问题, 这种情况不妨想一下是不是 server 端回收了这个 socket,因此在 client 端怎么都写入不进去. 还有就是 php 在读取消息的时候,出现消息过长的情况,那么就要考虑EOF终止符的问题了… 单次 http 每一次请求都是全新的代码, 不用自己考虑 gc 的问题, 但是在常驻内存的时候,这些就是一个个的大坑了 mysql has gone away产生这个错误的主要原因是 mysql server 端断开了链接, client 端还拿着这个句柄去请求,解决方式有两种: show global variables like &#39;%timeout&#39;; 查看 wait_timeout 的时长,适当的调长一点, 这种方法治标不治本,而且有隐患 12mysql&gt; set global wait_timeout=10;mysql&gt; show global variables like 'wait_timeout'; 使用 mysql 之前需要 mysql_ping() 一下, 如果出现断开的错误就启动重连机制]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 开发过程中一些不错的工具(不定期更新)]]></title>
    <url>%2F2018%2F03%2F26%2Fgolang-awesome-tools%2F</url>
    <content type="text"><![CDATA[就是平时用到的一些工具 fswatch用于监听目录文件的修改,一旦发生修改将自动执行系统指令,比如保存后自动 go run 之类的, 这个使用 go 写的 codeskyblue/fswatch 还有个跨平台的命令行工具,同样的名字 start 更多 emcrisostomo/fswatch 不过图方便用 go 这个就行 bee属于 beego 的附属开发工具, bee run [project-name] 的执行效果也是自动监听文件改动执行编译命令, 感觉不如fswatch方便,当然用 beego 开发的另说astaxie/beego govendor是 go 开发的包管理工具, 虽然依赖的package都在 gopath当中,但是代码换一个环境就要重新go get一堆东西实在不方便,而且还有一个值得吐槽的依赖包版本问题govendor工具就是解决这类的问题,通过 hash 来保证开发和线上使用的依赖库一样kardianos/govendor Gin一个很不错的 web 开发框架,github 上已经有 14711个 star(截止到18/02/05), 和 Martini的api 很像,但是更快,适合用来做 restful 的 APIgin-gonic/gin mux一个独立的路由包, 支持 restful,轻量,而且支持go的net/http 的接口gorilla/mux beego国人开发的go web框架, 特点是大而全,方便入门,和 php 的框架思路很像,有不少人在吐槽它的笨重, 如果公司想转成 go 做 web 业务它是一个不错的选择,因为它能快速出东西啊,个人感觉有点头疼的是源码很多很多…astaxie/beego beego-log如果不想全部引用 beego 的内容,可以引进它的模块啊,它的 log 模块就是一个很不错的选择beego-log 的中文档 kafka-go和 kafka 相关的库很少,不过我个人使用的话这个库已经能满足我的需求, 我这里也有一个demo示例segmentio/kafka-go go-redis/redisredis 的依赖包还是很简单的,这里推荐一个 star 不少的库go-redis/redis amqp如果用 rabbitmq 就肯定用这个拉,官方出品的肯定有保证啊,可惜 kafka 还没出官方包amqp]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-Volume]]></title>
    <url>%2F2018%2F02%2F13%2Fdocker-volume%2F</url>
    <content type="text"><![CDATA[这里有一个使用 wordpress 的 docker-compose.yml的示例:1234567891011121314151617181920212223242526272829version: '3'services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: gaofeifiy MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress ports: - 33060:3306 wordpress: depends_on: - db image: wordpress:latest ports: - "8080:80" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpressvolumes: db_data: 其中有一点奇怪的地方就是在db的数据挂载当中,是这么写的:123456789... db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql....volumes: db_data: 这是docker-compose version2 起开始的新语法,目的就是方便多个服务之间公用同一个卷12volumes: db_data: 这种写法就是声明一个命名卷, 通过docker volume ls 可以列出来宿主机上的所有挂载的卷,而且这些卷不会因为容器被删除而删除,为的就是方便数据和服务分离 可以通过命令docker inspect wordpress_db_data 来查看卷的配置,这里wordpress_db_data就是我们刚才声明的那个卷的名字123456789101112131415➜ wordpress git:(master) ✗ docker inspect wordpress_db_data[ &#123; "CreatedAt": "2018-02-13T04:29:29Z", "Driver": "local", "Labels": &#123; "com.docker.compose.project": "wordpress", "com.docker.compose.volume": "db_data" &#125;, "Mountpoint": "/var/lib/docker/volumes/wordpress_db_data/_data", "Name": "wordpress_db_data", "Options": &#123;&#125;, "Scope": "local" &#125;] 不过他的mountpoint的路径并不是宿主机上的路径,而依然是属于docker的路径,在macOS系统当中可以执行 123screen ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty# ls -ltrh /var/lib/docker/volumes 在 macOS 中并不能看到实体文件,而是进入linuxkit中,所有的资源也是在那里,这在win和mac会出现,在 linuxOS中就是正常的/var/lib/docker路径可以查看卷的列表, 参考资料1 参考资料2 清除本地的卷可以执行docker volume prune 官方文档]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>volume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-compose.yml 常用命令]]></title>
    <url>%2F2018%2F02%2F12%2Fdocker-compose-yml%2F</url>
    <content type="text"><![CDATA[常用命令备注 build 构建(重构)服务容器格式为: docker-compose build [options] [service...] --force-rm 删除构建时的临时容器 --no-cache 构建不使用 cache --pull 始终尝试 pull 最新的镜像 up (这个才是最常用的)docker-compose up [options] [service...] 直接输出docker-compose up就是将执行目录下的docker-compose.yml里的服务都自动构建,重新创建,并启动起来,同时将不同的容器关联起来,默认保持前台运行,同时也会输出各容器的输出日志 docker-compose up -d 将后台执行,在生产环境中使用 -d 保持后台运行 --no-color 不以颜色区分日志输出 --no-deps 不启动服务关联的容器 --force-recreate 强制重新创建容器 --no-recreate 若容器已经存在,则不再构建, 与上者不同时使用 --no-build 不自动构建缺失的镜像 -t , --timeout TIMEOUT 停止容器时候的超时,默认10s config 检测配置文件格式如果正确则显示配置文件内容,如果错误则显示错误原因 down 停止up启动的游戏exec 进入指定的容器images 列出 compose 中包含的镜像kill 发送信号停止容器docker-compose kill [options] [service...]比如 docker kill -s web logs 日志docker-compose logs [options] [service...]不同容器输出的日志颜色不同,不想有颜色就添加参数--no-color pause 暂停一个服务pull 拉取所需的镜像docker-compose pull [options] [service...] version 输出 compose 的版本一个简单的示例,具体代码参考 这里 123456789version: '3'services: web: # 一个 service 的名字 build: . # 指出 Dockerfile 所在文件夹的路径, 而且每个 service 中必须有 build 或者 image ports: # 将容器内的接口绑定到宿主机上 - "5000:5000" redis: image: "redis:alpine" # 这就是使用的远程镜像 下面列出来几个常用的参数命令: build 通过 Dockerfile 来构建镜像,可以指定Dockerfile路径以及context的路径, 可以用arg指定构建时的参数 比如: 123456web: build: context: ./dir dockerfile: ./other-dir arg: buildno: 1 image 根据提供的镜像名拉取镜像 command 覆盖容器启动后的默认命令比如: 1command: echo "hello world" container_name 指定 service 容器的名字,如果没设置的话就是 容器_序号 这样, 比如 web_1,db_1 这样的 1container_name: web-container devices 指定设备映射关系 12devices: - "/dev/ttyUSB1:/dev/ttyUSB0" depends_on 指定容器依赖关系,会优先构建依赖的容器,比如: 123456789101112version: '3'services: web: build: . depends_on: - db - redis redis: image: redis db: image: mysql 会先构建 db,redis再构建web dns 自定义 dns 服务列表 123dns: - 8.8.8.8 - 114.114.114.114 env_file 从文件中提取环境变量,同变量名的会被最后的变量覆盖 12345env_file: .envenv_file: - .env1 - .env2 格式必须是可以被 #注释的12PRO_ENV=productAPP_NAME=hahaha environment 设置环境变量,可以是KEY=VALUE 也可以只给出变量名,这将调取 docker 宿主机的环境变量 1234567environment: ROCK_ENV: 'development' SESSION_SECRET:environment: - ROCK_ENV=development - SESSION_SECRET port 将端口暴露到宿主机上对于表示布尔值的变量建议添加引号,防止 yaml 解析的时候产生歧义,比如:y|yes|TRYE|true|ON|on 这一类的 volumes 将宿主机的目录路径和容器中的路径挂载,可以设置访问模式,比如: 1234volumes: - /var/lib/mysql # 同路径挂载 - cache/:/tmp/cache - ~/configs:/etc/configs:/ro # 支持相对路径, 支持访问模式 读取变量: compose会读取宿主机的环境变量和当前目录下的.env文件中的变量 比如: 1234version: '3'services: db: image: "mongodb:($MONGO_VERSION) 这在启动的时候就会根据环境变量来调整要拉取的镜像]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-composer</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Go 进行 Jwt 验证]]></title>
    <url>%2F2018%2F01%2F22%2Fgo-jwt%2F</url>
    <content type="text"><![CDATA[对于使用负载均衡的服务器来说,使用 JWT(JSON WEB TOKEN) 是一个更优的选择,session受到单台服务器的限制,一个用户登录过后就只能分配到这一台服务器上,这和负载均衡的初衷不一致啊,而 jwt 就解决了这类的痛点 使用 JWT 的场景 身份验证 用户在登录过后服务器会用 jwt 返回用户可访问的资源,比如权限什么的 传递信息 通过 jwt 的header和signature可以保证payload没有被篡改,保证信息的安全 JWT 的结构JWT 是由header,payload,signature三部分组成的,咱们先用例子说话 header12345&#123; "alg": "HS256", "typ": "JWT"&#125;// base64编码的字符串`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9` 这里规定了加密算法,hash256 payload 123456&#123; "sub": "1234567890", "name": "John Doe", "admin": true&#125;// base64编码的字符串`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9` 这里的内容没有强制要求,因为 paylaod 就是为了承载内容而存在的,不过想用规范的话也可以参考下面的 iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 signature是用 header + payload + secret组合起来加密的,公式是: 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 这里 secret就是自己定义的一个随机字符串,这一个过程只能发生在 server 端,会随机生成一个 hash 值 这样组合起来之后就是一个完整的 jwt 了:1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.4c9540f793ab33b13670169bdf444c1eb1c37047f18e861981e14e34587b1e04 这里有一个用 go 加密和验证 jwt 的 demo 总结选择 jwt 最大的理由: 内容有公钥私钥,可以保证内容的合法性 token 中可以包含很多信息 不过 jwt 不保证的安全问题: 因为header,paylaod是 base64编码,相当于明文可见的,因此不能在payload中放入敏感信息 并不能保证数据传输时会不会被盗用,这一点和 sessionID 一样,因此不要迷信它有多高的安全性.. 为了安全还是要上 https 相关推荐:jwt.io]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>json</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于跨域请求的二三事]]></title>
    <url>%2F2018%2F01%2F16%2Fhttp-cross-domain-etc%2F</url>
    <content type="text"><![CDATA[在前后端分离开发时跨域经常是一个不可回避的问题,这里介绍一个比较简单的办法,前端 vue.js,后端 go 首先要区分简单请求和复杂请求这里阮一峰有详细讲解过一个: 跨域资源共享 CORS 详解 如果你有一种太长不看的想法,就听我给你简单说一下: 简单路由: 指的就是你平时表单提交,ajax 提交,使用GET,POST,HEAD,http 头信息里面没有杂七杂八的东西的请求 复杂请求: 就是除了简单请求之外的请求,比如你在 http 头里有自定义的字段,或者你使用像DELETE,PATCH这样的方法 你会发现复杂请求最明显的变化就是浏览器每次去请求接口的时候会发送两次,这里第一次发送的必定是一个请求方法为OPTIONS的,第二个才是你写的方法,我截图里的就是POST, 第二张截图之所以被判定为复杂请求就是因为我加了一个X-TOKEN这个header,而如果第一次的OPTIONS方法的请求如果失败了也就不会发送第二条信息了,至于为什么,我只能说这是规定 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。——HTTP访问控制（CORS） 对于简单请求和复杂请求的处理(后端)既然叫简单请求处理起来也很简单,下面已经列出代码, 关键就是设置Access-Control-Allow这一些参数就行,复杂请求就是添加一个针对OPTIONS的处理方式,通常情况返回一个空字符串就行至于跨域验证之类的就是八仙过海各显神通了各家有个家的处理方法12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( "flag" "fmt" "net" "net/http")type httpServer struct &#123;&#125;func (s *httpServer) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; // Stop here if its Preflighted OPTIONS request if origin := r.Header.Get("Origin"); origin != "" &#123; w.Header().Set("Access-Control-Allow-Origin", "*") // 限制请求方的域 * 就是不限制 w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE") // 限制请求方式 w.Header().Set("Access-Control-Allow-Headers","Action, Module") //有使用自定义头 需要这个,Action, Module是例子 w.Header().Set("Access-Control-Allow-Headers", "Content-Type,Authorization,X-Token") //允许的header的类型 &#125; // if r.Method == "OPTIONS" &#123; // 针对复杂请求时做出的处理 // return // &#125; w.Write([]byte("hello"))&#125;func main() &#123; addr := flag.String("http-address", "", "") flag.Parse() var h httpServer httpListener, err := net.Listen("tcp", *addr) server := http.Server&#123;Handler: &amp;h,&#125; server.Serve(httpListener) fmt.Println("finish ", err)&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 在 Vue-Cli 中使用 Svg 做 Icon]]></title>
    <url>%2F2017%2F12%2F26%2Fvue-svg-icon%2F</url>
    <content type="text"><![CDATA[之前都是用的image sprite或者使用的 Font Awesome这类的开源库现在咱们已经走进了现代浏览器的年代(ie9+),可以玩点新鲜的东西了,svg svg 有几个好处: 矢量图,不失真 可以受CSS样式影响,就像一个文本 http请求低了 相关阅读: 未来必热：SVG Sprite技术介绍 而对我来说最直观的好处就是可以让设计师给你出一个 svg,而不是自己眼都挑花了去找一个合适的图标:) 做一个 svg-icon 组件在 vue-cli 生成的 vue 脚手架中添加组件1234567891011121314151617181920212223242526272829303132333435363738// path: @/components/SvgIcon/index.vue&lt;template&gt; &lt;svg class="svg-icon" aria-hidden="true"&gt; &lt;use :xlink:href="iconName"&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'icon-svg', props: &#123; iconClass: &#123; type: String, required: true &#125; &#125;, computed: &#123; iconName() &#123; return `#icon-$&#123;this.iconClass&#125;` &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt;作者：花裤衩链接：https://juejin.im/post/59bb864b5188257e7a427c09来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 使用:12345678910111213//引入svg组件import IconSvg from &apos;@/components/IconSvg&apos;//全局注册icon-svgVue.component(&apos;icon-svg&apos;, IconSvg)//在代码中使用&lt;icon-svg icon-class=&quot;password&quot; /&gt;作者：花裤衩链接：https://juejin.im/post/59bb864b5188257e7a427c09来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 现在组件有了,svg 去哪里搞? 使用 svg-sprite-loader这个工具可以把多个 svg 打包成 svg-sprite 为了把 icon 使用的 svg 和其他地方使用的 svg 区分开,我们需要对webpack.base.conf.js中的内容重新设置一下:12345678910111213141516171819202122//path: app-project/build/webpack.base.conf.js ... // [新增]当引用图标 svg 的时候引入指定目录下的文件 &#123; test: /\.svg$/, loader: 'svg-sprite-loader', include: [resolve('src/icons')], options: &#123; symbolId: 'icon-[name]' &#125; &#125;, // [修改]这里 exclude 来忽略常规的 svg 引入 &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', exclude: [resolve('src/icons')], // 这一步必不可少 options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, ... 接下来需要使用 webpack 的require.context函数 require.context(“./test”, false, /.test.js$/);这行代码就会去 test 文件夹（不包含子目录）下面的找所有文件名以 .test.js 结尾的文件能被 require 的文件。更直白的说就是 我们可以通过正则匹配引入相应的文件模块。 为了拆卸方便就把这些都放在了icons目录下123456789101112// path: app-project/src/icons.index.jsimport Vue from 'vue'import SvgIcon from '@/components/SvgIcon'// svg组件// 全局注册组件Vue.component('svg-icon', SvgIcon)// 定义一个加载目录的函数const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context('./svg', false, /\.svg$/)// 加载目录下的所有 svg 文件requireAll(req) 然后只需要在 main.js 文件中引入这个组件就可以了1234// path: app-project/src/main.js...import './icons' // 引入图标文件... 具体代码可以参考 这个地址链接 压缩 svg 内容这里推荐一个比较好用的工具: svgo SVG精简压缩工具svgo简介和初体验 最后这是我抄的 花裤衩的 手摸手，带你优雅的使用 icon,观摩别人的代码给自己带来了很多收获]]></content>
      <categories>
        <category>精选转载</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Chrome 浏览器会强制跳转到 Https 的问题]]></title>
    <url>%2F2017%2F12%2F19%2Fchrome-redirection-https%2F</url>
    <content type="text"><![CDATA[我在本地使用的是 *.app 的域名开发的,某一天发现使用谷歌的时候会强制跳转到 https,改成http都不管用 询问了一下万能的404网站,查询的结果大多是: chrome浏览器地址栏输入：chrome://net-internals/#hsts在该页面中搜索：Query HSTS/PKP domain在其下方的 Domain 后面的输入框中输入自己无法访问的域名，比如：domain.app，点击Query进行查询，如果有类似下面的结果，说明该域名后缀无法使用http前缀。 这样式儿的结果,结果试了以后没有解决都我目前的问题,后来根据这篇文章的描述 Chrome 于 V63 版本起会将 .dev 域名强制转换为 HTTPS说 .dev 的域名就是会强制跳转,看来我用的.app的域名估计也是同样的问题,解决方法也简单.根据 Don’t Use .dev For Development建议使用1234.localhost.invalid.text.example 作为本地开发的模拟域名,如果用的不爽的话,换火狐啊 :)]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sense-HAT Api 文档]]></title>
    <url>%2F2017%2F11%2F30%2FRaspberry-pi3-sense-HAT-api%2F</url>
    <content type="text"><![CDATA[从官方给的 api 文档中硬翻的… LED 模型set_rotation 设置翻转角度这个函数可以设置 led 的旋转角度 参数 类型 可选参数 描述 r Integer 0,90,180,270 0指的是树莓派 HDMI 接口向下的方向 redraw Boolean TRUE,FALSE 默认为 TRUE 示例:12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/pythonimport sysimport timefrom sense_hat import SenseHatX = (255, 0, 0)O = (255, 255, 255)question_mark = [ O, O, O, X, X, O, O, O, O, O, X, O, O, X, O, O, O, O, O, O, O, X, O, O, O, O, O, O, X, O, O, O, O, O, O, X, O, O, O, O, O, O, O, X, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, X, O, O, O, O]sense = SenseHat()sense.set_pixels(question_mark)sense.set_pixel(0, 0, 255, 0, 0)sense.set_pixel(0, 7, 0, 255, 0)sense.set_pixel(7, 0, 0, 0, 255)sense.set_pixel(7, 7, 255, 0, 255)def close_light(): black = [ [0,0,0] ] * 64 sense.set_pixels(black)try: while True: for r in [0, 90, 180, 270]: sense.set_rotation(r) time.sleep(0.3)except KeyboardInterrupt: close_light() print &quot;Good bye&quot; set_pixels 批量设置像素点改变64颗 led 的显示颜色 参数 类型 可选参数 描述 pixel_list List [[R, G, B] * 64] 需要提供 list 长度为64的二维数组, (r,g,b)为三原色的色值 示例参考上一个示例 get_pixels 获取当前像素点数组 返回类型 描述 List 将当前的 led 屏上显示的图像转换成list 示例:12345678910111213141516171819202122#!/usr/bin/pythonfrom sense_hat import SenseHatX = (255, 0, 0)O = (0, 0, 0)question_mark = [ O, X, O, O, O, O, X, O, O, O, X, O, O, X, O, O, O, X, X, X, X, X, X, O, X, X, O, X, X, O, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, O, X, O, O, O, O, X, O, X, O, O, O, O, O, O, X]sense = SenseHat()sense.set_pixels(question_mark)out_list = sense.get_pixels()print out_list 提示:之所以有这个函数是因为传入set_pixels的像素值有时会发生变化,sense HAT 是将每个像素指定为8 位数 (0-255) 但是如果传入 led 的 frameBuffer 中的时候,颜色的位数会转成 RGB565(5位红色,6位绿色和5位蓝色)执行转换的时候可以看到二进制转换时发生的精度损失get_pixels 就是显示像素在缓冲区内结束时的值 set_pixel 设置单点像素颜色通过 x-y 坐标系来定位像素位置,以 HDMI 接口面向的位置为下 参数 类型 可选参数 描述 x Integer 0-7 0为左 7为右 y Integer 0-7 0为上 7为下 当只有三个参数的时候 pixel Tuple / List 0-255 (r, g, b) 数值 当有五个参数的时候 r Integer 0-255 红 g Integer 0-255 绿 b Integer 0-255 蓝 示例:123456789101112131415161718from sense_hat import SenseHatsense = SenseHat()# examples using (x, y, r, g, b)sense.set_pixel(0, 0, 255, 0, 0)sense.set_pixel(0, 7, 0, 255, 0)sense.set_pixel(7, 0, 0, 0, 255)sense.set_pixel(7, 7, 255, 0, 255)red = (255, 0, 0)green = (0, 255, 0)blue = (0, 0, 255)# examples using (x, y, pixel)sense.set_pixel(0, 0, red)sense.set_pixel(0, 0, green)sense.set_pixel(0, 0, blue) get_pixel 获取指定位置的颜色同 get_pixels 不过是单体版的 参数 类型 可选参数 描述 x Integer 0-7 0为左 7为右 y Integer 0-7 0为上 7为下 返回类型 描述 List [R,G,B] 组成的数组 示例:1234from sense_hat import SenseHatsense = SenseHat()top_left_pixel = sense.get_pixel(0, 0) load_image 加载图像到矩阵中加载一个图像文件，将其转换为RGB格式，并在LED矩阵上显示。图像的大小必须是8×8像素。 参数 类型 可选参数 描述 file_path String ... 有效的图片路径 redraw Boolean TRUE/FALSE 是否重绘已加载的图像文件在LED矩阵上。默认值为True 示例:1234from sense_hat import SenseHatsense = SenseHat()sense.load_image(&quot;space_invader.png&quot;) 返回类型 描述 List [[R,G,B] * 64] 组成的数组 1234from sense_hat import SenseHatsense = SenseHat()invader_pixels = sense.load_image(&quot;space_invader.png&quot;, redraw=False) clear 让 led 屏变成纯色,默认是关闭 参数 类型 可选参数 描述 当只有一个参数的时候 pixel Tuple / List 0-255 (r, g, b) 数值,默认为[0,0,0] 当有三个参数的时候 r Integer 0-255 红 g Integer 0-255 绿 b Integer 0-255 蓝 示例:123456789101112from sense_hat import SenseHatfrom time import sleepsense = SenseHat()red = (255, 0, 0)sense.clear() # no arguments defaults to offsleep(1)sense.clear(red) # passing in an RGB tuplesleep(1)sense.clear(255, 255, 255) # passing in r, g and b values of a colour show_message 屏幕显示单个文字就是街头广告灯的那种 led 滚屏啦! 参数 类型 可选参数 描述 text_string String ... 将要滚屏的字母 scroll_speed Float 任意浮点数 滚屏速度,默认 0.1 text_colour List [R,G,B]] 文字颜色,默认[255,255,255] back_colour List [R,G,B]] 背景颜色,默认[0,0,0] 示例: 1234from sense_hat import SenseHatsense = SenseHat()sense.show_message(&quot;One small step for Pi!&quot;, text_colour=[255, 0, 0]) show_letter 单屏显示字母 参数 类型 可选参数 描述 s String ... 将要显示的字母 text_colour List [R,G,B]] 文字颜色,默认[255,255,255] back_colour List [R,G,B]] 背景颜色,默认[0,0,0] 示例:123456789101112#!/usr/bin/pythonimport timefrom sense_hat import SenseHatsense = SenseHat()letters = &quot;ABCDEFGHIJKLMNOPQRSTUVWSYZ&quot;for i in letters: sense.show_letter(str(i)) time.sleep(1) low_light 调低亮度如果觉得亮度有点刺眼的话可以开低亮度模式12345678import timefrom sense_hat import SenseHatsense = SenseHat()sense.clear(255, 255, 255)sense.low_light = Truetime.sleep(2)sense.low_light = False 1234567891011121314151617181920212223#!/usr/bin/pythonimport timefrom sense_hat import SenseHatsense = SenseHat()sense.clear(255, 127, 0)sense.set_pixels(question_mark)print(sense.gamma)time.sleep(2)old = sense.gammasense.gamma = old[::-1]print(sense.gamma)time.sleep(2)sense.low_light = Trueprint(sense.gamma)time.sleep(2)sense.low_light = False gammaFor advanced users. Most users will just need the low_light Boolean property above. The Sense HAT python API uses 8 bit (0 to 255) colours for R, G, B. When these are written to the Linux frame buffer they’re bit shifted into RGB 5 6 5. The driver then converts them to RGB 5 5 5 before it passes them over to the ATTiny88 AVR for writing to the LEDs.The gamma property allows you to specify a gamma lookup table for the final 5 bits of colour used. The lookup table is a list of 32 numbers that must be between 0 and 31. The value of the incoming 5 bit colour is used to index the lookup table and the value found at that position is then written to the LEDs. 对于高级用户。大多数用户只需要上面的low_light布尔属性。这个感觉帽python API使用8位(0到255)的颜色为R,G,b。当这些被写入Linux框架缓冲区时，它们被位转换为RGB 5 6 5。然后，驱动程序将它们转换为RGB 5 5 5，然后将其传递给ATTiny88 AVR以写入led。gamma属性允许您为使用的最后5位颜色指定一个伽马查找表。查找表是32个数字的列表，它们必须在0到31之间。传入的5位颜色的值用于索引查找表，然后将该位置上发现的值写入led。—来自有道词典,因为暂时不知道用在哪里 类型 可选参数 描述 List 长度为32的元组或列表，包含0到31之间的整数 最后的5位颜色的查找表 示例:123456789101112131415161718import timefrom sense_hat import SenseHatsense = SenseHat()sense.clear(255, 127, 0)print(sense.gamma)time.sleep(2)sense.gamma = sense.gamma[::-1]print(sense.gamma)time.sleep(2)sense.low_light = Trueprint(sense.gamma)time.sleep(2)sense.low_light = False gamma_reset一个函数将gamma查找表重置为默认值，理想情况下，如果您已经对它进行了处理，并希望将它恢复到默认状态。示例:123456789import timefrom sense_hat import SenseHatsense = SenseHat()sense.clear(255, 127, 0)time.sleep(2)sense.gamma = [0] * 32 # Will turn the LED matrix offtime.sleep(2)sense.gamma_reset() 环境感应器get_humidity 湿度 返回类型 描述 Float 湿度的百分数 示例:123456789#!/usr/bin/pythonfrom sense_hat import SenseHatsense = SenseHat()humidity = sense.get_humidity()print(&quot;Humidity: %s %%rH&quot; % humidity) #Humidity: 13.8048038483 %rH# 同样效果print(sense.humidity) #14.9011135101 get_temperature 温度返回值也是浮点数示例:12345678910#!/usr/bin/pythonfrom sense_hat import SenseHatsense = SenseHat()temp = sense.get_temperature()print(&quot;Temperature: %s C&quot; % temp) # Temperature: 33.0 C# alternativesprint(sense.temp) # 33.0print(sense.temperature) # 33.0 get_temperature_from_humidity 温度从湿度传感器获取当前温度(摄氏度)。示例:12345from sense_hat import SenseHatsense = SenseHat()temp = sense.get_temperature_from_humidity()print(&quot;Temperature: %s C&quot; % temp) get_temperature_from_pressure 温度从压力传感器获取温度12345from sense_hat import SenseHatsense = SenseHat()temp = sense.get_temperature_from_pressure()print(&quot;Temperature: %s C&quot; % temp) get_pressure 压力获取压力参数 ps: 1Bar=0.1MPa=1000mba=1000hpa=100*7.5mmhg=75mmhg=1个大气压 返回类型 描述 Float 单位为Millibars 示例:12345678from sense_hat import SenseHatsense = SenseHat()pressure = sense.get_pressure()print(&quot;Pressure: %s Millibars&quot; % pressure) #Pressure: 1024.56738281 Millibars# 同理print(sense.pressure) # 1024.56738281 IMU Sensor 惯性测量单元IMU(inertial measurement unit)传感器是三个传感器的组合，每个传感器分别有x、y和z轴。由于这个原因，它被认为是一个9自由度的传感器。 陀螺仪(Gyroscope) 加速度计(Accelerometer) 指南针(Magnetometer)这个API允许你在任何组合中使用这些传感器来测量方向或单独的传感器。 set_imu_config支持或禁用陀螺仪、加速度计和/或磁强计 参数 类型 可选参数 描述 compass_enabled Boolean TRUE,FALSE 是否启用指南针 gyro_enabled Boolean TRUE,FALSE 是否启用陀螺仪 accel_enabled Boolean TRUE,FALSE 是否启用加速度计 示例:1234from sense_hat import SenseHatsense = SenseHat()sense.set_imu_config(False, True, False) # 只开启陀螺仪 get_orientation_radians获取当前方向弧度,依据飞行器轴参数的 pitch, roll 和 yaw.理解传说中的roll、yaw、pitch欧拉角 返回类型 描述 Dictionary 由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴弧度 示例:12345678from sense_hat import SenseHatsense = SenseHat()orientation_rad = sense.get_orientation_radians()print(&quot;p: &#123;pitch&#125;, r: &#123;roll&#125;, y: &#123;yaw&#125;&quot;.format(**orientation_rad)) # p: 0.0906969159842, r: -0.218863099813, y: 2.87161874771# alternativesprint(sense.orientation_radians) # &#123;&apos;yaw&apos;: 2.933598041534424, &apos;roll&apos;: -0.20759552717208862, &apos;pitch&apos;: 0.09733205288648605&#125; get_orientation_degrees以俯仰、翻滚和偏航的飞机主轴得到当前的方向。 返回类型 描述 Dictionary 由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴角度 示例:12345from sense_hat import SenseHatsense = SenseHat()orientation = sense.get_orientation_degrees()print(&quot;p: &#123;pitch&#125;, r: &#123;roll&#125;, y: &#123;yaw&#125;&quot;.format(**orientation)) # p: 359.368855623, r: 359.958133745, y: 24.4292643968 get_orientation作用同get_orientation_degrees 123456from sense_hat import SenseHatsense = SenseHat()orientation = sense.get_orientation()print(sense.orientation) # &#123;&apos;yaw&apos;: 20.334569404489745, &apos;roll&apos;: 0.02406978340326997, &apos;pitch&apos;: 359.2895215347403&#125; get_compass调用罗盘时会预先调用set_imu_config禁止掉重力计和加速度计的功能 12345678from sense_hat import SenseHatsense = SenseHat()north = sense.get_compass()print(&quot;North: %s&quot; % north) # North: 351.031626941# alternativesprint(sense.compass) # 351.031626941 get_compass_raw获取原始x、y和z轴的磁强计数据。 返回类型 描述 Dictionary 字典对象索引的字符串x,y和z。表示磁场强度的值浮动轴的microteslas(µT)。 12345678from sense_hat import SenseHatsense = SenseHat()raw = sense.get_compass_raw()print(&quot;x: &#123;x&#125;, y: &#123;y&#125;, z: &#123;z&#125;&quot;.format(**raw)) # x: 3.14855718613, y: 0.269534498453, z: -0.743863344193# alternativesprint(sense.compass_raw) # &#123;&apos;y&apos;: 0.4851621091365814, &apos;x&apos;: 5.667402744293213, &apos;z&apos;: -1.338953971862793&#125; get_gyroscope调用set_imu_config来禁用磁强计和加速计，然后只从陀螺仪获取当前方向。 返回类型 描述 Dictionary 由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴角度 123456789from sense_hat import SenseHatsense = SenseHat()gyro_only = sense.get_gyroscope()print(&quot;p: &#123;pitch&#125;, r: &#123;roll&#125;, y: &#123;yaw&#125;&quot;.format(**gyro_only))# alternativesprint(sense.gyro) # &#123;&apos;yaw&apos;: 0.0604013305118731, &apos;roll&apos;: 359.9494321175156, &apos;pitch&apos;: 359.9567423509234&#125;print(sense.gyroscope) # &#123;&apos;yaw&apos;: 0.0604013305118731, &apos;roll&apos;: 359.9494321175156, &apos;pitch&apos;: 359.9567423509234&#125; get_gyroscope_raw获取原始x、y和z轴的陀螺仪数据。 返回类型 描述 Dictionary 一个由字符串x、y和z索引的字典对象。这些值是按每秒弧度表示轴的旋转强度的浮点数。 1234567891011121314from sense_hat import SenseHatsense = SenseHat()raw = sense.get_gyroscope_raw()print(&quot;x: &#123;x&#125;, y: &#123;y&#125;, z: &#123;z&#125;&quot;.format(**raw))# alternativesprint(sense.gyro_raw)print(sense.gyroscope_raw)# x: 1.03765261173, y: 2.46352291107, z: 0.185390725732# &#123;&apos;y&apos;: 1.5728815793991089, &apos;x&apos;: 0.34309887886047363, &apos;z&apos;: 0.2984008193016052&#125;# &#123;&apos;y&apos;: 0.8343454599380493, &apos;x&apos;: 0.163504496216774, &apos;z&apos;: 0.4767734408378601&#125; get_accelerometer调用set_imu_config来禁用磁力仪和陀螺仪，然后从加速度计得到当前的方向。 返回类型 描述 Dictionary 由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴角度 1234567891011121314from sense_hat import SenseHatsense = SenseHat()accel_only = sense.get_accelerometer()print(&quot;p: &#123;pitch&#125;, r: &#123;roll&#125;, y: &#123;yaw&#125;&quot;.format(**accel_only))# alternativesprint(sense.accel)print(sense.accelerometer)# p: 3.76471788135, r: 10.0814548376, y: 0.0# &#123;&apos;yaw&apos;: 4.5454772552392335e-07, &apos;roll&apos;: 10.082596332952239, &apos;pitch&apos;: 3.7639588765826475&#125;# &#123;&apos;yaw&apos;: 4.5454772552392335e-07, &apos;roll&apos;: 10.082596332952239, &apos;pitch&apos;: 3.7639588765826475&#125; get_accelerometer_raw获取原始x、y和z轴加速度计数据。 返回类型 描述 Dictionary 一个由字符串x、y和z索引的字典对象。这些值代表了在Gs中轴的加速度强度。 12345678910111213from sense_hat import SenseHatsense = SenseHat()raw = sense.get_accelerometer_raw()print(&quot;x: &#123;x&#125;, y: &#123;y&#125;, z: &#123;z&#125;&quot;.format(**raw))# alternativesprint(sense.accel_raw)print(sense.accelerometer_raw)# x: -0.0634367614985, y: 0.172625526786, z: 0.974787354469# &#123;&apos;y&apos;: 0.1738394945859909, &apos;x&apos;: -0.06516461074352264, &apos;z&apos;: 0.9757621884346008&#125;# &#123;&apos;y&apos;: 0.17286831140518188, &apos;x&apos;: -0.06565827876329422, &apos;z&apos;: 0.9735689163208008&#125; Joystick 操纵杆操纵事件描述操纵杆事件的元组。包含三个命名参数: 时间戳—事件发生的时间，作为秒数(与内置时间函数相同的格式) 方向-操纵杆移动的方向，作为一个字符串(“向上”，“向下”，“左”，“右”，“中间”) 动作—发生的动作，作为一个字符串(“按压”，“释放”，“持有”) 这个tuple类型被一些joystick方法使用，要么作为返回类型，要么是参数的类型。 wait_for_event在发生joystick事件之前阻止执行，然后返回一个表示发生的事件的InputEvent。123456789from sense_hat import SenseHatfrom time import sleepsense = SenseHat()event = sense.stick.wait_for_event()print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction))sleep(0.1)event = sense.stick.wait_for_event()print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction)) 在上面的例子中，如果你将操纵杆简单地推到一个单一的方向，你就会看到两个事件输出:一个被压的动作和一个释放的动作。可选的emptybuffer可以用于在等待新事件之前刷新任何未决事件。试试下面的脚本，看看有什么不同:123456789from sense_hat import SenseHatfrom time import sleepsense = SenseHat()event = sense.stick.wait_for_event()print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction))sleep(0.1)event = sense.stick.wait_for_event(emptybuffer=True)print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction)) get_events返回自最后一次调用get_events或wait_for_event之后发生的所有事件的InputEvent tuple的列表。123456from sense_hat import SenseHatsense = SenseHat()while True: for event in sense.stick.get_events(): print(&quot;The joystick was &#123;&#125; &#123;&#125;&quot;.format(event.action, event.direction)) direction_up, direction_left, direction_right, direction_down, direction_middle, direction_any这些属性可以被分配一个函数，当操纵杆按在相关的方向(或者在direction_any的任何方向上)时，它就会被调用。分配的函数要么不接受参数，要么必须接受一个参数，该参数将传递给相关的InputEvent。1234567891011121314151617181920212223242526272829303132333435363738394041from sense_hat import SenseHat, ACTION_PRESSED, ACTION_HELD, ACTION_RELEASEDfrom signal import pausex = 3y = 3sense = SenseHat()def clamp(value, min_value=0, max_value=7): return min(max_value, max(min_value, value))def pushed_up(event): global y if event.action != ACTION_RELEASED: y = clamp(y - 1)def pushed_down(event): global y if event.action != ACTION_RELEASED: y = clamp(y + 1)def pushed_left(event): global x if event.action != ACTION_RELEASED: x = clamp(x - 1)def pushed_right(event): global x if event.action != ACTION_RELEASED: x = clamp(x + 1)def refresh(): sense.clear() sense.set_pixel(x, y, 255, 255, 255)sense.stick.direction_up = pushed_upsense.stick.direction_down = pushed_downsense.stick.direction_left = pushed_leftsense.stick.direction_right = pushed_rightsense.stick.direction_any = refreshrefresh()pause() 相关资料 博客原文api 原文树莓派+senseHAT 的一个入门项目来自官方的 astro-pi 简介]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派3安装 Sense HAT]]></title>
    <url>%2F2017%2F11%2F29%2FRaspberry-pi3-install-sense-HAT%2F</url>
    <content type="text"><![CDATA[因为感觉各种感应器的 GPIO 有点乱,干脆买了一个官方提供的集成板来玩,这样看着也整体一些… 英文不错的同学出门右转: 官方提供的一个说明一个 sense-hat 的接口文档各感应模块的针脚示意图 更新系统(Rasbian)1$ sudo apt update &amp;&amp; sudo apt upgrade -y 可能得等一大会儿…. 安装扩展模块12$ sudo apt-get install sense-hat$ sudo reboot 运行一个 demo, 官方提供的一些 demo 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/pythonimport timefrom sense_hat import SenseHatsense = SenseHat()r = 255g = 0b = 0msleep = lambda x: time.sleep(x / 1000.0)def next_colour(): global r global g global b if (r == 255 and g &lt; 255 and b == 0): g += 1 if (g == 255 and r &gt; 0 and b == 0): r -= 1 if (g == 255 and b &lt; 255 and r == 0): b += 1 if (b == 255 and g &gt; 0 and r == 0): g -= 1 if (b == 255 and r &lt; 255 and g == 0): r += 1 if (r == 255 and b &gt; 0 and g == 0): b -= 1while True: sense.clear([r, g, b]) msleep(2) next_colour() 如果运行是出现下列报错的话:1234567Traceback (most recent call last): File &quot;demo1.py&quot;, line 38, in &lt;module&gt; sense.clear([r, g, b]) File &quot;/usr/lib/python2.7/dist-packages/sense_hat/sense_hat.py&quot;, line 413, in clear self.set_pixels([colour] * 64) File &quot;/usr/lib/python2.7/dist-packages/sense_hat/sense_hat.py&quot;, line 294, in set_pixels f.seek(map[index // 8][index % 8] * 2) # row, column 还是比较好解决的,更改配置就行12345$ sudo vi /boot/config.txt//找到 dtoverlay 这一行修改成dtoverlay=rpi-sense//然后 wq 退出$ sudo reboot 这是我第一次安装时碰到的问题 解决方案来源]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派的一些报错问题]]></title>
    <url>%2F2017%2F11%2F28%2FRaspberry-pi3-local-lang%2F</url>
    <content type="text"><![CDATA[树莓派出现本地语言出现问题123456789101112perl: warning: Setting locale failed.perl: warning: Please check that your locale settings: LANGUAGE = "en_US.UTF-8", LC_ALL = "en_US.UTF-8", LC_CTYPE = "zh_CN.UTF-8", LANG = "en_US.UTF-8" are supported and installed on your system.perl: warning: Falling back to the standard locale ("C").locale: Cannot set LC_CTYPE to default locale: No such file or directorylocale: Cannot set LC_MESSAGES to default locale: No such file or directorylocale: Cannot set LC_ALL to default locale: No such file or directory/usr/sbin/dpkg-reconfigure must be run as root 解决方法其实已经给出运行命令:1sudo dpkg-reconfigure locales 设置 utf8 就行]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派上安装 Golang]]></title>
    <url>%2F2017%2F11%2F22%2FRaspberry-Pi3-golang-env%2F</url>
    <content type="text"><![CDATA[树莓派上需要进行编译安装,不过很简单,而且 golang 官方也有 arm 平台的编译包,在树莓派上一定要选linux-armv61这个版本啊 golang 各版本的下载列表 $ 开头的都是在命令行中输入123456789101112131415$ wget https://redirector.gvt1.com/edgedl/go/go1.9.2.linux-armv6l.tar.gz$ tar -C /usr/local -zvxf go1.8.3.linux-armv6l.tar.gz$cd / &amp;&amp; mkdir -p /data/www/go$ sudo vim /etc/profile# 在文件末尾添加如下内容export PATH=$PATH:/usr/local/go/bin# 添加如下设置项export GOROOT=/usr/local/goexport GOPATH=/data/www/goexport PATH=$GOROOT/bin:$PATH//保存退出后让环境变量立即生效$ source /etc/profile$ go version]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用树莓派3搞一个信号灯输出]]></title>
    <url>%2F2017%2F11%2F21%2FRaspberry-Pi3-traffic-light%2F</url>
    <content type="text"><![CDATA[通过一个python脚本跑一个监控 cpu 的交通信号灯,运行环境是官方的系统 Raspbian 执行脚本有编程基础的同学就直接上手好了: 123456789101112131415161718192021222324252627282930313233343536373839#! /usr/bin/env python# to use with Pi Traffic Lightimport RPi.GPIO as GPIOimport psutilGREEN = 13YELLOW = 19RED = 26# Pin Setup:GPIO.setmode(GPIO.BCM) # Broadcom pin-numbering scheme.GPIO.setwarnings(False)GPIO.setup(GREEN, GPIO.OUT)GPIO.setup(YELLOW, GPIO.OUT)GPIO.setup(RED, GPIO.OUT)try: while (1): cpu_pc = psutil.cpu_percent(interval=2) print 'CPU: %d%%' % (cpu_pc) if cpu_pc &lt;= 50: GPIO.output(RED, False) GPIO.output(YELLOW, False) GPIO.output(GREEN, True) if 50 &lt; cpu_pc &lt; 90: GPIO.output(GREEN, False) GPIO.output(RED, False) GPIO.output(YELLOW, True) if cpu_pc &gt;=90 : GPIO.output(GREEN, False) GPIO.output(YELLOW, False) GPIO.output(RED, True)except KeyboardInterrupt: print "Good bye" GPIO.output(GREEN, False) GPIO.output(YELLOW, False) GPIO.output(RED, False) GPIO.cleanup() 如果出现提示****line 5, in &lt;module&gt; import psutil***** 提示缺少psutil模块,就按照下面的方法安装: 代码原文 123wget https://pypi.python.org/packages/source/p/psutil/psutil-3.2.2.tar.gzcd psutil-3.2.2python setup.py install 如果报错检查 gcc,python-devel 是否安装(官方系统的话会把这些环境默认安装好,不用管的) 针脚怎么插?软件方面的搞定了,接下来需要搞明白怎么配置硬件了,这是树莓派系列的针脚图(咱们这是3代,最右边的那个):我又从网上找的一张实物图这是我淘来的信号灯这两个都是针脚型的,但是我有一个40针脚的扁平线可以用来对接,按照信号灯指定的端口插就行 插好以后就直接运行脚本就行比如这个脚本叫做 traffic.py,就运行1$ python ./traffic.py 就能看到效果 代码都做了什么? 引入需要用到的模块, RPi.GPIO针脚输出,psutil用于系统监控 12345#! /usr/bin/env python# to use with Pi Traffic Lightimport RPi.GPIO as GPIOimport psutil 定义三个灯输出的针脚 123GREEN = 13YELLOW = 19RED = 26 对指定的针脚进行设置 123456# Pin Setup:GPIO.setmode(GPIO.BCM) GPIO.setwarnings(False)GPIO.setup(GREEN, GPIO.OUT)GPIO.setup(YELLOW, GPIO.OUT)GPIO.setup(RED, GPIO.OUT) 这里的 GPIO.setmode(GPIO.BCM)就是指定了输出模式为按照信道编号,就是上图中的GPIO2,GPIO3...这类如果GPIO.setmode(GPIO.BOARD)就是Pin No.1 =&gt; GPIO1,使用物理针脚的编号作为输出信道 GPIO.setwarnings(False) 关闭warning 提示 GPIO.setup(GREEN, GPIO.OUT) 将对应的信道设置为输出信道 通过 while 循环检索 cpu 的使用情况并输出,且根据所占百分比显示相应的灯 123456789101112131415while (1): cpu_pc = psutil.cpu_percent(interval=2) print 'CPU: %d%%' % (cpu_pc) if cpu_pc &lt;= 50: GPIO.output(RED, False) GPIO.output(YELLOW, False) GPIO.output(GREEN, True) if 50 &lt; cpu_pc &lt; 90: GPIO.output(GREEN, False) GPIO.output(RED, False) GPIO.output(YELLOW, True) if cpu_pc &gt;=90 : GPIO.output(GREEN, False) GPIO.output(YELLOW, False) GPIO.output(RED, True) GPIO.output(GREEN, False)和GPIO.output(GREEN, True)猜都能猜到是控制输出的啦 对于程序退出的操作:把灯全关了,再调用GPIO.cleanup()释放资源 12345678910try: // some code....except KeyboardInterrupt: print "Good bye" GPIO.output(GREEN, False) GPIO.output(YELLOW, False) GPIO.output(RED, False) GPIO.cleanup() 总结这个 demo 只是对 GPIO 的输出进行展示,还没涉及到信号输入,接下来如果有空的话我会做一个输入的 demo 相关-极客大讲堂：手把手教你用树莓派控制红绿灯]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 烧录树莓派系统(新手版)]]></title>
    <url>%2F2017%2F11%2F21%2FRaspberry-Pi3-install%2F</url>
    <content type="text"><![CDATA[怎么在 mac 上给 TF 卡烧录一个树莓派系统(为什么没有 win 的?因为 win 上的烧录软件很好用啊!混蛋!) 下载树莓派镜像首先需要下载个系统镜像 官方镜像列表 RASPBIAN :这是树莓派为自己定制的系统,基于 Debian,原生支持最好,新手强烈推荐桌面版的 UBUNTU MATE :ubuntu 的 mate 版本,习惯使用 ubuntu 的选这个 SNAPPY UBUNTU CORE :仅包含 ubuntu 16.04 内核的版本,如果做 IoT 的据说用这个很不错,但是如果做网络服务器不咋好用其他的比如 WIN10 的这种有需要的自取 格式化 TF 卡先用读卡机器插到 mac 上,用系统自带的 磁盘工具 格式化一下 tf 卡,选择抹掉,格式为MS-DOS(FAT),名字随便,写完系统就没用了 打开 终端 使用df名称查看当前已挂载的卷1234567$ dfFilesystem 512-blocks Used Available Capacity iused ifree %iused Mounted on/dev/disk1 233269248 218788512 13968736 94% 27412562 1746092 94% /devfs 374 374 0 100% 648 0 100% /devmap -hosts 0 0 0 100% 0 0 100% /netmap auto_home 0 0 0 100% 0 0 100% /home/dev/disk2s1 31100416 4992 31095424 1% 0 0 100% /Volumes/Pi 基本商最后一行就是你的 tf 卡,/Volumes/Pi 这个 Pi 就是刚才格式化 tf 卡的时候输入的名字 使用diskutil unmount卸载12$ diskutil unmount /dev/disk2s1Volume Pi on disk2s1 unmounted diskutil list 确认设备,这里是 16G 的卡12345$ diskutil list/dev/disk2 #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *15.9 GB disk2 1: DOS_FAT_32 Pi 15.9 GB disk2s1 进入你下载好镜像文件的目录下,使用 dd 命令将镜像写入 PS /dev/disk2s1是分区，/dev/disk2是块设备，/dev/rdisk2是原始字符设备 1234$ dd bs=4m if=2017-09-07-raspbian-stretch.img of=/dev/rdisk2781+1 records in781+1 records out3276800000 bytes transferred in 194.134151 secs (16879050 bytes/sec) if后是镜像的地址,如果是当前目录地址的话直接输入文件名就行, of就是要写入的设备,执行的时候会感觉卡一会,大概30s,正常现象这时候这张 tf 卡就算是烧录好系统了,插到派上启动就行 这个时候你需要鼠标,键盘,有 hdmi 的显示器,插上 pi 就能启动了,可以在左上角菜单中preference中进行各种设置了,在界面可以很方便的设置 wifi使用网线插入路由器的话,可以在路由器的管理界面中找到设备名,默认设备名为raspberry进行 ssh 链接,用户命是 pi,密码 raspberry,或者你自己设置的1ssh pi@192.168.66.207 转载原文]]></content>
      <categories>
        <category>精选转载</category>
      </categories>
      <tags>
        <tag>Raspberry</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
</search>
