<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Centos7 部署 K8s]]></title>
    <url>%2F2019%2F06%2F17%2Fk8s-install-centos7%2F</url>
    <content type="text"><![CDATA[都是走的国内镜像源 关闭 selinux12setenforce 0 #实时动态关闭 selinuxsed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config #禁止重启后自动开启 关闭交换分区12swapoff -a #实时动态关闭交换分区sed -i &apos;/ swap / s/^/#/&apos; /etc/fstab #禁止重启后自动开启 网络配置文件123456789cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1vm.swappiness=0EOFmodprobe br_netfilter #执行该命令 如果不执行就会在应用k8s.conf时出现加载错误sysctl -p /etc/sysctl.d/k8s.conf #应用配置文件 yum换国内源12345cd /etc/yum.repos.d &amp;&amp; \sudo mv CentOS-Base.repo CentOS-Base.repo.bak &amp;&amp; \sudo wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo &amp;&amp; \yum clean all &amp;&amp; \yum makecache 配置k8s资源的下载地址1234567891011cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 安装依赖1yum install -y docker kubelet kubeadm kubectl docker换源12345678mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;&#123;&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125;EOFservice docker restart 开机启动123systemctl disable firewalld.service &amp;&amp; systemctl stop firewalld.service systemctl enable docker &amp;&amp; systemctl start dockersystemctl enable kubelet &amp;&amp; systemctl start kubelet 下载k8s依赖镜像获取依赖的镜像1kubeadm config images list 国内用户通过阿里云镜像下载k8s依赖组件12345kubeadm config images list |sed -e &apos;s/^/docker pull /g&apos; -e &apos;s#k8s.gcr.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g&apos; |sh -xdocker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk &apos;&#123;print &quot;docker tag &quot;,$1&quot;:&quot;$2,$1&quot;:&quot;$2&#125;&apos; |sed -e &apos;s#registry.cn-hangzhou.aliyuncs.com/google_containers#k8s.gcr.io#2&apos; |sh -xdocker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk &apos;&#123;print &quot;docker rmi &quot;, $1&quot;:&quot;$2&#125;&apos; |sh -x 主节点初始化Kubernetes v1.14.31kubeadm init --kubernetes-version=1.14.3 执行成功后出现1234567891011121314To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.31.120:6443 --token 6nelb5.lrc5qbs0k3v64eln \ --discovery-token-ca-cert-hash sha256:c55a113114d664133685430a86f2e39f40e9df6b12ad3f4d65462fd372079e97 node节点启动12kubeadm join 192.168.31.120:6443 --token 6nelb5.lrc5qbs0k3v64eln \ --discovery-token-ca-cert-hash sha256:c55a113114d664133685430a86f2e39f40e9df6b12ad3f4d65462fd372079e97 就是初始化后的最后一条命令 主节点执行：1234[root@localhost ~]# kubectl get nodesNAME STATUS ROLES AGE VERSIONlocalhost.localdomain NotReady master 40m v1.14.3miwifi-r3-srv NotReady &lt;none&gt; 3m48s v1.14.3 状态还是notReady 查看文档 https://kubernetes.io/docs/concepts/cluster-administration/addons/ 这里选了 weave 插件文档： https://www.weave.works/docs/net/latest/kubernetes/kube-addon/执行命令1kubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &apos;\n&apos;)&quot; 稍微等几分钟就可以看到正常了1234[root@localhost ~]# kubectl get nodesNAME STATUS ROLES AGE VERSIONlocalhost.localdomain Ready master 49m v1.14.3miwifi-r3-srv Ready &lt;none&gt; 12m v1.14.3 kubeadm token 过期的情况kubeadm join 用到的token有效期是24h 生成 token, 查看token 12345$ kubeadm token createrugi2c.bb97e7ney91bogbg$ kubeadm token listTOKEN TTL EXPIRES USAGES DESCRIPTION EXTRA GROUPSrugi2c.bb97e7ney91bogbg 23h 2019-06-18T22:28:11+08:00 authentication,signing &lt;none&gt; system:bootstrappers:kubeadm:default-node-token 生成证书1openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed &apos;s/^.* //&apos; 新token加入12kubeadm join 192.168.31.120:6443 --token rugi2c.bb97e7ney91bogbg \ --discovery-token-ca-cert-hash sha256:c55a113114d664133685430a86f2e39f40e9df6b12ad3f4d65462fd372079e97 搭建教程部署node节点]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K8s 安装 Minikube]]></title>
    <url>%2F2019%2F05%2F14%2Fk8s-minikube%2F</url>
    <content type="text"><![CDATA[本地快速装一个微型的kubernetes环境, 翻墙的苦谁能懂? mac 本地安装minikube环境环境需求: kubectl 本地做命令行控制用, 所有的命令操作都是通过它 vittualBox v5.1 + 更新到最新版本就对了 minikube 在本地搭建测试环境 翻墙有困难的可以参考一下这个 https://yq.aliyun.com/articles/221687 安装 kubectl1➜ brew install kubectl 下载最新 minikube 不建议使用brew安装, 首先版本不会是最新, 再者会出现莫名其妙的问题123➜ curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 &amp;&amp; \ chmod +x minikube &amp;&amp; \ sudo mv minikube /usr/local/bin/ 默认 start 时运行的virtualBox 去官网下个最新的就行 启动, 最好把docker镜像指定到国内12345678910111213141516171819202122232425➜ ~ minikube start --registry-mirror=https://registry.docker-cn.com😄 minikube v1.0.1 on darwin (amd64)💿 Downloading Minikube ISO ... 142.88 MB / 142.88 MB [============================================] 100.00% 0s🤹 Downloading Kubernetes v1.14.1 images in the background ...🔥 Creating virtualbox VM (CPUs=2, Memory=2048MB, Disk=20000MB) ...📶 &quot;minikube&quot; IP address is 192.168.99.103🐳 Configuring Docker as the container runtime ...🐳 Version of container runtime is 18.06.3-ce⌛ Waiting for image downloads to complete ...✨ Preparing Kubernetes environment ...💾 Downloading kubeadm v1.14.1💾 Downloading kubelet v1.14.1🚜 Pulling images required by Kubernetes v1.14.1 ...🚀 Launching Kubernetes v1.14.1 using kubeadm ...⌛ Waiting for pods: apiserver proxy etcd scheduler controller dns🔑 Configuring cluster permissions ...🤔 Verifying component health .....💗 kubectl is now configured to use &quot;minikube&quot;🏄 Done! Thank you for using minikube!➜ ~ kubectl cluster-infoKubernetes master is running at https://192.168.99.103:8443KubeDNS is running at https://192.168.99.103:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxyTo further debug and diagnose cluster problems, use &apos;kubectl cluster-info dump&apos;. 如果Minikube ISO存在墙的问题, 就把iso下载后放到 ~/.minikube/cache/iso/下 这时Mac上的docker不能用docker for Mac提供的了, 而是宿主机里面的docker, 切换命令为:1➜ eval $(minikube docker-env) 撤销更改1➜ eval $(minikube docker-env -u) 加载后台控制面板, 稍等一会, 自动打卡后台界面1➜ minikube dashboard 部署第一个应用命令行部署创建node.js 应用创建文件 server.js123456789var http = require('http');var handleRequest = function(request, response) &#123; console.log('Received request for URL: ' + request.url); response.writeHead(200); response.end('Hello World! V1');&#125;;var www = http.createServer(handleRequest);www.listen(3000); 运行1node server.js // 访问地址 http://localhost:3000 创建docker镜像123456FROM node:8.10.0EXPOSE 3000COPY server.js .CMD ["node", "server.js"] 构建镜像1➜ docker build -t hello-node:v1 . 如果出现Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 说明你忘了执行 eval $(minikube docker-env)kube用的 docker 和你本地用的 docker 是两个位置, kube的在虚拟机里运行 创建 deployment有了镜像就具备创建pod的条件, 通常来说不用直接创建 pod, 而是创建 deployment 或者 replication controller, 由他们来负责管理服务的运行, 规模缩放, 自动重启等等这些操作, 就单个pod来说是可以随时被销毁的, 不能作为稳定服务的保证 123➜ kubectl run hello-node --image=hello-node:v1 --port=3000或➜ kubectl create deployment hello-node --image=hello-node:v1 查看当前deployment123➜ kubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGEhello-node 1/1 1 1 8m8s ready 1/1 说明已经准备就绪了 查看 pod123➜ hellonode git:(master) ✗ kubectl get podsNAME READY STATUS RESTARTS AGEhello-node-5c58cb6dd4-h65fx 1/1 Running 0 8m40s 从这两条信息就能看出来, 每个pod都是带随机字符串的, 并不打算给人去操作, 我们主要专注在deployment和 service 的搭建 查看 deployment 描述123456789101112131415161718192021222324252627282930313233➜ kubectl describe deployments/hello-nodeName: hello-nodeNamespace: defaultCreationTimestamp: Mon, 13 May 2019 14:17:03 +0800Labels: run=hello-nodeAnnotations: deployment.kubernetes.io/revision: 1Selector: run=hello-nodeReplicas: 1 desired | 1 updated | 1 total | 1 available | 0 unavailableStrategyType: RollingUpdateMinReadySeconds: 0RollingUpdateStrategy: 25% max unavailable, 25% max surgePod Template: Labels: run=hello-node Containers: hello-node: Image: hello-node:v1 Port: 3000/TCP Host Port: 0/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailableOldReplicaSets: &lt;none&gt;NewReplicaSet: hello-node-5c58cb6dd4 (1/1 replicas created)Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 11m deployment-controller Scaled up replica set hello-node-5c58cb6dd4 to 1 这里是对deployment的概览, Pod Template: 下就是每个pods的配置, 之后对部署的扩容都是基于这个去复制 到目前为止我们创建了deployment 而且也自动生成pod了, 可是服务并不能被访问到, 为什么? 因为端口没有对外暴露出来, 所以有了下一步 创建serviceservice 就是用来对我暴露服务的东西, 所有的 pod 都是在内网通信, 外部访问就得让 service 这层代理去转发过去, --type=LoadBalancer 就是指定转发为负载均衡模式, kubectl create service -h 查看更多, 这里不细讲 创建service123➜ kubectl expose deployment hello-node --type=LoadBalancer或➜ kubectl expose deployment hello-node --type=LoadBalancer --port=3000 // 这里指定端口 查看1234➜ kubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-node LoadBalancer 10.111.18.151 &lt;pending&gt; 3000:31349/TCP 3skubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 3d 详细信息123456789101112131415➜ kubectl describe services hello-node Name: hello-nodeNamespace: defaultLabels: run=hello-nodeAnnotations: &lt;none&gt;Selector: run=hello-nodeType: LoadBalancerIP: 10.111.18.151Port: &lt;unset&gt; 3000/TCPTargetPort: 3000/TCPNodePort: &lt;unset&gt; 31349/TCPEndpoints: 172.17.0.7:3000Session Affinity: NoneExternal Traffic Policy: ClusterEvents: &lt;none&gt; NodePort 就是绑定在节点的那个端口上, 直接访问节点ip就行, 也可以用minikube命令 minikube service hello-node 自动帮你打开本地地址 扩展示例线上肯定是有这种动态扩容的情况, 而且多实例之间滚动升级也不会停止服务12345678➜ kubectl scale deployments/hello-node --replicas=4deployment.extensions/hello-node scaled➜ hellonode git:(master) ✗ kubectl get podsNAME READY STATUS RESTARTS AGEhello-node-5c58cb6dd4-d2qq9 1/1 Running 0 18shello-node-5c58cb6dd4-h65fx 1/1 Running 0 51mhello-node-5c58cb6dd4-jlzjw 1/1 Running 0 18shello-node-5c58cb6dd4-vmx4f 1/1 Running 0 18s 更新应用重新构建一个node的镜像service.js123456789var http = require('http');var handleRequest = function(request, response) &#123; console.log('Received request for URL: ' + request.url); response.writeHead(200); response.end('Hello World! V2');&#125;;var www = http.createServer(handleRequest);www.listen(3000); 1➜ docker build -t hello-node:v2 . 设置 deployment 使用新镜像1➜ kubectl set image deployment/hello-node hello-node=hello-node:v2 查看每个pod的具体情况1➜ kubectl describe pods 再访问刚才的地址就能看到改变了 清除资源12➜ kubectl delete service hello-node➜ kubectl delete deployments hello-node 经过上面一套操作下来, 应该也对k8s有了一个大致的印象了, 毕竟光看实践才是检验真理的唯一标准, 但是如果部署一个服务这样一个命令一个命令的敲是很要命的, 而且服务器这玩意, 轻易不会动, 时间一长就容易忘, 因此用配置文件去启动更加合理 通过 yaml 启动如下: test-service.yaml123456789101112131415161718192021222324252627282930313233343536373839apiVersion: v1kind: Servicemetadata: name: test-service labels: version: v2 run: hello-node app: test-servicespec: type: LoadBalancer ports: - port: 3001 targetPort: 3000 protocol: TCP selector: app: test-service---apiVersion: apps/v1kind: Deploymentmetadata: name: test-service labels: app: test-servicespec: replicas: 2 selector: matchLabels: app: test-service template: metadata: labels: app: test-service spec: containers: - name: node-pod image: hello-node:v2 imagePullPolicy: IfNotPresent ports: - containerPort: 3000 执行12➜ kubectl create -f test-service.yaml➜ minikube service test-service 这样通过配置文件就能启动了, 配置文件里里的字段后续我们再详细的讲一下 删除kubectl delete -f test-service.yaml 代码地址 相关资料带你理解Kubernetes，部署一个Node应用Kubernetes的三种外部访问方式：NodePort、LoadBalancer 和 IngressMinikube - Kubernetes本地实验环境Kubernetes之kubectl常用命令replication controller与deployment的区别Kubenetes里pod和service绑定的实现方式Kubernetes创建资源对象yaml文件例子kubernetes/minikube github]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker for Mac 部署 Kubernetes]]></title>
    <url>%2F2019%2F05%2F06%2Fk8s-install-docker%2F</url>
    <content type="text"><![CDATA[docker for mac 安装kubernetes本来是很方便的, 但是国内玩家要折腾一下, 因为 gcr.io 这个域被墙了… 目前来看前辈们已经把坑给淌的差不多了, 我老早的时候也被折腾的头秃, 这里就做个总结 通过代理翻墙下载镜像这个方法相对来说一劳永逸, 缺点是每个月有vpn的花费, 我代理用的shadowsockets, 就拿这个来举例: 首先安装1brew install privoxy 添加配置: 1vi /usr/local/etc/privoxy/config 配置内容:12listen-address 0.0.0.0:8118forward-socks5 / localhost:1080 . 监听本地8118端口, 转发到 localhost:1080, 这也是ss的客户端的转发端口 启动:1brew services start privoxy 转发部分完成, 接下来在 docker for mac配置 docker for mac &gt; preferences &gt; Proxies &gt; 点击 Manual proxy configuration Web Server(HTTP) 和 Secure Web Server (HTTPS) 都填入 http://{你机器IP}:8118 比如: ‘http://192.168.110.203:8118&#39; 不能用 127.0.0.1, 因为 docker for mac 启动后, docker 是运行在一个虚拟机中,而不是macOS下, 因此这个地址代表的意义不一样 点保存, 这样就能正常安装k8s了, 可以通过活动监视器看一下他们的流量是否正常 教程来源 自己预先加载一套镜像来找个目录, 新建 images.properties12345678910k8s.gcr.io/pause-amd64:3.1=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1k8s.gcr.io/kube-controller-manager-amd64:v1.10.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.3k8s.gcr.io/kube-scheduler-amd64:v1.10.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.3k8s.gcr.io/kube-proxy-amd64:v1.10.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.3k8s.gcr.io/kube-apiserver-amd64:v1.10.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.3k8s.gcr.io/etcd-amd64:3.1.12=registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12k8s.gcr.io/k8s-dns-sidecar-amd64:1.14.8=registry.cn-hangzhou.aliyuncs.com/google_containers/k8s-dns-sidecar-amd64:1.14.8k8s.gcr.io/k8s-dns-kube-dns-amd64:1.14.8=registry.cn-hangzhou.aliyuncs.com/google_containers/k8s-dns-kube-dns-amd64:1.14.8k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64:1.14.8=registry.cn-hangzhou.aliyuncs.com/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.8k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64:v1.8.3 新建脚本: kubernetes.sh12345678910111213141516171819#/bin/bashfile="./images.properties"if [ -f "$file" ]then echo "$file found." while IFS='=' read -r key value do #echo "$&#123;key&#125;=$&#123;value&#125;" docker pull $&#123;value&#125; docker tag $&#123;value&#125; $&#123;key&#125; docker rmi $&#123;value&#125; done &lt; "$file"else echo "$file not found."fi 运行就行 教程来源k8s-docker-for-mac 找个gcr.io的国内镜像这个是利用了dockerHub 因为都是国外的, 先让dockerHub给build一下, 然后直接拉dockerHub的镜像来迂回一下 Google Container Registry(gcr.io) 中国可用镜像(长期维护)gcr.io_mirror基于Docker for macOS的Kubernetes本地环境搭建与应用部署]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter 对Tcp进行压测]]></title>
    <url>%2F2019%2F04%2F30%2Ftools-jmeter%2F</url>
    <content type="text"><![CDATA[jmeter是个好工具, 跨平台, 有GUI, 简单易用, 扩展多 安装本地环境为macOS Mojave 10.14.4 本地需要安装java8jmeter官方下载地址jmeter插件下载 当前下载的jmeter版本为 5.1.1解压下载之后, 运行命令:1sh ~/Downloads/apache-jmeter-5.1.1/bin/jmeter 就运行起来了 进行tcp压测首先创建Thread Group 注意几个关键点: Number of Threads (users) 创建进程组, 相当于多少并发 Ramp-Up Period (in seconds) 设定的并发值在多少秒内到达预期, 模拟自然流量 Loop Count 每个进程组循环多少次 Loop Count * Number of Threads 就是整体请求数量了 创建tcp Sampler 这篇文章是使用最基本的文字tcp传输 看图说话, TCP classname默认为: org.apache.jmeter.protocol.tcp.sampler.TCPClientImpl, 可以直接从 Text to send 中传入文本传文本的时候一定要输入之后加一个回车,写\n都不管用, 必须 是回车, 它是自动转换的, 不然会造成数据找不到终止断点 如果使用 org.apache.jmeter.protocol.tcp.sampler.BinaryTCPClientImpl 则需要在 End of line byte value 里面传值, 通常是10且 Text to send 传的是16进制数据 创建 summary report 用于做统计表格 创建 view results tree 用于查看请求数据返回数据 安装cpu/内存监控插件5.1.1 版本的和之前搜的有些不一样, 现在有了一个内置的扩展商店 扩展下载地址 Download plugins-manager.jar and put it into lib/ext directory, then restart JMeter. 看到这句话没? 点就行了, 然后把它放到jmeter目录 lib/ext下,重启jmeter就能看到了 点进去搜索 PerfMon ,就是我们要找的了, 点击安装 , 从插件简介里也能看到文档地址 在文档中找到 Server Agent的下载地址 在被测服务器中安装 Server Agent , linux 直接运行 serverAgent.sh 默认端口为 4444 添加监控:点 Add Row 添加目标服务器的ip和端口就行, 端口默认4444 以上就是一套简单的tcp压测测试了 原文地址]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php开发过程中不常碰到的error (2.28更新)]]></title>
    <url>%2F2019%2F02%2F28%2Fphp-unsual-mistakes%2F</url>
    <content type="text"><![CDATA[这里做一些备注,以防再次碰到 url 当中的参数有 &amp;timestamp=1234567890这样的字段会被转义成xtamp=1234567890这个不仅存在于页面解析当中,当使用 curl 请求时拼接的参数有这种格式的也会发生转义解决方法有两个: 把 timestamp 这个参数放在 urlQuery 的最前面, ?timestamp=1234567890 这样避免出现 &amp;time发生转义的情况 将&amp;用&amp;amp;来代替 Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.出现这句话通常说明你在用的 php 版本是5.6.而且在php&lt;=5.6的时候,进行 application/json格式的 post 提交会把数据放在$HTTP_RAW_POST_DATA这个系统变量里面,在php&gt;=7的时候这个变量被移除了,统统归总到php://input这里解决方法: 根据系统提示的走: Although that indeed would be technically impossible (as $HTTP_RAW_POST_DATA is populated in the bootstrapping phase of the PHP process) allow one to override the setting by means of calling ini_set. 要确保自己的系统中没有使用 HTTP_RAW_POST_DATA这个变量,直接在php.ini里面禁掉它的设置,但是容易出现系统中又打开的情况(在框架中很常见) 改一下自己的提交方式, 使用 application/form-data或者application/x-www-form-urlencoded这种格式的提交, 然后在后端接收数据的时候再转成自己需要的格式(通常是数组) 参考资料 Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’这种情况出现在平时运行的好好的, 但是突然换 cli 模式后这个配置就出问题了,原因在当 host=localhost时走的是 unix:socket 链接, 当host=127.0.0.1走的是 tcp 链接,这在php-fpm和php-cli中有点区别,尤其是本地没有安装 mysql 的时候解决方法有三种: 将本地链接配置统一成 127.0.0.1 查看 MySQL 中的user表, host=localhost和host=127.0.0.1是不是用的同一个账号密码 配置php.ini文件中的pdo_mysql.default_socket= 写上完整的 socket 路径以上三种方法都可以试一下参考资料 常驻内存时发生的事情这个是 phper 很少碰到但是很常见的情况, 比如用 swoole 启动了一个常驻进程的服务, 那么就一定要小心使用静态变量,在同步模式下会发生变量污染, 还有就是 redis,mysql 这类的链接,你会发现长时间静置以后就会出现一些摸不着头脑的问题, 这种情况不妨想一下是不是 server 端回收了这个 socket,因此在 client 端怎么都写入不进去. 还有就是 php 在读取消息的时候,出现消息过长的情况,那么就要考虑EOF终止符的问题了… 单次 http 每一次请求都是全新的代码, 不用自己考虑 gc 的问题, 但是在常驻内存的时候,这些就是一个个的大坑了 mysql has gone away产生这个错误的主要原因是 mysql server 端断开了链接, client 端还拿着这个句柄去请求,解决方式有两种: show global variables like &#39;%timeout&#39;; 查看 wait_timeout 的时长,适当的调长一点, 这种方法治标不治本,而且有隐患 12mysql&gt; set global wait_timeout=10;mysql&gt; show global variables like 'wait_timeout'; 使用 mysql 之前需要 mysql_ping() 一下, 如果出现断开的错误就启动重连机制 js 和 php 交互传中文参数的编解码问题之前碰到了问题是:在 php 端 urlencode 的值为:1orderid%3D21111111110001954%26pid%3D257742%26reason%3D%E4%B8%AA%E4%BA%BA%E6%96%B9%E9%9D%A2%E5%8E%9F%E5%9B%A0_%E4%BD%BF%E7%94%A8%E7%BA%A2%E5%8C%85%E9%87%8D%E6%96%B0%E4%B8%8B%E5%8D%95%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f 需要 urldecode 一次 而在 js 端的结果是:1orderid%3D21111111110002170%26pid%3D257742%26reason%3D%25E4%25B8%25AA%25E4%25BA%25BA%25E6%2596%25B9%25E9%259D%25A2%25E5%258E%259F%25E5%259B%25A0_%25E4%25B8%25AA%25E4%25BA%25BA%25E8%25BA%25AB%25E4%25BD%2593%25E5%258E%259F%25E5%259B%25A0%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f 需要 urldecode 两次 查阅资料后:12345678910111213在后端是PHP程序的情况下，保持前端Javascript和PHP之间传值的统一编码可以使用以下函数进行处理： WEB前端JavaScript 编码：escape(encodeURI(string)) 解码：unescape(decodeURI(string)) WEB后端Php 编码：urlencode(string) 解码：urldecode(urldecode(string)) 为什么要encodeURI(url)两次才不会出现乱码？ PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent 的区别rawurlencode遵守是94年国际标准备忘录RFC 1738 urlencode实现的是传统做法，和上者的主要区别是对空格的转义是’+’而不是’%20’javascript的encodeURL也是94年标准，而javascript的escape是另一种用”%xxx”标记unicode编码的方法。推荐在PHP中使用用rawurlencode。弃用urlencode 样例source:超级无敌的人sadha sajdh数据样本sdls fhejrthcxzb.file.jpeg PHP urlencode:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha+sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls+fhejrthcxzb.file.jpeg PHP rawurlencode:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg Javascript encodeURI|encodeURIComponent:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg Javascript escape:%u8D85%u7EA7%u65E0%u654C%u7684%u4EBAsadha%20sajdh%u6570%u636E%u6837%u672Csdls%20fhejrthcxzb.file.jpeg 帖子原文 在前端还有个问题就是, js 的 encodeURIComponent 和 encodeURI 都不会转换 _-.!~*&#39;()# 这些保留字符, 而在后端的rawurlencode 则是会转换的, 因此需要前端单独把这几个给拎出来, 如下:12"*".charCodeAt(0) // 42String.fromCharCode(42) // * 这里有张图说的很明白图片来源 关于出现 &lt;U+200B&gt; 这种 zero-width space 字符如果出现 mb_substr 这类操作的时候, 会出现字数判断错误的问题, 这个有时候很难排查, 因为在 win 上,使用命令行或者 linux 上用cat命令是看不到字符间是有 &lt;U+200B&gt; 的, 如下: 这玩意儿出现的场景就是: 在前端输入框中输入几个字, 然后复制粘贴. 这样尽管看起来之间没有空格, 但是其中还是插入了这个字符这个就是 zero-width space 零宽空格, 处理的办法也很简单, 前端传值之前给过滤一下, 比如 https://stackoverflow.com/questions/7055600/u200b-zero-width-space-characters-in-my-js-code-where-did-they-come-from 或 https://codeday.me/bug/20171122/97765.html 后端 php 处理的话和这个不一样, 使用 utf-8 的处理方式, 可以参考这篇文章 特殊字符的删除办法与原理 替换这种编码123$value = str_replace("\xe2\x80\x8b", '', $value);$value = str_replace("\xe2\x80\x8c", '', $value);$value = str_replace("\xe2\x80\x8d", '', $value); 编码对照如下: mac 设置crontab -e ： “/usr/bin/vi” exited with status 1输入以下命令1234export EDITOR=vimsudo touch /etc/crontabcrontab -ecrontab -l 把默认编辑器从 vi 改成 vim 原文 出现: The “https://bower.herokuapp.com/packages/jquery&quot; file could not be downloaded (HTTP/1.1 502 Bad Gateway)yii2 更新的时候静态资源出现问题, 执行 composer global require &quot;fxp/composer-asset-plugin:~1.4.4&quot; 问题来源 出现: Jquery UI 1.11.4 and jquery 3.0 的版本兼容问题这个是在部署 adminLTE + rbac 时候遇上的, 打开 /admin/menu/create 会报 Jquery UI error - f.getClientRects is not a function 错误 解决方法:配置文件: config/web.php1234567891011121314151617... 'components' =&gt; [ ... //静态资源 'assetManager' =&gt; [ ... 'assetMap' =&gt; [ 'jquery.js' =&gt; 'https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js', // 'jquery.min.js' =&gt; 'https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js',// 'jquery.js' =&gt; '@web/js/jquery/jquery.js',// 'jquery.min.js' =&gt; '@web/js/jquery/jquery.js', ], ... ], ... ]... 把相应的 jquery 替换成 v2.2.4 解决问题来源 macOS brew安装php7.1 以及swoole扩展brew改版后内核集成了php, 所以可以直接安装安装php1brew install php@7.1 按提示把12echo 'export PATH="/usr/local/opt/php@7.1/bin:$PATH"' &gt;&gt; ~/.zshrcecho 'export PATH="/usr/local/opt/php@7.1/sbin:$PATH"' &gt;&gt; ~/.zshrc 这些放到你本地命令行配置里面, 然后生成一个软链1brew link php@7.1 --force 安装扩展就得使用pecl工具了12cd /usr/local/opt/php@7.1 # 执行完 brew link 之后就按软链的来, 这样的好处就是不用记小版本号, 路径短pecl install swoole # 提示 'openssl/ssl.h' file not found 就是你安装的时候别选 ssl支持就行 如果提示 No releases available for package “pecl.php.net/swoole”参考 执行 ‘pecl install swoole’之后，遇到的一些坑 , 按提示一步步走应该没问题 安装完毕之后需要变一下配置12345php -i | grep .ini...Loaded Configuration File =&gt; /usr/local/etc/php/7.1/php.ini //当前加载的配置文件路径...cd /usr/local/etc/php/7.1 先删除 php.ini 里面第一行的 extension=swoole.so 改成这个so文件的真实路径, 推荐放到隔壁的 conf.d 目录底下然后php -m | grep sw 可以看一下了安装其他扩展也是按这个路数来 出现 Connection reset by peer 报错这是个tcp链接上的错误, 意味着 链接过程中读或者写出现异常, 出现的原因: AB两端, A端关闭了链接, B端仍在发送, 则抛异常 AB两端, A退出但没关闭链接, 则B在读的时候抛异常 排查: 先看看server端是不是对包大小进行了限制, buffer分配是否足够 是不是程序链接到上限了, 被服务器误杀 防火墙问题 Warning: preg_match() [function.preg-match]: Compilation failed: PCRE does not support \L, \l, \N, \U, or \u atphp正则匹配中文字符的时候, 使用 /^[\u4e00-\u9fa5]+$/ 这一条就会报上面的错误, 正确的写法应该是:123456$str = "php编程";if (preg_match("/^[\x&#123;4e00&#125;-\x&#123;9fa5&#125;]+$/u",$str)) &#123;print("该字符串全部是中文");&#125; else &#123;print("该字符串不全部是中文");&#125; php preg_match 正则匹配中文 php匹配 UTF-8 with DOM 的字符这个和上面的匹配中文是一起出现的, win上使用 UTF-8 格式的txt文件在linux上打开就会变成 UTF-8 with DOM 这个类型, 文件内容中会存在dom头, 从而干扰到一些判断, 比如正则匹配解决办法也简单, 去掉就行1234567// 简单的将win上的txt文件转成utf-8格式function toUTF8($str)&#123; $type = mb_detect_encoding($str, array("ASCII","UTF-8","GB2312","GBK","BIG5")); $result = iconv($type, 'UTF-8//IGNORE', $str); // 防止UTF-8 with BOM 的情况 return trim($result, "\xEF\xBB\xBF");&#125; 不过 utf-8 with dom 对php来说是个隐患, 因为php没有对这块的处理, 会出现ZERO WIDTH NO-BREAK SPACE这样的问题, 有数据但是不会在页面输出 参考:PHP UTF-8的 BOM 问题解决]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Golang 需要避免踩的 50 个坑]]></title>
    <url>%2F2019%2F01%2F31%2Fgo-50-tips%2F</url>
    <content type="text"><![CDATA[Golang 需要避免踩的 50 个坑]]></content>
      <categories>
        <category>精选转载</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Go 的 for Range 上的一个坑]]></title>
    <url>%2F2019%2F01%2F30%2Fgo-for-range-error%2F</url>
    <content type="text"><![CDATA[range作为go的一个语法糖在进行迭代的时候是很方便的, 但6是传址赋值的时候需要小心一点 出现问题直接上代码: 12345678910111213141516171819202122232425262728293031package mainimport "fmt"func main() &#123; slice := []int&#123;0, 1, 2, 3&#125; myMap := make(map[int]*int) for index, value := range slice &#123; fmt.Printf("value's memery address: %v | value's value: %v \n", &amp;value, value) myMap[index] = &amp;value &#125; fmt.Println("=====new map by range=====") fmt.Printf("result: %v \n", myMap) prtMap(myMap) myMap2 := make(map[int]*int) for i := 0; i &lt; len(slice); i++ &#123; myMap2[i] = &amp;slice[i] &#125; fmt.Println("=====new map by for=====") fmt.Printf("result: %v \n", myMap2) prtMap(myMap2)&#125;func prtMap(myMap map[int]*int) &#123; for key, value := range myMap &#123; fmt.Printf("map[%v]=%v\n", key, *value) &#125;&#125; 输出:1234567891011121314151617181920value's memery address: 0xc0000160a8 | value's value: 0value's memery address: 0xc0000160a8 | value's value: 1value's memery address: 0xc0000160a8 | value's value: 2value's memery address: 0xc0000160a8 | value's value: 3=====new map by range=====result: map[0:0xc0000160a8 1:0xc0000160a8 2:0xc0000160a8 3:0xc0000160a8]map[1]=3map[2]=3map[3]=3map[0]=3i's memery address: 0xc000016120 | value: 0i's memery address: 0xc000016120 | value: 1i's memery address: 0xc000016120 | value: 2i's memery address: 0xc000016120 | value: 3=====new map by for=====result: map[2:0xc00001c110 3:0xc00001c118 0:0xc00001c100 1:0xc00001c108]map[2]=2map[3]=3map[0]=0map[1]=1 猜测原因range 和 for 进行赋值操作只执行了一次, 因此在上面那个例子中 value和i的内存地址在循环的时候都没变过, 在进行值拷贝的时候是没问题的, 但是一旦加上 &amp; 的时候就变得很危险了, 造成的结果就是上面那个例子中的问题, 新数组存的都是同一个内存地址, 在 for 循环的时候因为只是利用的索引, 没有直接用到切片的值而不会引发这些问题, 在 range 的时候会出现 key,value 同时出现,那么就要小心处理了, 因为这里的value并不是切片中的原值, 而是一个拷贝出来的 Go Range 内部实现go语言坑之for range 类似的问题123456789101112131415161718package mainimport ( "fmt" "sync")func main() &#123; wg := sync.WaitGroup&#123;&#125; for i := 0; i &lt; 4; i++ &#123; wg.Add(1) go func() &#123; fmt.Printf("i is %d \n", i) wg.Done() &#125;() &#125; wg.Wait()&#125; 1输出 4,4,4,4 这个和上一个的问题还不一样, 这个就是闭包的执行顺序以及变量作用域的问题, 在执行闭包的时候for循环已经执行完毕,此时i=4, 接下来才会执行闭包内的函数, 规避这个问题也简单, 把变量的作用域改一下就行, 还有就是函数参数的值拷贝特点1234567for i := 0; i &lt; 4; i++ &#123; wg.Add(1) go func(i int) &#123; fmt.Printf("i is %d \n", i) wg.Done() &#125;(i) &#125; 闭包和变量作用域]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>range</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Mac上一些好玩的命令行工具]]></title>
    <url>%2F2019%2F01%2F18%2Ftool-mac-terminal-awesome%2F</url>
    <content type="text"><![CDATA[mac上一些有意思的命令行小工具 asciinema 和 svg-termassiiname 是用来命令行录屏的, svg-term 将文件转换成svg动图, 这个做截屏很方便 安装:12brew install asciinemanpm install -g svg-term 使用方式:12asciinema rec cast.json // 开始录制, 数据保存在cast.json, 按 ctrl+d 保存cat cast.json | svg-term-cli //输出svg文件 比如下图缺点就是如果文件特别大帧率受到严重的影响 sl 和 cmatrix 小特效玩具安装12brew install slbrew install cmatrix 平时装哔用的 bat安装1brew install bat 替代 cat 命令, 支持代码高亮 ncdu 清理磁盘如标题, 清理磁盘, 直接运行就行 安装1brew install ncdu 收藏链接:优秀的命令行工具整理（一）优秀的命令行工具整理（二）]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>mac</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Gorilla Websocket 搞一个聊天室]]></title>
    <url>%2F2019%2F01%2F15%2Fgo-chat%2F</url>
    <content type="text"><![CDATA[这个demo实现了: 消息广播 心跳检测 提供了一个通过命令行来进行聊天的例子 具体逻辑都在 websocket.go 这个文件里 这里的核心就是 aliveList 这个全局变量, 负责把消息分发给各客户端, 事件用channel来传递, 减少阻塞 单个链接会在 aliveList 中注册, ConnList 就是所有活跃的链接 12345678910111213141516// AliveList 当前在线列表type AliveList struct &#123; ConnList map[string]*Client register chan *Client destroy chan *Client broadcast chan Message cancel chan int Len int&#125;// Client socket客户端type Client struct &#123; ID string conn *websocket.Conn cancel chan int&#125; 服务启动后会执行事件监听循环 123456789101112131415161718192021222324252627282930313233343536373839404142// 启动监听func (al *AliveList) run() &#123; log.Println("开始监听注册事件") for &#123; select &#123; case client := &lt;-al.register: log.Println("注册事件:", client.ID) al.ConnList[client.ID] = client al.Len++ al.SysBroadcast(ConnectedMessage, Message&#123; ID: client.ID, Content: "connected", SentAt: time.Now().Unix(), &#125;) case client := &lt;-al.destroy: log.Println("销毁事件:", client.ID) err := client.conn.Close() if err != nil &#123; log.Printf("destroy Error: %v \n", err) &#125; delete(al.ConnList, client.ID) al.Len-- case message := &lt;-al.broadcast: log.Printf("广播事件: %s %s %d \n", message.ID, message.Content, message.Type) for id := range al.ConnList &#123; if id != message.ID &#123; err := al.sendMessage(id, message) if err != nil &#123; log.Println("broadcastError: ", err) &#125; &#125; &#125; case sign := &lt;-al.cancel: log.Println("终止事件: ", sign) os.Exit(0) &#125; &#125;&#125; 因为消息的类型比较多, 单纯字符串无法满足需求, 就选用了比较常用的json格式去传递, 消息目前分: 12345678910111213141516171819202122const ( // SystemMessage 系统消息 SystemMessage = iota // BroadcastMessage 广播消息(正常的消息) BroadcastMessage // HeartBeatMessage 心跳消息 HeartBeatMessage // ConnectedMessage 上线通知 ConnectedMessage // DisconnectedMessage 下线通知 DisconnectedMessage)// Message 消息体结构type Message struct &#123; ID string Content string SentAt int64 Type int // &lt;- SystemMessage 等类型就是这里了&#125; 如果有空闲时间就再搞搞多聊天室的实现, 以及优化一下目前的事件循环逻辑如果还有更多的余力, 就搞一个好看点的客户端? demo地址]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Yii2 断线重连问题]]></title>
    <url>%2F2018%2F12%2F19%2Fyii-mysql%2F</url>
    <content type="text"><![CDATA[yii2 + swoole 的模式下因为使用swoole做的常驻内存服务, 那么之前的设计思路会有一点偏差, 不是第一眼能看到的就是 mysql has gone away的问题 目前解决思路就是当sql命令报错mysql has gone away的时候就断开重连再重新执行一次 参考 Yii2实现mysql断线重连 重写一个command类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php namespace common\components; use Yii; /** * 新增加执行sql时断开重连 * 数据库连接断开异常 * errorInfo = [''HY000',2006,'错误信息'] * Class Command * @package common\components */ class Command extends \yii\db\Command &#123; const EVENT_DISCONNECT = 'disconnect'; /** * 处理修改类型sql的断线重连问题 * @return int * @throws \Exception * @throws \yii\db\Exception */ public function execute() &#123; try&#123; return parent::execute(); &#125;catch(\Exception $e)&#123; if($this-&gt;handleException($e)) return parent::execute(); throw $e; &#125; &#125; /** * 处理查询类sql断线重连问题 * @param string $method * @param null $fetchMode * @return mixed * @throws \Exception * @throws \yii\db\Exception */ protected function queryInternal($method, $fetchMode = null) &#123; try&#123; return parent::queryInternal($method, $fetchMode); &#125;catch(\Exception $e)&#123; if($this-&gt;handleException($e)) return parent::queryInternal($method, $fetchMode); throw $e; &#125; &#125; /** * 处理执行sql时捕获的异常信息 * 并且根据异常信息来决定是否需要重新连接数据库 * @param \Exception $e * @return bool true: 需要重新执行sql false: 不需要重新执行sql */ private function handleException(\Exception $e) &#123; //如果不是yii\db\Exception异常抛出该异常或者不是MySQL server has gone away $offset = stripos($e-&gt;getMessage(),'MySQL server has gone away'); if(($e instanceof \yii\db\Exception) == false OR $offset === false) //OR $e-&gt;errorInfo[0] != 'HY000' OR $e-&gt;errorInfo[1] != 2006) return false; $this-&gt;trigger(static::EVENT_DISCONNECT); //将pdo设置从null $this-&gt;pdoStatement = NULL; //$this-&gt;db-&gt;resetPdo(); $this-&gt;db-&gt;close(); return true; &#125; &#125; 在配置文件中关于db的配置给加上指定的class123456789101112&lt;?php return [ 'components' =&gt; [ 'db' =&gt; [ 'class' =&gt; 'yii\db\Connection', 'commandClass' =&gt; 'common\components\Command',// 加上这个 'username' =&gt; 'XXX', 'password' =&gt; 'XXX', 'dsn' =&gt; 'mysql:host=XXX;dbname=XXX;port=3306', ], ], ]; 相关文章:Yii2实现mysql断线重连在mysql中connection设置和wait-timeout的设置查看mysql连接情况，以及连接超时时间设置源码剖析Yii错误 Invalid parameter number: no parameters were boundYii 数据库重连告别General error: 2006 MySQL server has gone away]]></content>
      <categories>
        <category>yii2</category>
      </categories>
      <tags>
        <tag>yii2</tag>
      </tags>
  </entry>
</search>
