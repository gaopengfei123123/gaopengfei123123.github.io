<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jmeter 对Tcp进行压测]]></title>
    <url>%2F2019%2F04%2F30%2Ftools-jmeter%2F</url>
    <content type="text"><![CDATA[jmeter是个好工具, 跨平台, 有GUI, 简单易用, 扩展多 安装本地环境为macOS Mojave 10.14.4 本地需要安装java8jmeter官方下载地址jmeter插件下载 当前下载的jmeter版本为 5.1.1解压下载之后, 运行命令:1sh ~/Downloads/apache-jmeter-5.1.1/bin/jmeter 就运行起来了 进行tcp压测首先创建Thread Group 注意几个关键点: Number of Threads (users) 创建进程组, 相当于多少并发 Ramp-Up Period (in seconds) 设定的并发值在多少秒内到达预期, 模拟自然流量 Loop Count 每个进程组循环多少次 Loop Count * Number of Threads 就是整体请求数量了 创建tcp Sampler 这篇文章是使用最基本的文字tcp传输 看图说话, TCP classname默认为: org.apache.jmeter.protocol.tcp.sampler.TCPClientImpl, 可以直接从 Text to send 中传入文本传文本的时候一定要输入之后加一个回车,写\n都不管用, 必须 是回车, 它是自动转换的, 不然会造成数据找不到终止断点 如果使用 org.apache.jmeter.protocol.tcp.sampler.BinaryTCPClientImpl 则需要在 End of line byte value 里面传值, 通常是10且 Text to send 传的是16进制数据 创建 summary report 用于做统计表格 创建 view results tree 用于查看请求数据返回数据 安装cpu/内存监控插件5.1.1 版本的和之前搜的有些不一样, 现在有了一个内置的扩展商店 扩展下载地址 Download plugins-manager.jar and put it into lib/ext directory, then restart JMeter. 看到这句话没? 点就行了, 然后把它放到jmeter目录 lib/ext下,重启jmeter就能看到了 点进去搜索 PerfMon ,就是我们要找的了, 点击安装 , 从插件简介里也能看到文档地址 在文档中找到 Server Agent的下载地址 在被测服务器中安装 Server Agent , linux 直接运行 serverAgent.sh 默认端口为 4444 添加监控:点 Add Row 添加目标服务器的ip和端口就行, 端口默认4444 以上就是一套简单的tcp压测测试了 原文地址]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php开发过程中不常碰到的error (2.28更新)]]></title>
    <url>%2F2019%2F02%2F28%2Fphp-unsual-mistakes%2F</url>
    <content type="text"><![CDATA[这里做一些备注,以防再次碰到 url 当中的参数有 &amp;timestamp=1234567890这样的字段会被转义成xtamp=1234567890这个不仅存在于页面解析当中,当使用 curl 请求时拼接的参数有这种格式的也会发生转义解决方法有两个: 把 timestamp 这个参数放在 urlQuery 的最前面, ?timestamp=1234567890 这样避免出现 &amp;time发生转义的情况 将&amp;用&amp;amp;来代替 Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.出现这句话通常说明你在用的 php 版本是5.6.而且在php&lt;=5.6的时候,进行 application/json格式的 post 提交会把数据放在$HTTP_RAW_POST_DATA这个系统变量里面,在php&gt;=7的时候这个变量被移除了,统统归总到php://input这里解决方法: 根据系统提示的走: Although that indeed would be technically impossible (as $HTTP_RAW_POST_DATA is populated in the bootstrapping phase of the PHP process) allow one to override the setting by means of calling ini_set. 要确保自己的系统中没有使用 HTTP_RAW_POST_DATA这个变量,直接在php.ini里面禁掉它的设置,但是容易出现系统中又打开的情况(在框架中很常见) 改一下自己的提交方式, 使用 application/form-data或者application/x-www-form-urlencoded这种格式的提交, 然后在后端接收数据的时候再转成自己需要的格式(通常是数组) 参考资料 Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’这种情况出现在平时运行的好好的, 但是突然换 cli 模式后这个配置就出问题了,原因在当 host=localhost时走的是 unix:socket 链接, 当host=127.0.0.1走的是 tcp 链接,这在php-fpm和php-cli中有点区别,尤其是本地没有安装 mysql 的时候解决方法有三种: 将本地链接配置统一成 127.0.0.1 查看 MySQL 中的user表, host=localhost和host=127.0.0.1是不是用的同一个账号密码 配置php.ini文件中的pdo_mysql.default_socket= 写上完整的 socket 路径以上三种方法都可以试一下参考资料 常驻内存时发生的事情这个是 phper 很少碰到但是很常见的情况, 比如用 swoole 启动了一个常驻进程的服务, 那么就一定要小心使用静态变量,在同步模式下会发生变量污染, 还有就是 redis,mysql 这类的链接,你会发现长时间静置以后就会出现一些摸不着头脑的问题, 这种情况不妨想一下是不是 server 端回收了这个 socket,因此在 client 端怎么都写入不进去. 还有就是 php 在读取消息的时候,出现消息过长的情况,那么就要考虑EOF终止符的问题了… 单次 http 每一次请求都是全新的代码, 不用自己考虑 gc 的问题, 但是在常驻内存的时候,这些就是一个个的大坑了 mysql has gone away产生这个错误的主要原因是 mysql server 端断开了链接, client 端还拿着这个句柄去请求,解决方式有两种: show global variables like &#39;%timeout&#39;; 查看 wait_timeout 的时长,适当的调长一点, 这种方法治标不治本,而且有隐患 12mysql&gt; set global wait_timeout=10;mysql&gt; show global variables like 'wait_timeout'; 使用 mysql 之前需要 mysql_ping() 一下, 如果出现断开的错误就启动重连机制 js 和 php 交互传中文参数的编解码问题之前碰到了问题是:在 php 端 urlencode 的值为:1orderid%3D21111111110001954%26pid%3D257742%26reason%3D%E4%B8%AA%E4%BA%BA%E6%96%B9%E9%9D%A2%E5%8E%9F%E5%9B%A0_%E4%BD%BF%E7%94%A8%E7%BA%A2%E5%8C%85%E9%87%8D%E6%96%B0%E4%B8%8B%E5%8D%95%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f 需要 urldecode 一次 而在 js 端的结果是:1orderid%3D21111111110002170%26pid%3D257742%26reason%3D%25E4%25B8%25AA%25E4%25BA%25BA%25E6%2596%25B9%25E9%259D%25A2%25E5%258E%259F%25E5%259B%25A0_%25E4%25B8%25AA%25E4%25BA%25BA%25E8%25BA%25AB%25E4%25BD%2593%25E5%258E%259F%25E5%259B%25A0%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f 需要 urldecode 两次 查阅资料后:12345678910111213在后端是PHP程序的情况下，保持前端Javascript和PHP之间传值的统一编码可以使用以下函数进行处理： WEB前端JavaScript 编码：escape(encodeURI(string)) 解码：unescape(decodeURI(string)) WEB后端Php 编码：urlencode(string) 解码：urldecode(urldecode(string)) 为什么要encodeURI(url)两次才不会出现乱码？ PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent 的区别rawurlencode遵守是94年国际标准备忘录RFC 1738 urlencode实现的是传统做法，和上者的主要区别是对空格的转义是’+’而不是’%20’javascript的encodeURL也是94年标准，而javascript的escape是另一种用”%xxx”标记unicode编码的方法。推荐在PHP中使用用rawurlencode。弃用urlencode 样例source:超级无敌的人sadha sajdh数据样本sdls fhejrthcxzb.file.jpeg PHP urlencode:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha+sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls+fhejrthcxzb.file.jpeg PHP rawurlencode:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg Javascript encodeURI|encodeURIComponent:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg Javascript escape:%u8D85%u7EA7%u65E0%u654C%u7684%u4EBAsadha%20sajdh%u6570%u636E%u6837%u672Csdls%20fhejrthcxzb.file.jpeg 帖子原文 在前端还有个问题就是, js 的 encodeURIComponent 和 encodeURI 都不会转换 _-.!~*&#39;()# 这些保留字符, 而在后端的rawurlencode 则是会转换的, 因此需要前端单独把这几个给拎出来, 如下:12"*".charCodeAt(0) // 42String.fromCharCode(42) // * 这里有张图说的很明白图片来源 关于出现 &lt;U+200B&gt; 这种 zero-width space 字符如果出现 mb_substr 这类操作的时候, 会出现字数判断错误的问题, 这个有时候很难排查, 因为在 win 上,使用命令行或者 linux 上用cat命令是看不到字符间是有 &lt;U+200B&gt; 的, 如下: 这玩意儿出现的场景就是: 在前端输入框中输入几个字, 然后复制粘贴. 这样尽管看起来之间没有空格, 但是其中还是插入了这个字符这个就是 zero-width space 零宽空格, 处理的办法也很简单, 前端传值之前给过滤一下, 比如 https://stackoverflow.com/questions/7055600/u200b-zero-width-space-characters-in-my-js-code-where-did-they-come-from 或 https://codeday.me/bug/20171122/97765.html 后端 php 处理的话和这个不一样, 使用 utf-8 的处理方式, 可以参考这篇文章 特殊字符的删除办法与原理 替换这种编码123$value = str_replace("\xe2\x80\x8b", '', $value);$value = str_replace("\xe2\x80\x8c", '', $value);$value = str_replace("\xe2\x80\x8d", '', $value); 编码对照如下: mac 设置crontab -e ： “/usr/bin/vi” exited with status 1输入以下命令1234export EDITOR=vimsudo touch /etc/crontabcrontab -ecrontab -l 把默认编辑器从 vi 改成 vim 原文 出现: The “https://bower.herokuapp.com/packages/jquery&quot; file could not be downloaded (HTTP/1.1 502 Bad Gateway)yii2 更新的时候静态资源出现问题, 执行 composer global require &quot;fxp/composer-asset-plugin:~1.4.4&quot; 问题来源 出现: Jquery UI 1.11.4 and jquery 3.0 的版本兼容问题这个是在部署 adminLTE + rbac 时候遇上的, 打开 /admin/menu/create 会报 Jquery UI error - f.getClientRects is not a function 错误 解决方法:配置文件: config/web.php1234567891011121314151617... 'components' =&gt; [ ... //静态资源 'assetManager' =&gt; [ ... 'assetMap' =&gt; [ 'jquery.js' =&gt; 'https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js', // 'jquery.min.js' =&gt; 'https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js',// 'jquery.js' =&gt; '@web/js/jquery/jquery.js',// 'jquery.min.js' =&gt; '@web/js/jquery/jquery.js', ], ... ], ... ]... 把相应的 jquery 替换成 v2.2.4 解决问题来源 macOS brew安装php7.1 以及swoole扩展brew改版后内核集成了php, 所以可以直接安装安装php1brew install php@7.1 按提示把12echo 'export PATH="/usr/local/opt/php@7.1/bin:$PATH"' &gt;&gt; ~/.zshrcecho 'export PATH="/usr/local/opt/php@7.1/sbin:$PATH"' &gt;&gt; ~/.zshrc 这些放到你本地命令行配置里面, 然后生成一个软链1brew link php@7.1 --force 安装扩展就得使用pecl工具了12cd /usr/local/opt/php@7.1 # 执行完 brew link 之后就按软链的来, 这样的好处就是不用记小版本号, 路径短pecl install swoole # 提示 'openssl/ssl.h' file not found 就是你安装的时候别选 ssl支持就行 如果提示 No releases available for package “pecl.php.net/swoole”参考 执行 ‘pecl install swoole’之后，遇到的一些坑 , 按提示一步步走应该没问题 安装完毕之后需要变一下配置12345php -i | grep .ini...Loaded Configuration File =&gt; /usr/local/etc/php/7.1/php.ini //当前加载的配置文件路径...cd /usr/local/etc/php/7.1 先删除 php.ini 里面第一行的 extension=swoole.so 改成这个so文件的真实路径, 推荐放到隔壁的 conf.d 目录底下然后php -m | grep sw 可以看一下了安装其他扩展也是按这个路数来 出现 Connection reset by peer 报错这是个tcp链接上的错误, 意味着 链接过程中读或者写出现异常, 出现的原因: AB两端, A端关闭了链接, B端仍在发送, 则抛异常 AB两端, A退出但没关闭链接, 则B在读的时候抛异常 排查: 先看看server端是不是对包大小进行了限制, buffer分配是否足够 是不是程序链接到上限了, 被服务器误杀 防火墙问题 Warning: preg_match() [function.preg-match]: Compilation failed: PCRE does not support \L, \l, \N, \U, or \u atphp正则匹配中文字符的时候, 使用 /^[\u4e00-\u9fa5]+$/ 这一条就会报上面的错误, 正确的写法应该是:123456$str = "php编程";if (preg_match("/^[\x&#123;4e00&#125;-\x&#123;9fa5&#125;]+$/u",$str)) &#123;print("该字符串全部是中文");&#125; else &#123;print("该字符串不全部是中文");&#125; php preg_match 正则匹配中文 php匹配 UTF-8 with DOM 的字符这个和上面的匹配中文是一起出现的, win上使用 UTF-8 格式的txt文件在linux上打开就会变成 UTF-8 with DOM 这个类型, 文件内容中会存在dom头, 从而干扰到一些判断, 比如正则匹配解决办法也简单, 去掉就行1234567// 简单的将win上的txt文件转成utf-8格式function toUTF8($str)&#123; $type = mb_detect_encoding($str, array("ASCII","UTF-8","GB2312","GBK","BIG5")); $result = iconv($type, 'UTF-8//IGNORE', $str); // 防止UTF-8 with BOM 的情况 return trim($result, "\xEF\xBB\xBF");&#125; 不过 utf-8 with dom 对php来说是个隐患, 因为php没有对这块的处理, 会出现ZERO WIDTH NO-BREAK SPACE这样的问题, 有数据但是不会在页面输出 参考:PHP UTF-8的 BOM 问题解决]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 目标]]></title>
    <url>%2F2019%2F02%2F18%2F2019-goal%2F</url>
    <content type="text"><![CDATA[以前是没钱没时间, 现在我想做个有规划的人: 去一趟加拿大见一个人 拿驾照 看5本技术书, 达到理解80%的程度, 笔记跟上 健身, 最低目标30分钟5公里 过200道leetcode, hard难度以下需要想出次优解, hard 难度能做到理解最优解 以上能完成的话就接下来: 自己搞一个基于k8s的微服务架构 这些目标截止到 2020-2-18号 吧]]></content>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Golang 需要避免踩的 50 个坑]]></title>
    <url>%2F2019%2F01%2F31%2Fgo-50-tips%2F</url>
    <content type="text"><![CDATA[Golang 需要避免踩的 50 个坑]]></content>
      <categories>
        <category>精选转载</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Go 的 for Range 上的一个坑]]></title>
    <url>%2F2019%2F01%2F30%2Fgo-for-range-error%2F</url>
    <content type="text"><![CDATA[range作为go的一个语法糖在进行迭代的时候是很方便的, 但6是传址赋值的时候需要小心一点 出现问题直接上代码: 12345678910111213141516171819202122232425262728293031package mainimport "fmt"func main() &#123; slice := []int&#123;0, 1, 2, 3&#125; myMap := make(map[int]*int) for index, value := range slice &#123; fmt.Printf("value's memery address: %v | value's value: %v \n", &amp;value, value) myMap[index] = &amp;value &#125; fmt.Println("=====new map by range=====") fmt.Printf("result: %v \n", myMap) prtMap(myMap) myMap2 := make(map[int]*int) for i := 0; i &lt; len(slice); i++ &#123; myMap2[i] = &amp;slice[i] &#125; fmt.Println("=====new map by for=====") fmt.Printf("result: %v \n", myMap2) prtMap(myMap2)&#125;func prtMap(myMap map[int]*int) &#123; for key, value := range myMap &#123; fmt.Printf("map[%v]=%v\n", key, *value) &#125;&#125; 输出:1234567891011121314151617181920value's memery address: 0xc0000160a8 | value's value: 0value's memery address: 0xc0000160a8 | value's value: 1value's memery address: 0xc0000160a8 | value's value: 2value's memery address: 0xc0000160a8 | value's value: 3=====new map by range=====result: map[0:0xc0000160a8 1:0xc0000160a8 2:0xc0000160a8 3:0xc0000160a8]map[1]=3map[2]=3map[3]=3map[0]=3i's memery address: 0xc000016120 | value: 0i's memery address: 0xc000016120 | value: 1i's memery address: 0xc000016120 | value: 2i's memery address: 0xc000016120 | value: 3=====new map by for=====result: map[2:0xc00001c110 3:0xc00001c118 0:0xc00001c100 1:0xc00001c108]map[2]=2map[3]=3map[0]=0map[1]=1 猜测原因range 和 for 进行赋值操作只执行了一次, 因此在上面那个例子中 value和i的内存地址在循环的时候都没变过, 在进行值拷贝的时候是没问题的, 但是一旦加上 &amp; 的时候就变得很危险了, 造成的结果就是上面那个例子中的问题, 新数组存的都是同一个内存地址, 在 for 循环的时候因为只是利用的索引, 没有直接用到切片的值而不会引发这些问题, 在 range 的时候会出现 key,value 同时出现,那么就要小心处理了, 因为这里的value并不是切片中的原值, 而是一个拷贝出来的 Go Range 内部实现go语言坑之for range 类似的问题123456789101112131415161718package mainimport ( "fmt" "sync")func main() &#123; wg := sync.WaitGroup&#123;&#125; for i := 0; i &lt; 4; i++ &#123; wg.Add(1) go func() &#123; fmt.Printf("i is %d \n", i) wg.Done() &#125;() &#125; wg.Wait()&#125; 1输出 4,4,4,4 这个和上一个的问题还不一样, 这个就是闭包的执行顺序以及变量作用域的问题, 在执行闭包的时候for循环已经执行完毕,此时i=4, 接下来才会执行闭包内的函数, 规避这个问题也简单, 把变量的作用域改一下就行, 还有就是函数参数的值拷贝特点1234567for i := 0; i &lt; 4; i++ &#123; wg.Add(1) go func(i int) &#123; fmt.Printf("i is %d \n", i) wg.Done() &#125;(i) &#125; 闭包和变量作用域]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>range</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Mac上一些好玩的命令行工具]]></title>
    <url>%2F2019%2F01%2F18%2Ftool-mac-terminal-awesome%2F</url>
    <content type="text"><![CDATA[mac上一些有意思的命令行小工具 asciinema 和 svg-termassiiname 是用来命令行录屏的, svg-term 将文件转换成svg动图, 这个做截屏很方便 安装:12brew install asciinemanpm install -g svg-term 使用方式:12asciinema rec cast.json // 开始录制, 数据保存在cast.json, 按 ctrl+d 保存cat cast.json | svg-term-cli //输出svg文件 比如下图缺点就是如果文件特别大帧率受到严重的影响 sl 和 cmatrix 小特效玩具安装12brew install slbrew install cmatrix 平时装哔用的 bat安装1brew install bat 替代 cat 命令, 支持代码高亮 ncdu 清理磁盘如标题, 清理磁盘, 直接运行就行 安装1brew install ncdu 收藏链接:优秀的命令行工具整理（一）优秀的命令行工具整理（二）]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>mac</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Gorilla Websocket 搞一个聊天室]]></title>
    <url>%2F2019%2F01%2F15%2Fgo-chat%2F</url>
    <content type="text"><![CDATA[这个demo实现了: 消息广播 心跳检测 提供了一个通过命令行来进行聊天的例子 具体逻辑都在 websocket.go 这个文件里 这里的核心就是 aliveList 这个全局变量, 负责把消息分发给各客户端, 事件用channel来传递, 减少阻塞 单个链接会在 aliveList 中注册, ConnList 就是所有活跃的链接 12345678910111213141516// AliveList 当前在线列表type AliveList struct &#123; ConnList map[string]*Client register chan *Client destroy chan *Client broadcast chan Message cancel chan int Len int&#125;// Client socket客户端type Client struct &#123; ID string conn *websocket.Conn cancel chan int&#125; 服务启动后会执行事件监听循环 123456789101112131415161718192021222324252627282930313233343536373839404142// 启动监听func (al *AliveList) run() &#123; log.Println("开始监听注册事件") for &#123; select &#123; case client := &lt;-al.register: log.Println("注册事件:", client.ID) al.ConnList[client.ID] = client al.Len++ al.SysBroadcast(ConnectedMessage, Message&#123; ID: client.ID, Content: "connected", SentAt: time.Now().Unix(), &#125;) case client := &lt;-al.destroy: log.Println("销毁事件:", client.ID) err := client.conn.Close() if err != nil &#123; log.Printf("destroy Error: %v \n", err) &#125; delete(al.ConnList, client.ID) al.Len-- case message := &lt;-al.broadcast: log.Printf("广播事件: %s %s %d \n", message.ID, message.Content, message.Type) for id := range al.ConnList &#123; if id != message.ID &#123; err := al.sendMessage(id, message) if err != nil &#123; log.Println("broadcastError: ", err) &#125; &#125; &#125; case sign := &lt;-al.cancel: log.Println("终止事件: ", sign) os.Exit(0) &#125; &#125;&#125; 因为消息的类型比较多, 单纯字符串无法满足需求, 就选用了比较常用的json格式去传递, 消息目前分: 12345678910111213141516171819202122const ( // SystemMessage 系统消息 SystemMessage = iota // BroadcastMessage 广播消息(正常的消息) BroadcastMessage // HeartBeatMessage 心跳消息 HeartBeatMessage // ConnectedMessage 上线通知 ConnectedMessage // DisconnectedMessage 下线通知 DisconnectedMessage)// Message 消息体结构type Message struct &#123; ID string Content string SentAt int64 Type int // &lt;- SystemMessage 等类型就是这里了&#125; 如果有空闲时间就再搞搞多聊天室的实现, 以及优化一下目前的事件循环逻辑如果还有更多的余力, 就搞一个好看点的客户端? demo地址]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Yii2 断线重连问题]]></title>
    <url>%2F2018%2F12%2F19%2Fyii-mysql%2F</url>
    <content type="text"><![CDATA[yii2 + swoole 的模式下因为使用swoole做的常驻内存服务, 那么之前的设计思路会有一点偏差, 不是第一眼能看到的就是 mysql has gone away的问题 目前解决思路就是当sql命令报错mysql has gone away的时候就断开重连再重新执行一次 参考 Yii2实现mysql断线重连 重写一个command类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php namespace common\components; use Yii; /** * 新增加执行sql时断开重连 * 数据库连接断开异常 * errorInfo = [''HY000',2006,'错误信息'] * Class Command * @package common\components */ class Command extends \yii\db\Command &#123; const EVENT_DISCONNECT = 'disconnect'; /** * 处理修改类型sql的断线重连问题 * @return int * @throws \Exception * @throws \yii\db\Exception */ public function execute() &#123; try&#123; return parent::execute(); &#125;catch(\Exception $e)&#123; if($this-&gt;handleException($e)) return parent::execute(); throw $e; &#125; &#125; /** * 处理查询类sql断线重连问题 * @param string $method * @param null $fetchMode * @return mixed * @throws \Exception * @throws \yii\db\Exception */ protected function queryInternal($method, $fetchMode = null) &#123; try&#123; return parent::queryInternal($method, $fetchMode); &#125;catch(\Exception $e)&#123; if($this-&gt;handleException($e)) return parent::queryInternal($method, $fetchMode); throw $e; &#125; &#125; /** * 处理执行sql时捕获的异常信息 * 并且根据异常信息来决定是否需要重新连接数据库 * @param \Exception $e * @return bool true: 需要重新执行sql false: 不需要重新执行sql */ private function handleException(\Exception $e) &#123; //如果不是yii\db\Exception异常抛出该异常或者不是MySQL server has gone away $offset = stripos($e-&gt;getMessage(),'MySQL server has gone away'); if(($e instanceof \yii\db\Exception) == false OR $offset === false) //OR $e-&gt;errorInfo[0] != 'HY000' OR $e-&gt;errorInfo[1] != 2006) return false; $this-&gt;trigger(static::EVENT_DISCONNECT); //将pdo设置从null $this-&gt;pdoStatement = NULL; //$this-&gt;db-&gt;resetPdo(); $this-&gt;db-&gt;close(); return true; &#125; &#125; 在配置文件中关于db的配置给加上指定的class123456789101112&lt;?php return [ 'components' =&gt; [ 'db' =&gt; [ 'class' =&gt; 'yii\db\Connection', 'commandClass' =&gt; 'common\components\Command',// 加上这个 'username' =&gt; 'XXX', 'password' =&gt; 'XXX', 'dsn' =&gt; 'mysql:host=XXX;dbname=XXX;port=3306', ], ], ]; 相关文章:Yii2实现mysql断线重连在mysql中connection设置和wait-timeout的设置查看mysql连接情况，以及连接超时时间设置源码剖析Yii错误 Invalid parameter number: no parameters were boundYii 数据库重连告别General error: 2006 MySQL server has gone away]]></content>
      <categories>
        <category>yii2</category>
      </categories>
      <tags>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go Mysql数据库连接池的使用]]></title>
    <url>%2F2018%2F12%2F17%2Fgo-mysql-pool%2F</url>
    <content type="text"><![CDATA[建立一个mysql连接池将极大的缩短应用的响应时间, 减少频繁的io开销以及gc, 这在golang里面也是很容易就实现的 示例代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// main.gopackage mainimport ( "database/sql" "fmt" _ "github.com/GO-SQL-Driver/MySQL" "net/http" "time")var db *sql.DBfunc init() &#123; db, _ = sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8") // 设置最大连接数 db.SetMaxOpenConns(300) // 设置最大空闲连接数 db.SetMaxIdleConns(100) // 设置每个链接的过期时间 db.SetConnMaxLifetime(time.Second * 5) err := db.Ping() checkErr(err)&#125;func main() &#123; startServer(":9999")&#125;func startServer(port string) &#123; http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; record := doSomething() fmt.Fprintln(w, record) &#125;) fmt.Printf("listening http://localhost%s\n", port) err := http.ListenAndServe(port, nil) checkErr(err)&#125;func doSomething() map[string]string &#123; rows, err := db.Query("SELECT * FROM test LIMIT 1") checkErr(err) defer rows.Close() columns, _ := rows.Columns() scanArgs := make([]interface&#123;&#125;, len(columns)) values := make([]interface&#123;&#125;, len(columns)) for j := range values &#123; scanArgs[j] = &amp;values[j] &#125; record := make(map[string]string) for rows.Next() &#123; //将行数据保存到record字典 err = rows.Scan(scanArgs...) for i, col := range values &#123; if col != nil &#123; record[columns[i]] = string(col.([]byte)) &#125; &#125; &#125; // fmt.Println(record) return record&#125;func doSomething2() map[string]string &#123; dbConn, _ := sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8") defer dbConn.Close() rows, err := dbConn.Query("SELECT * FROM test LIMIT 1") checkErr(err) defer rows.Close() columns, _ := rows.Columns() scanArgs := make([]interface&#123;&#125;, len(columns)) values := make([]interface&#123;&#125;, len(columns)) for j := range values &#123; scanArgs[j] = &amp;values[j] &#125; record := make(map[string]string) for rows.Next() &#123; //将行数据保存到record字典 err = rows.Scan(scanArgs...) for i, col := range values &#123; if col != nil &#123; record[columns[i]] = string(col.([]byte)) &#125; &#125; &#125; // fmt.Println(record) return record&#125;func checkErr(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; 测试代码: 12345678910111213141516171819202122232425262728293031323334353637383940// main_test.gopackage mainimport ( "testing")func TestDoSomething(t *testing.T) &#123; record := doSomething() t.Log(record)&#125;func BenchmarkDoSomething(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; doSomething() &#125;&#125;func BenchmarkDoSomethingParallel(b *testing.B) &#123; b.RunParallel(func(pb *testing.PB) &#123; for pb.Next() &#123; doSomething() &#125; &#125;)&#125;func BenchmarkDoSomethingWithoutPoll(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; doSomething2() &#125;&#125;func BenchmarkDoSomethingWithoutPollParallel(b *testing.B) &#123; b.RunParallel(func(pb *testing.PB) &#123; for pb.Next() &#123; doSomething2() &#125; &#125;)&#125; 测试输出对比:12345678910$ go test --bench=.goos: darwingoarch: amd64BenchmarkDoSomething-4 20000 67898 ns/opBenchmarkDoSomethingParallel-4 50000 29347 ns/opBenchmarkDoSomethingWithoutPoll-4 1000 8400516 ns/opBenchmarkDoSomethingWithoutPollParallel-4 2000 8167164 ns/opPASSok _/Users/gpf/Documents/go/code/mysql_curd/pool 28.857s 关键就是这几个方法:1234567db, _ = sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8")// 设置最大连接数db.SetMaxOpenConns(300)// 设置最大空闲连接数db.SetMaxIdleConns(100)// 设置每个链接的过期时间db.SetConnMaxLifetime(time.Second * 5) 设置超时时间很有必要, 避免出现server端主动关闭的情况 mysql has gone away... 代码来源]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go里的点点点语法]]></title>
    <url>%2F2018%2F12%2F14%2Fgo-dotdotdot%2F</url>
    <content type="text"><![CDATA[golang 代码里面有时会出现 ... 这个操作, 初次看到也是摸不到头脑,其实他是用来做数组的析构用的 举个例子就明白了: 123456789101112131415161718192021package mainimport "fmt"func main() &#123; pm := []string&#123;"a", "b", "c"&#125; test("abc", pm...) // 相当于 test("abc", "a", "b", "c") ap := []string&#123;"f", "g"&#125; rs := append(pm, ap...) // 相当于 append(pm, ap[0], ap[1], 以此类推) fmt.Println("rs:", rs)&#125;func test(name string, pms ...string) &#123; fmt.Println("output name:", name) for k, v := range pms &#123; fmt.Printf("k: %v, v: %v \n", k, v) &#125; return&#125; 输出: 12345output name: abck: 0, v: ak: 1, v: bk: 2, v: crs: [a b c f g] 这里做了两个示例: 在func中的 ... eg: func test(name string, pms ...string)代表着不限参数数量, 而多出的参数都放在了 var pms []string 这个数组当中, 在go中典型的使用例子就是 fmt.Print 这一系列的方法 在传参的时候使用... 是用来表示将数组中每个元素单独传入函数中较长用的就是出现数组合并的时候, 使用append() 方法时:这样写正确 12ap := []string&#123;"f", "g"&#125; rs := append(pm, ap...) // 相当于 append(pm, ap[0], ap[1], 以此类推) 这样写就报错12ap := []string&#123;"f", "g"&#125;rs := append(pm, ap)]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
</search>
