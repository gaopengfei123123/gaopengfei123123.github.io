<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[不正宗 Docker 入门教程-构建一个镜像(2/3)]]></title>
    <url>%2F2018%2F07%2F08%2Fdocker-step-2%2F</url>
    <content type="text"><![CDATA[本章讲的大概能让你明白虚拟机和 docker 的区别… docker 设置了两种构建镜像的方式: 通过 docker commit 构建镜像(不推荐)这个命令是将先有的容器制作成镜像, 不过建议仅用在排查问题的时候使用, 平时生成容器时最好不要用这种镜像, 因为不知道里面有什么改动, 对于开发者来说完全是一个黑盒 命令格式:1docker commit [参数] &lt;容器 ID 或 容器名&gt; [仓库名[:标签]] [flags] 比如(我随便找了一个本地容器 ID):12345➜ ~ docker commit -m "这是一个测试镜像" -a "GPF" 5ad06ec670eb local_nginx:v1sha256:134e09cdce58842dea03202aa5b6516ead8268afe78d2203be8595b4f0bc5ebe➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZElocal_nginx v1 134e09cdce58 2 seconds ago 109MB 这就把当前的容器转换成了镜像, 提交到远程就是:1docker push local_nginx:v1 和git很像对不对? 不过推送到远程时需要有个 dockerhub 的账号 docker history 命令可以查看镜像的构建记录12345678910111213➜ ~ docker history 134e09cdce58IMAGE CREATED CREATED BY SIZE COMMENT134e09cdce58 12 seconds ago nginx -g daemon off; 0B 这是一个测试镜像649dcb69b782 4 days ago /bin/sh -c #(nop) CMD ["nginx" "-g" "daemon… 0B&lt;missing&gt; 4 days ago /bin/sh -c #(nop) STOPSIGNAL [SIGTERM] 0B&lt;missing&gt; 4 days ago /bin/sh -c #(nop) EXPOSE 80/tcp 0B&lt;missing&gt; 4 days ago /bin/sh -c ln -sf /dev/stdout /var/log/nginx… 22B&lt;missing&gt; 4 days ago /bin/sh -c set -x &amp;&amp; apt-get update &amp;&amp; apt… 53.7MB&lt;missing&gt; 4 days ago /bin/sh -c #(nop) ENV NJS_VERSION=1.15.1.0.… 0B&lt;missing&gt; 4 days ago /bin/sh -c #(nop) ENV NGINX_VERSION=1.15.1-… 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) LABEL maintainer=NGINX Do… 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) CMD ["bash"] 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) ADD file:28fbc9fd012eef727… 55.3MB 通过 Dockerfile 构建镜像一个 Dockerfile 就是一个构建镜像的脚本, 常用的几个命令也不多, 也就FROM, COPY, RUN, ADD, ARG, ENV, VOLUME, EXPOSE, CMD, LABEL, 其他的一些命令就不再这里说了, 想了解完整的 Dockerfile 的关键词看这个 Dockerfile reference 一个简单的 demo接下来我们就用一个完整的 Dockerfile 来示范一下: 首先创建一个Dockerfile12mkdir dockerfile_demo &amp;&amp; cd dockerfile_demovi Dockerfile 12345678910111213# dockerfile 内容# 继承的 ubuntu 镜像的版本号FROM ubuntu:16.04# 将本地 workdir 的文件复制到镜像内部, 另外有个 ADD 指令和这个效果类似, 不过不推荐使用COPY ./sources.list /etc/apt/sources.list# 在镜像内部执行命令, 这里就是更新版本和安装 nginxRUN apt-get update &amp;&amp; apt-get install -y nginx# 修改 nginx 默认的 index.html 的内容RUN echo 'Hi, I am in your container'\ &gt;/var/www/html/index.html# 镜像对外暴露80端口EXPOSE 80 然后为了更新速度快一点, 就要换一个国内镜像1vi sources.list 123456789101112# sources.list 内容deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 然后还是在这个目录下, 运行:1docker build ./ -t local_ubuntu_nginx:v2 执行完毕后就能看到本地多了一个镜像123➜ Documents docker imagesREPOSITORY TAG IMAGE ID CREATED SIZElocal_ubuntu_nginx v2 b0f5984c042a 14 minutes ago 214MB 用这个镜像构建一个容器:123➜ Documents docker run -it --rm -p 8088:80 local_ubuntu_nginx:v2 /bin/bashroot@5cb9ff723bee:/# /usr/sbin/nginxroot@5cb9ff723bee:/# 保持终端打开, 本地访问 http://localhost:8088/ 就能看到欢迎界面了  如果这个是关闭交互端口, 这个就访问不到了, 这里要说一个关键点了 在 docker 中运行的程序不能使用后台运行的模式, 否则 docker 会任务这个容器不活跃或出现问题而自动关闭但是 docker 容器本身是可以后台运行的: docker run -d …… 关于 docker build 多说一句之前我们构建时执行的:1docker build ./ -t local_ubuntu_nginx:v2 这个 ./ 的路径指的是构建文本流(context)的路径, 而不是 Dockerfile的文件路径, 在 Dockerfile 中用的各种相对路径都是基于 context 的,我们完全可以是1docker build /path/to/context -f /path/to/anywhere/Dockerfile_demo -t local_ubuntu_nginx 你看, Dockerfile 的文件名不就变成 Dockerfile_demo 了, 如果有1COPY ./sources.list /etc/apt/sources.list 这样的操作, 那么它的完整路径应该是 /path/to/context/sources.list, 不过默认的情况下就是这两个路径是一起的, 不设置镜像tag的话就拿 Dockerfile 所在的目录名为镜像名,默认latest版本 多阶段构建有时候我们的运行环境和编译环境是两回事, 就拿 golang 来举例, 我们只会去维护代码, 而不去管它生成的二进制包是什么, 又因为golang 打包出来的二进制文件几乎是没有依赖, 只要执行这个文件就行, 那么在运行环境中和编译相关的程序就是多余的, 可以看一下官网的示例 Use multi-stage builds, 不能翻墙的看这个 123456789101112FROM golang:1.7.3WORKDIR /go/src/github.com/alexellis/href-counter/RUN go get -d -v golang.org/x/net/html COPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest RUN apk --no-cache add ca-certificatesWORKDIR /root/# 这个是关键, --from=0 是指从第一个镜像(from)中复制内容, 程序中的1 就是0COPY --from=0 /go/src/github.com/alexellis/href-counter/app .CMD ["./app"] 1$ docker build -t alexellis2/href-counter:latest . 这是我自己构建镜像时编译 swoole.so 的镜像和运行时的镜像大小我们只想要一个 swoole.so 像 gcc, make 都是不是代码运行时需要的模块, 因此只是在编译的时候用上, 吐一个swoole.so出来就行, 相关代码 12345678910111213141516171819202122232425262728293031FROM php:5.6.36-cli-alpine3.7 as builder# 中国特色RUN echo "http://mirrors.ustc.edu.cn/alpine/v3.7/main/" &gt; /etc/apk/repositories# 添加编译 swoole 需要的前置插件RUN apk update &amp;&amp; \ apk upgrade &amp;&amp; \ apk add alpine-sdk linux-headers &amp;&amp; \ apk add autoconf gcc makeRUN wget https://github.com/swoole/swoole-src/archive/1.8.12-stable.tar.gz &amp;&amp; \ tar zxvf 1.8.12-stable.tar.gz &amp;&amp; \ cd swoole-src-1.8.12-stable &amp;&amp; \ phpize &amp;&amp; \ ./configure &amp;&amp; \ make &amp;&amp; make installFROM php:5.6.36-cli-alpine3.7 as runtimer# 这里因为给每一个阶段加了别名, 这样更方便一点COPY --from=builder /usr/local/lib/php/extensions/no-debug-non-zts-20131226/swoole.so /usr/local/lib/php/extensions/no-debug-non-zts-20131226/swoole.soCOPY ./swoole.ini /usr/local/etc/php/conf.d/swoole.ini# 通常 run 是构建镜像时用的, 会保存一层缓存, cmd 就是镜像启动后执行的命令RUN ["php", "-m"]CMD ["php", "-a"] 构建镜像时需要注意的几点 尽量使用官方镜像, 同时版本选择 alpine &gt; debian &gt; ubuntu &gt; centos, alpine版本的镜像是最小的 COPY 和 ADD 尽量使用 COPY, COPY 只是单纯的复制, ADD 则会自动执行一些东西, 有可能出现意料外的问题 CMD 和 ENTERPOINT 这两个可以查一下区别, 我个人习惯用 CMD 容器中的程序都要前台执行的模式, 使用 daemon 模式会被退出(你想想本身一个后台运行的容器中有个后台运行的程序…) 每一个 RUN 指令就是一层缓存, 当其中一个步骤发生更改那么这之后的步骤也都重新构建 系统更新最好合成一个 RUN 比如: 1234RUN apk update &amp;&amp; \ apk upgrade &amp;&amp; \ apk add alpine-sdk linux-headers &amp;&amp; \ apk add autoconf gcc make 同样还是为了避免因为缓存时出现问题 多看看官方构建的镜像, 收获会很多, 比如 docker-nginx, docker-php 下一章:不正宗 docker 入门教程 使用 docker-compose 来构建镜像(3/3)]]></content>
      <tags>
        <tag>docker入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不正宗 Docker 入门教程-启动一个容器(1/3)]]></title>
    <url>%2F2018%2F07%2F06%2Fdocker-step-1%2F</url>
    <content type="text"><![CDATA[从命名上就知道这是一篇简单粗暴的docker新手入门教程， 为什么要简单粗暴？ 我认为有自学能力的人帮他入门就够了， 不能自学的一时半会儿也教不会， 不符合入门教程的初衷， 建议出门左拐去找找视频教程… 本章目标 大概了解 docker 是个什么玩意 知道常用的 docker 指令参数, 能启动一个容器(不然还想怎么样? 上天吗?) 安装环境强烈推荐使用 Docker for Mac 或 Docker for Windows, 这两个工具已经将 Kitematic 和 docker-compose 集成好了， 至于这两个工具是做什么的咱们后面再说， win10 版本需要专业版的， 不然开启不了Hyper-V， win7 就别想了，不支持… 怎么安装在 阿里云镜像容器服务 里面都说的很清楚了， 连国内镜像源都给你安排好了， 咱们就进入下一话题 PS: 如果是 CentOS 6 的就需要升级一下系统内核了， centOS6.5 安装docker， 毕竟都 8102 年了， docker 又是个比较新的东西， 对于稍微久一点的系统的支持就不那么友好 运行第一个容器安装完环境之后就启动一个镜像开开眼儿1docker run -d -p 8080:80 --name local_nginx nginx 然后访问 http://localhost:8080/ 就能看到 nginx 的初始界面了 中间发生了什么呢？ docker run 运行镜像的起手式， 详情查看 docker run --help -d 启动 docker 守护进程 -p 8080:80 将本地的 8080 端口绑定到容器的 80 端口上 --name local_nginx 分配一个容器名， 不写的话会默认分配要给， 不过这个还是很有用的 nginx 指定运行的镜像名，如果没有指定标签则默认是 latest， 这里其实是启动nginx:latest镜像 现在可以查看一下本机都在运行着什么镜像123PS D:\docker_study&gt; docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6732fa239270 nginx "nginx -g 'daemon of…" 18 minutes ago Up 18 minutes 0.0.0.0:8080-&gt;80/tcp local_nginx docker ps 只能看到正在运行中的容器， 想看到全部的就是 docker ps -a 进入这个容器的命令:123docker exec -it 6732fa239270 /bin/bash#或docker exec -it local_nginx /bin/bash 解释一下: docker exec 在容器中执行命令 -i 保持stdin打开 -t 分配一个伪终端(tty) 6732fa239270 或 local_nginx 这里你也发现了， 可以是通过 CONTAINER ID 也可以是 NAMES 这里的 CONTAINER ID分为128位长ID和32位短ID， 不过作用都是一样的 /bin/bash 运行容器中的 /bin/bash 脚本 进入容器中感觉其实和进入一个虚拟机一样， 但是容器和虚拟机有点区别， 这个我们下一小节会讲到 关闭容器1docker stop 6732fa239270 或 local_nginx 什么是容器？什么是镜像？ 之前我们使用 VirtualBox 装虚拟机的时候有装盘镜像, 但是启动后就是一个个的虚拟机了, 不过在 docker 中和虚拟机还是有点区别 就拿上图来说, container就是镜像的实例化, image 是容器的底层支撑, 其实他们的关系用代码中的类Class来比喻是最合适的: Class 就是我们实际开发中写的一个代码集合, Object 是 Class 实例化之后生成的一种资源变量 Image 也是预先写好的逻辑, 并存在一个地方, Container 是 Image 启动之后生成的一个虚拟系统 实例化出来的 Object 不会影响到 Class 中的内容 已经启动的 Container 也不会影响到 Image 中的逻辑 Class 可以继承别的 Class, 从而继承它的特性 Image 也是可以继承别的 Image, 并在它的基础上构建新的镜像 一个 Object 对应着一个 Class, 但是 一个 Class 可以实例化无数个 Object 同理, 一份 Image 可以生成无数个 Container, 这就是方便集群化部署的所在 简单的说 Container 就是 Image 的儿子, 模样和 Image 预想的一样, 但是 Container 运行之后会发生一些改变, 而且这种改变是可以保存的 常用的运行参数和命令咱们先不说构建镜像的事儿(那是下一章的话题), 这里先了解一下 docker run 命令中比较常用的参数: -it 建立一个可在终端交互的容器比如:123docker run -it --name local_nginx nginx:latest /bin/bash# 或docker exec -it local_nginx bin/bash -p 用于宿主机和容器的端口绑定绑定多个端口就设置多个映射1234567docker run -d -p 8088:80 -p 4433:443 nginx:latest# 或 不写本地端口, docker 将帮你自动分配docker run -d -p :80 -p :443 nginx:latest# 或 加上 ip 就绑本地指定的 ipdocker run -d -p 127.0.0.1:8088:80 -p :443 nginx:latest# 或 照样不写本地端口就随机分配docker run -d -p 127.0.0.1::80 -p :443 nginx:latest 通过 docker ps 可以看一下上面两行命令的执行状态1234➜ test docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES57f65b46bd87 nginx:latest "nginx -g 'daemon of…" 1 second ago Up 3 seconds 0.0.0.0:32769-&gt;80/tcp, 0.0.0.0:32768-&gt;443/tcp happy_zhukovsky0c035ebabe44 nginx:latest "nginx -g 'daemon of…" About a minute ago Up About a minute 0.0.0.0:8088-&gt;80/tcp, 0.0.0.0:4433-&gt;443/tcp ecstatic_haibt -v 将宿主机的卷挂载到容器中的指定目录1docker run -d -p 8088:80 -v /Users/gpf/Documents/docker_study/docker_test/www/:/usr/share/nginx/html/ nginx:latest 这里本地的目录要写绝对路径, 不然会报错, 这样一来, 本地的/Users/gpf/Documents/docker_study/docker_test/www/ 就是容器中的/usr/share/nginx/html/, 就可以本地更改代码, 然后容器中运行 -d 后台运行想查看日志的话就 docker logs [containerID] 就行 docker exec 执行 docker 容器中的命令通常就是用来进入容器中搞七搞八的123docker exec -it 57f65b46bd87 /bin/bash# 或docker exsec -it local_nginx /bin/bash 这里注意两点: containerID 在很多情况下都可以用 container Name 来代替, 很多情况是等价的 命令最后的 /bin/bash 不是必须这么填, 而是执行的容器中的脚本, 如果你的镜像是 alpine版的就是 sh, 因为这个版本中就没有 bash 这个命令 docker ps 容器的运行状态docker stop [containerID 或 name] 停止容器目前版本也增加了 docker container stop [containerID 或 name] 其实作用是一样的, 不过 docker container 命令底下还有很多别的命令, docker 给各模块的命令做了细分 docker rm [containerID 或 name] 删除指定未运行的容器, 一个或多个1docker rm 6dee0a9b5232 582f708af9d3 docker rmi [imageID 或 tag] 删除宿主机指定的镜像这里要注意如果这个镜像还有容器在使用就不能删除掉, 这个时候要先把对应的容器删掉才行删除指定镜像的容器12docker stop $(docker ps | grep '这里写imageName' | awk '&#123; print $1&#125;')docker rm $(docker ps | grep '这里写imageName' | awk '&#123; print $1&#125;') 删除临时构建的镜像1docker rmi $(docker images | grep '&lt;none&gt;' | awk '&#123; print $3&#125;') prune 大杀器这一手还是慎用,一些情况下可造成 rm -rf /* 的效果1234567#移除所有未使用的镜像docker image prune#移除所有未运行的容器docker container prune#移除所有未使用的本地卷docker volume prune... PS: 因为有这一手, 所以可以看出官方的态度, 他们貌似也许可能没准大概差不多不建议把容器当成虚拟机一样把所有的东西都堆在一个镜像里面, 那样搞不止构建出来的镜像臃肿, 而且维护性移植性很差, 从目前网上的 docker 镜像资源来说, 基础镜像 alpine &gt; debian &gt; ubuntu &gt; centos, 优先使用最小的基础构建, 然后整个 image 只为一个服务而构建, 比如 redis 镜像里只要 redis, 没有什么 MySQL, memcache 什么的, 多个独立的 service 才组成一个 APP, 里面各个组件替换的话不用考虑其他组件的环境依赖什么的, 当然, 这个也是看业务的实际需要, 不能为了拆分而拆分, 在这之间能找到最合适自己的才是工具给我们带来的便利 docker network 容器之间的互联如果只是在一个容器里搞来搞去就真的是虚拟机了, docker 的强大之处就是它内部维护一个网络, 处在相同网络的容器是可以互通的12345# 新建一个 docker 网络, -d bridge 是指定网络模式, 当前是桥接网络docker network create -d bridge nginx_swarm# 启动两个 nginx 容器, 分别命名 nginx_swarm_a nginx_swarm_b , 两者都加入了 nginx_swarm 这个网络 --rm 是当容器停止后自动删除docker run -it --rm --name nginx_swarm_a --network nginx_swarm nginx /bin/bashdocker run -it --rm --name nginx_swarm_b --network nginx_swarm nginx /bin/bash 注意, 我们并没把接口暴露出去, 现在随便在一个容器中 ping 另一个容器12345678910# 这是在 nginx_swarm_a 中# 没有 ping 命令的先装一个 ping# apt-get update &amp;&amp; apt-get install -y iputils-pingroot@73d04107780f:/# ping -c 3 nginx_swarm_bPING nginx_swarm_b (172.18.0.3) 56(84) bytes of data.64 bytes from nginx_swarm_b.nginx_swarm (172.18.0.3): icmp_seq=1 ttl=64 time=0.084 ms64 bytes from nginx_swarm_b.nginx_swarm (172.18.0.3): icmp_seq=2 ttl=64 time=0.161 ms64 bytes from nginx_swarm_b.nginx_swarm (172.18.0.3): icmp_seq=3 ttl=64 time=0.146 ms--- nginx_swarm_b ping statistics --- docker 能自动的把 server name 转换成 ip, 我们只需要标明请求的是哪个容器, 而不是还要记住它的 ip 地址(当然 ip 地址也能设置) 总结弄明白以下几点启动一个容器应该是没什么问题了: 国内一定要使用国内镜像源, 不然会痛不欲生, 国内 docker 仓库镜像对比 分清镜像和容器的概念, 容器就是基于镜像构建出来的一个实例 不要往容器中保存数据, 容器应该是无状态的, 需要持久化保存的就docker run -v xx:xx 或者 docker create volume ... 用独立的卷来保存 docker 不是虚拟机 分清楚宿主机端口和容器端口 处在相同network下的容器才能通过容器明互相访问 参考资料:Docker — 从入门到实践nginx 官方镜像 下一章:不正宗 docker 入门教程 构建一个镜像(2/3)]]></content>
      <tags>
        <tag>docker入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 centOS65 环境下安装 Docker]]></title>
    <url>%2F2018%2F07%2F06%2Fdocker-install-centos65%2F</url>
    <content type="text"><![CDATA[早期的 docker 对稍微老点的系统支持都不是很友好, 也是因为操作系统的一些新特性才能让 docker 运行起来 在国内的云服务商提供的 CentOS65 镜像内核都是2.6.*的，不能满足docker需要的3.1.*，因此首先需要升级一下内核12345678#导入public keyrpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org#安装elrepo到内核为2.6.32的CentOS中rpm -Uvh http://www.elrepo.org/elrepo-release-6-6.el6.elrepo.noarch.rpm#安装kernel-lt(long term support)长期支持版本yum --enablerepo=elrepo-kernel install kernel-lt -y 如果yum安装的慢，可以通过rpm安装kernel-lt12访问http://elrepo.org/linux/kernel/el6/x86_64/RPMS/下载对应的rpm包，通过rpm方式安装：rpm -ivh kernel-lt-3.10.93-1.el6.elrepo.x86_64.rpm 安装完毕后编辑配置文件123456789101112131415161718192021222324vi /etc/grub.conf# grub.conf generated by anaconda## Note that you do not have to rerun grub after making changes to this file# NOTICE: You do not have a /boot partition. This means that# all kernel and initrd paths are relative to /, eg.# root (hd0,0)# kernel /boot/vmlinuz-version ro root=/dev/xvda1# initrd /boot/initrd-[generic-]version.img#boot=/dev/xvdadefault=0timeout=5splashimage=(hd0,0)/boot/grub/splash.xpm.gzhiddenmenutitle CentOS (3.10.105-1.el6.elrepo.x86_64) root (hd0,0) kernel /boot/vmlinuz-3.10.105-1.el6.elrepo.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-3.10.105-1.el6.elrepo.x86_64.imgtitle CentOS (2.6.32-573.22.1.el6.x86_64) root (hd0,0) kernel /boot/vmlinuz-2.6.32-573.22.1.el6.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-2.6.32-573.22.1.el6.x86_64.imgtitle CentOS (2.6.32-431.23.3.el6.x86_64) 我们用的 CentOS (3.10.105-1.el6.elrepo.x86_64)就排在第一个，因此改成 default=0 保存后重启系统12uname -aLinux iZm5eib1msf1eaxvrvhp60Z 3.10.105-1.el6.elrepo.x86_64 #1 SMP Fri Feb 10 10:48:08 EST 2017 x86_64 x86_64 x86_64 GNU/Linux 安装docker123yum install -y docker-engineservice docker startsudo docker version 如果出现 Cannot connect to the Docker daemon. Is &#39;docker -d&#39; running on this host? 这种提示，按以下解决步骤： 执行 service docker start 加上 sudo 执行 yum upgrade device-mapper 我是执行到第三步就可以正常运行了，如果还没解决问题的话就自己找去吧 资料1-centos安装docker升级内核到3.10 资料2-github/docker/issues/11356]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker中 Arg 和 Env 的区别]]></title>
    <url>%2F2018%2F06%2F28%2Fdocker-arg-env%2F</url>
    <content type="text"><![CDATA[在使用 docker-compoe 构建镜像的时候会感觉 ARG 和 ENV 的作用很相似, 但是这两个存在就肯定有它的原因 它们起作用的时机 arg 是在 build 的时候存在的, 可以在 Dockerfile 中当做变量来使用 env 是容器构建好之后的环境变量, 不能在 Dockerfile 中当参数使用 从这里可以看出来 ARG 就是专门为构建镜像而生的 拿一个具体的例子12345678910111213# DockerfileFROM redis:3.2-alpineLABEL maintainer="GPF &lt;5173180@qq.com&gt;"ARG REDIS_SET_PASSWORD=developerENV REDIS_PASSWORD $&#123;REDIS_SET_PASSWORD&#125;VOLUME /dataEXPOSE 6379CMD ["sh", "-c", "exec redis-server --requirepass \"$REDIS_PASSWORD\""] 这是一个构建 redis 的文件, 中间有这么一句12ARG REDIS_SET_PASSWORD=developerENV REDIS_PASSWORD $&#123;REDIS_SET_PASSWORD&#125; 它是为1CMD ["sh", "-c", "exec redis-server --requirepass \"$REDIS_PASSWORD\""] 这一句服务的, 这句就是在启动 redis 的时候设置密码, 因为当执行 CMD 的时候,说明容器已经构建成功运行了起来,此时 CMD是在容器中执行容器中的命令, 因此 CMD 中的变量是用的环境变量而不是在 Dockerfile 中的变量,因此需要把 ARG 中的值在构建的时候赋值给 ENV 另一个使用 ARG 的例子1234567891011121314151617181920212223FROM nginx:1.13.1-alpineLABEL maintainer="GPF &lt;5173180@qq.com&gt;"#https://yeasy.gitbooks.io/docker_practice/content/image/build.htmlRUN mkdir -p /etc/nginx/cert \ &amp;&amp; mkdir -p /etc/nginx/conf.d \ &amp;&amp; mkdir -p /etc/nginx/sitesCOPY ./nginx.conf /etc/ngixn/nginx.confCOPY ./conf.d/ /etc/nginx/conf.d/COPY ./cert/ /etc/nginx/cert/COPY ./sites /etc/nginx/sites/ARG PHP_UPSTREAM_CONTAINER=php-fpmARG PHP_UPSTREAM_PORT=9000RUN echo "upstream php-upstream &#123; server $&#123;PHP_UPSTREAM_CONTAINER&#125;:$&#123;PHP_UPSTREAM_PORT&#125;; &#125;" &gt; /etc/nginx/conf.d/upstream.confVOLUME ["/var/log/nginx", "/var/www"]WORKDIR /usr/share/nginx/html 这里就只是用了ARG123ARG PHP_UPSTREAM_CONTAINER=php-fpmARG PHP_UPSTREAM_PORT=9000RUN echo "upstream php-upstream &#123; server $&#123;PHP_UPSTREAM_CONTAINER&#125;:$&#123;PHP_UPSTREAM_PORT&#125;; &#125;" &gt; /etc/nginx/conf.d/upstream.conf 这里的变量用的就是 ARG 而不是 ENV了,因为这条命令运行在 Dockerfile 当中的, 像这种临时使用一下的变量没必要存环境变量的值就很适合使用 ARG]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-composer</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git调整 Ssh 登录参数]]></title>
    <url>%2F2018%2F06%2F23%2Fgit-sshcommand%2F</url>
    <content type="text"><![CDATA[指定 ssh 命令使用时的签名文件进入 app的.git/config 文件下12345678910111213141516 Engine:[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true # 添加一行这个就行 sshCommand = ssh -i ~/.ssh/id_rsa_gayhuber[remote "origin"] url = git@github.com:gayhuber/php-fpm.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 Gii 模板]]></title>
    <url>%2F2018%2F05%2F23%2Fyii-gii%2F</url>
    <content type="text"><![CDATA[开发是需要用到 gii,但是 gii 并不是完全符合自己的开发需求,所以需要对他做一点改造 这里先拿 basic 版举例, advance版同理 1.修改配置文件 web.php12345678910111213141516171819202122232425262728// file path: @app/config/web.phpif (YII_ENV_DEV) &#123; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'debug'; $config['modules']['debug'] = [ 'class' =&gt; 'yii\debug\Module', ]; $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'yii\gii\Module', // 这里把原来的 model generator 给覆盖成自己的 'generators' =&gt; [ 'model' =&gt; [ // 自定义的模板生成器 'class' =&gt; 'app\common\gii\model\Generator', //设置我们自己的模板 'templates' =&gt; [ //模板名 =&gt; 模板路径 'default' =&gt; '@app/common/gii/model/default', 'original' =&gt; '@app/common/gii/model/original_tpl', ] ] ], ];&#125; 现在在配置中指定了两种model 生成模板了 2.设置自定义的 Geneartor 和 template现在进@app/vendor/yiisoft/yii2-gii/src/generators/model把这个目录拷贝到 @app/common/gii/这里,位置随意, 只要保证 config 中能找到这个路径就行,现在我们就在 @app/common/gii/model这里操作 因为 Generator 继承的 \yii\gii\Generator, 需要实现两个方法, 一个是 getName() 另一个是 generate(), 我们主要修改的就是 generate(),12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// file path: @app/common/gii/model/Generatornamespace app\common\gii\model;use Yii;use yii\db\ActiveQuery;use yii\db\ActiveRecord;use yii\db\Connection;use yii\db\Schema;use yii\db\TableSchema;use yii\gii\CodeFile;use yii\helpers\Inflector;use yii\base\NotSupportedException;class Generator extends \yii\gii\Generator&#123; /** some code ..... */ /** * &#123;@inheritdoc&#125; */ public function generate() &#123; $files = []; $relations = $this-&gt;generateRelations(); $db = $this-&gt;getDbConnection(); foreach ($this-&gt;getTableNames() as $index =&gt; $tableName) &#123; // model : $modelClassName = $this-&gt;generateClassName($tableName); $queryClassName = ($this-&gt;generateQuery) ? $this-&gt;generateQueryClassName($modelClassName) : false; $tableSchema = $db-&gt;getTableSchema($tableName); $params = [ &apos;tableName&apos; =&gt; $tableName, &apos;className&apos; =&gt; $modelClassName, &apos;queryClassName&apos; =&gt; $queryClassName, &apos;tableSchema&apos; =&gt; $tableSchema, &apos;properties&apos; =&gt; $this-&gt;generateProperties($tableSchema), &apos;labels&apos; =&gt; $this-&gt;generateLabels($tableSchema), // 这是新增的 &apos;constMap&apos; =&gt; $this-&gt;generateConstMap($tableSchema), &apos;rules&apos; =&gt; $this-&gt;generateRules($tableSchema), &apos;relations&apos; =&gt; isset($relations[$tableName]) ? $relations[$tableName] : [], ]; // 同一个库中只生成一个 Model.php 之后的 model 都要继承这个 model if ($index == 0) &#123; $files[] = new CodeFile( Yii::getAlias(&apos;@&apos; . str_replace(&apos;\\&apos;, &apos;/&apos;, $this-&gt;ns)) . &apos;/Model.php&apos;, $this-&gt;render(&apos;cModel.php&apos;, $params) ); &#125; $files[] = new CodeFile( Yii::getAlias(&apos;@&apos; . str_replace(&apos;\\&apos;, &apos;/&apos;, $this-&gt;ns)) . &apos;/&apos; . $modelClassName . &apos;.php&apos;, $this-&gt;render(&apos;model.php&apos;, $params) ); &#125; return $files; &#125; protected function generateConstMap($table)&#123; // some code &#125; /** some code ..... */&#125; 在generate() 这个方法里的 $params 这里就是给模板准备参数, new CodeFile这里就是生成指定的模板 现在我们在模板中搞一下 3.设置 model 模板在@app/common/gii/model目录下有一个default目录,就是默认的 template,咱们在config.php中设置了12345'templates' =&gt; [ //模板名 =&gt; 模板路径 'default' =&gt; '@app/common/gii/model/default', 'original' =&gt; '@app/common/gii/model/original_tpl', ] 这两个, 把 default/ 复制一份叫 original_tpl/ 这在 gii 页面端选模板的时候能看到这写别名,如果是console模式的话只能使用default模板了 1234567891011121314151617181920212223242526272829303132// path: @app/common/gii/default/model.php&lt;?php/** * This is the template for generating the model class of a specified table. *//* @var $this yii\web\View *//* @var $generator yii\gii\generators\model\Generator *//* @var $tableName string full table name *//* @var $className string class name *//* @var $queryClassName string query class name *//* @var $tableSchema yii\db\TableSchema *//* @var $properties array list of properties (property =&gt; [type, name. comment]) *//* @var $labels string[] list of attribute labels (name =&gt; label) *//* @var $rules string[] list of validation rules *//* @var $relations array list of relations (name =&gt; relation declaration) *//* @var $constMap string[] list of attribute labels (name =&gt; label) */echo "&lt;?php\n";?&gt;namespace &lt;?= $generator-&gt;ns ?&gt;;use Yii;/** * This is the model class for table "&lt;?= $generator-&gt;generateTableName($tableName) ?&gt;". *&lt;?php foreach ($properties as $property =&gt; $data): ?&gt;...底下一些乱七八糟的代码.... 这里就看着办吧,就是正常的渲染模板 因为在generate()中还设置了一个1234567// 同一个库中只生成一个 Model.php 之后的 model 都要继承这个 modelif ($index == 0) &#123; $files[] = new CodeFile( Yii::getAlias('@' . str_replace('\\', '/', $this-&gt;ns)) . '/Model.php', $this-&gt;render('cModel.php', $params) );&#125; 新增了一个cModel.php,这个是我自己的业务需求, 同库的 model 全部继承这个 model, 这里只是设置了一下getDb()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/** * This is the template for generating the model class of a specified table. *//* @var $this yii\web\View *//* @var $generator yii\gii\generators\model\Generator *//* @var $tableName string full table name *//* @var $className string class name *//* @var $queryClassName string query class name *//* @var $tableSchema yii\db\TableSchema *//* @var $properties array list of properties (property =&gt; [type, name. comment]) *//* @var $labels string[] list of attribute labels (name =&gt; label) *//* @var $rules string[] list of validation rules *//* @var $relations array list of relations (name =&gt; relation declaration) *//* @var $constMap string[] list of attribute labels (name =&gt; label) */$date = date('Y/m/d H:i');$date = explode(' ', $date);$model = &lt;&lt;&lt;str&lt;?php/** * Created by Gii. * TemplatePath: @app\common\gii\model\default\cModel.php * Date: &#123;$date[0]&#125; * Time: &#123;$date[1]&#125; */namespace &#123;$generator-&gt;ns&#125;;use yii\db\ActiveRecord;use Yii;/** * 同文件夹下都要继承一下这个 model,目前是用来改库的链接地址 * Class Model * @package app\modules\v1\models\passport */class Model extends ActiveRecord&#123; /** * 重写表所对应的数据库链接信息 (如果函数不存在则默认为 db 的配置) * @return \yii\db\Connection */ public static function getDb() &#123; return Yii::\$app-&gt;get('&#123;$generator-&gt;db&#125;'); &#125;&#125;str;echo $model;?&gt; 这样依赖 gii 的模板自定义就算是完事了 4. console 模式下的 gii照例首先需要设置console.php的配置 12345678910111213141516//path @app/console.phpif (YII_ENV_DEV) &#123; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'app\common\gii\Module', 'generators' =&gt; [ 'model' =&gt; [ // 自定义的模板生成器 'class' =&gt; 'app\common\gii\model\Generator', //设置我们自己的模板 console 默认就是 default 模板 'templates' =&gt; [] ] ], ];&#125; generators 和 之前的配置一样,区别就是 module 下的 class 设置成自己的 Module 这里把@app/vendor/yiisoft/yii2-gii/src/Module.php复制一份到@app/common/gii/Module.php 改一下命名空间并且继承\yii\gii\Module 毕竟咱们是定制的, 这个代码不能在 vendor 中改,不然以后你再装新的 composer 包的时候会非常麻烦 12345678910111213141516171819202122232425// path: @app/common/gii/Module.php/**代码块*/ public function bootstrap($app) &#123; if ($app instanceof \yii\web\Application) &#123; $app-&gt;getUrlManager()-&gt;addRules([ ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id, 'route' =&gt; $this-&gt;id . '/default/index'], ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id . '/&lt;id:\w+&gt;', 'route' =&gt; $this-&gt;id . '/default/view'], ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id . '/&lt;controller:[\w\-]+&gt;/&lt;action:[\w\-]+&gt;', 'route' =&gt; $this-&gt;id . '/&lt;controller&gt;/&lt;action&gt;'], ], false); &#125; elseif ($app instanceof \yii\console\Application) &#123; $app-&gt;controllerMap[$this-&gt;id] = [ // 这里改成自己定制的 consoleController 'class' =&gt; 'app\common\gii\console\GenerateController', 'generators' =&gt; array_merge($this-&gt;coreGenerators(), $this-&gt;generators), 'module' =&gt; $this, ]; &#125; &#125;/**代码块*/ 只用把 console 的 GenerateController 指向咱们自定义的控制器, 复制目录@app/vendor/yiisoft/yii2-gii/src/console/ 到 @app/common/gii/console/, 这时我们就能对 gii console 模式下的代码进行调整了 可能在@app/common/gii/console/GenerateController.php中的代码让你摸不到头脑, 这里是在 actions()来着注册 router, 具体的 action 实现则是在 class 中指定了 1234567891011121314151617181920// path: @app/common/gii/console/GenerateController.php public function actions() &#123; $actions = []; foreach ($this-&gt;generators as $name =&gt; $generator) &#123; $actions[$name] = [ 'class' =&gt; 'yii\gii\console\GenerateAction', 'generator' =&gt; $generator, ]; // 依赖model generator 重新定义一个 gii 命令 if($name == 'model') &#123; $actions['all'] = [ 'class' =&gt; 'app\common\gii\console\GenerateAllAction', 'generator' =&gt; $generator, ]; &#125; &#125; return $actions; &#125; 因为所有的 Generator 都实现了 getName() 和 generate()这两个方法,action 也是只使用了这两个方法,可以自己翻下代码,这里就不详细讲了]]></content>
      <categories>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>gii</tag>
        <tag>yii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十进制与二进制,八进制,十六进制的换算]]></title>
    <url>%2F2018%2F05%2F23%2Fconversion-calculation%2F</url>
    <content type="text"><![CDATA[复习一下二进制,八进制,十六进制之间的互相转换和怎么用十进制去转换它们 首先做一个定义： B(Binary)表示二进制，O(Octal)表示八进制，D(Decimal)或不加表示十进制，H(Hexadecimal)表示十六进制，比如：(101011)B=(53)O=(43)D=(2B)H 十进制转换成二进制除二取余法二进制说白了就是 0 和 1 啊，在十进制的时候就是2的次方 以十进制的(43)D为例：123456743/2=21%121/2=10%110/2=5 %05 /2=2 %12 /2=1 %01 /2=0 %1以上把余数倒着排就是二进制的结果了，即101011 阶段相减法（适合低次方的速算）每次都减去最大的值，还是拿(42)D举例：42-32-8-2-1=0， 对应以下的表格为： 64 32 16 8 4 2 1 2^6 2^5 2^4 2^3 2^2 2^1 2^0 0 1 0 1 0 1 1 结果就是： 101011 十进制转二进制以 (101011)B 举例：11*2^0 + 1*2^1 + 1*2^3 + 1*2^5 = 43 十进制转八进制和十六进制都是用的除8或16取余法，不做赘述了，有点区别就是16进制的9以后就是abcd…代替的这等式就自己进行一下验算好了: (101011)B=(53)O=(43)D=(2B)H 二进制转八进制、十六进制先复习一个等式: 2^0 * 2^1 * 2^2 = 2^3， 那么二进制转八进制就是将二进制的数三个为一组合并一下：1101|011 =&gt; 53 同理， 二进制转16进制就是按四个为一组合并一下：10010|1011 =&gt; 2b 十六进制和八进制之间转换都是先转换成二进制，然后再转成想要的进制]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Rabbitmq实现的延时队列(golang版)]]></title>
    <url>%2F2018%2F05%2F14%2Fgo-rabbitmq-delay-queue%2F</url>
    <content type="text"><![CDATA[虽然 rabbitmq 没有延时队列的功能,但是稍微变动一下也是可以实现的 实现延时队列的基本要素 存在一个倒计时机制:Time To Live(TTL) 当到达时间点的时候会触发一个发送消息的事件:Dead Letter Exchanges（DLX） $~~$基于第一点,我利用的是消息存在过期时间这一特性, 消息一旦过期就会变成dead letter,可以让单独的消息过期,也可以设置整个队列消息的过期时间而rabbitmq会有限取两个值的最小值 $~~$基于第二点,是用到了rabbitmq的过期消息处理机制:. x-dead-letter-exchange 将过期的消息发送到指定的 exchange 中. x-dead-letter-routing-key 将过期的消息发送到自定的 route当中 在这里例子当中,我使用的是 过期消息+转发指定exchange 在 golang 中的实现首先是消费者comsumer.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package mainimport ( "log" "github.com/streadway/amqp")func failOnError(err error, msg string) &#123; if err != nil &#123; log.Fatalf("%s: %s", msg, err) &#125;&#125;func main() &#123; // 建立链接 conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/") failOnError(err, "Failed to connect to RabbitMQ") defer conn.Close() ch, err := conn.Channel() failOnError(err, "Failed to open a channel") defer ch.Close() // 声明一个主要使用的 exchange err = ch.ExchangeDeclare( "logs", // name "fanout", // type true, // durable false, // auto-deleted false, // internal false, // no-wait nil, // arguments ) failOnError(err, "Failed to declare an exchange") // 声明一个常规的队列, 其实这个也没必要声明,因为 exchange 会默认绑定一个队列 q, err := ch.QueueDeclare( "test_logs", // name false, // durable false, // delete when unused true, // exclusive false, // no-wait nil, // arguments ) failOnError(err, "Failed to declare a queue") /** * 注意,这里是重点!!!!! * 声明一个延时队列, ß我们的延时消息就是要发送到这里 */ _, errDelay := ch.QueueDeclare( "test_delay", // name false, // durable false, // delete when unused true, // exclusive false, // no-wait amqp.Table&#123; // 当消息过期时把消息发送到 logs 这个 exchange "x-dead-letter-exchange":"logs", &#125;, // arguments ) failOnError(errDelay, "Failed to declare a delay_queue") err = ch.QueueBind( q.Name, // queue name, 这里指的是 test_logs "", // routing key "logs", // exchange false, nil) failOnError(err, "Failed to bind a queue") // 这里监听的是 test_logs msgs, err := ch.Consume( q.Name, // queue name, 这里指的是 test_logs "", // consumer true, // auto-ack false, // exclusive false, // no-local false, // no-wait nil, // args ) failOnError(err, "Failed to register a consumer") forever := make(chan bool) go func() &#123; for d := range msgs &#123; log.Printf(" [x] %s", d.Body) &#125; &#125;() log.Printf(" [*] Waiting for logs. To exit press CTRL+C") &lt;-forever&#125; 然后是生产者productor.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( "log" "os" "strings" "github.com/streadway/amqp")func failOnError(err error, msg string) &#123; if err != nil &#123; log.Fatalf("%s: %s", msg, err) &#125;&#125;func main() &#123; conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/") failOnError(err, "Failed to connect to RabbitMQ") defer conn.Close() ch, err := conn.Channel() failOnError(err, "Failed to open a channel") defer ch.Close() body := bodyFrom(os.Args) // 将消息发送到延时队列上 err = ch.Publish( "", // exchange 这里为空则不选择 exchange "test_delay", // routing key false, // mandatory false, // immediate amqp.Publishing&#123; ContentType: "text/plain", Body: []byte(body), Expiration: "5000", // 设置五秒的过期时间 &#125;) failOnError(err, "Failed to publish a message") log.Printf(" [x] Sent %s", body)&#125;func bodyFrom(args []string) string &#123; var s string if (len(args) &lt; 2) || os.Args[1] == "" &#123; s = "hello" &#125; else &#123; s = strings.Join(args[1:], " ") &#125; return s&#125; 运行一下:12go run comsumer.gogo run productor.go $~~$具体看代码和注释就行, 这里的关键点就是将要延时的消息发送到过期队列当中, 然后监听的是过期队列转发到的 exchange 下的队列正常情况就是始终监听一个队列,然后把过期消息发送到延时队列中,当消息到达时间后就把消息发到正在监听的队列 一个自己写的mq工具]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关 Restful 借口规范踩到的坑]]></title>
    <url>%2F2018%2F05%2F09%2Fphp-restful%2F</url>
    <content type="text"><![CDATA[使用 restful 接口规范开发时我碰到的几个槽点… restful提供了一种接口规范,本意是让路由变得更加易懂,不过既然是规则那么就有束缚,想在项目中采用这个的同学们可以参考一下 路由嵌套太要命$~~$如果存在这种city/3/zoo/2/animal/1这样的查询路由你怎么说? 多层嵌套在我看来反而不如?city=3&amp;zoo=2&amp;animal=1这种 query 来的方便直接,尤其是在后台的开发中这种目录结构会让人痛不欲生,而且很多情况下我们进行列表展示的时候数据不是从一个表里取出来的,有时甚至需要跨业务或者调第三方的进行组合,这种情况下路由是不是要很长? restful路由里需要显示出要操控的资源,这资源种类一多url 就会变得长长长,反而不如像select/animal-list这样来的简单直接 权限问题$~~$这是由于上个问题引申出来的, 像city/{cid}/zoo/{zid}/animal/{aid}这种路由规则的权限怎么去维护? 而且 rbac 在国内的应用来说很是常见,我们目前的解决方案也是12345$route = [ 'select/animal' =&gt; 'city/&#123;cid&#125;/zoo/&#123;zid&#125;/animal/&#123;aid&#125;', //.....]; 这样给这类的路由出一个给机器看的路由,长期下来如果当前开发人员走了后续接手的程序员会很绝望 路由规则让人头秃$~~$restful的路由命名核心就是将动词转换成名词,这个就看你的词汇量能不能跟上业务了,最典型的就是用户登录注册,user/login和user/register这种明显不符合啊,如果用session/{id}这种路由又显得怪怪的 如果出现文件类型接口的怎么办?$~~$举个例子就是如果我有导出 excel 或者生成二维码的需求,那么这个路由算是文档操作里面的还是业务资源底下的?这一类的操作大部分都是查的居多,增删改几乎没有,这种接口都是单独写路由规则的.还有一点,我们这边采取的前后端分离通常都是 application/json 格式传输数据,当碰到文件上传的时候还是老老实实的用multipart/form-data,请求方式要单独写,php56的还会提示$HTTP_RAW_POST_DATA即将被php://input替换 回归到参数提取的问题$~~$还是查找这一块,路由很受限,举个例子:我需要查当前某个动物园的动物种类,按名字首字母降序排序,那么我应该是GET /zoo/3/animal?sort=-1&amp;slabel=name, 需要组成这个路由首先要前端兄弟把指定的 id 给拼出来,然后其他的参数拼到后面,或者其他的参数放到header里面,那么后台兄弟就要先把路由中的参数给剔出来,然后再去某个地方把剩余的参数给拿到…累不累? 查询条件多的情况下是不是还和原来一样,而且还多了提取url中参数的操作? 理论上在查询的时候是可以指定显示字段的$~~$GET /zoo?field=name,id,desc 查询的路由把暴露字段的权利开放给了调用方,那么如果有人操作不规范或者直接就是是坏,每次请求我都取全量字段内容,那么我的带宽不要钱啊?mysql 的 I/O 也是压力啊 总结$~~$restful接口在猛一看很美好,但是需要结合自己实际业务是不是适配这套规则,不要强行为了restful而restful, 一些小而美的工具可以用这种规范,中大型的业务真的要慎重考虑]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php开发过程中不常碰到的error]]></title>
    <url>%2F2018%2F04%2F26%2Fphp-unsual-mistakes%2F</url>
    <content type="text"><![CDATA[这里做一些备注,以防再次碰到 url 当中的参数有 &amp;timestamp=1234567890这样的字段会被转义成xtamp=1234567890这个不仅存在于页面解析当中,当使用 curl 请求时拼接的参数有这种格式的也会发生转义解决方法有两个: 把 timestamp 这个参数放在 urlQuery 的最前面, ?timestamp=1234567890 这样避免出现 &amp;time发生转义的情况 将&amp;用&amp;amp;来代替 Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.出现这句话通常说明你在用的 php 版本是5.6.而且在php&lt;=5.6的时候,进行 application/json格式的 post 提交会把数据放在$HTTP_RAW_POST_DATA这个系统变量里面,在php&gt;=7的时候这个变量被移除了,统统归总到php://input这里解决方法: 根据系统提示的走: Although that indeed would be technically impossible (as $HTTP_RAW_POST_DATA is populated in the bootstrapping phase of the PHP process) allow one to override the setting by means of calling ini_set. 要确保自己的系统中没有使用 HTTP_RAW_POST_DATA这个变量,直接在php.ini里面禁掉它的设置,但是容易出现系统中又打开的情况(在框架中很常见) 改一下自己的提交方式, 使用 application/form-data或者application/x-www-form-urlencoded这种格式的提交, 然后在后端接收数据的时候再转成自己需要的格式(通常是数组) 参考资料 Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’这种情况出现在平时运行的好好的, 但是突然换 cli 模式后这个配置就出问题了,原因在当 host=localhost时走的是 unix:socket 链接, 当host=127.0.0.1走的是 tcp 链接,这在php-fpm和php-cli中有点区别,尤其是本地没有安装 mysql 的时候解决方法有三种: 将本地链接配置统一成 127.0.0.1 查看 MySQL 中的user表, host=localhost和host=127.0.0.1是不是用的同一个账号密码 配置php.ini文件中的pdo_mysql.default_socket= 写上完整的 socket 路径以上三种方法都可以试一下参考资料 常驻内存时发生的事情这个是 phper 很少碰到但是很常见的情况, 比如用 swoole 启动了一个常驻进程的服务, 那么就一定要小心使用静态变量,在同步模式下会发生变量污染, 还有就是 redis,mysql 这类的链接,你会发现长时间静置以后就会出现一些摸不着头脑的问题, 这种情况不妨想一下是不是 server 端回收了这个 socket,因此在 client 端怎么都写入不进去. 还有就是 php 在读取消息的时候,出现消息过长的情况,那么就要考虑EOF终止符的问题了… 单次 http 每一次请求都是全新的代码, 不用自己考虑 gc 的问题, 但是在常驻内存的时候,这些就是一个个的大坑了 mysql has gone away产生这个错误的主要原因是 mysql server 端断开了链接, client 端还拿着这个句柄去请求,解决方式有两种: show global variables like &#39;%timeout&#39;; 查看 wait_timeout 的时长,适当的调长一点, 这种方法治标不治本,而且有隐患 12mysql&gt; set global wait_timeout=10;mysql&gt; show global variables like 'wait_timeout'; 使用 mysql 之前需要 mysql_ping() 一下, 如果出现断开的错误就启动重连机制]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>debug</tag>
      </tags>
  </entry>
</search>
