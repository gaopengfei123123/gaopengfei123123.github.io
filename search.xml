<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Crontab 设置一小时执行一次]]></title>
    <url>%2F2018%2F12%2F11%2Flinux-crontab%2F</url>
    <content type="text"><![CDATA[如果主管给你个任务, 让你每小时执行一次脚本, 是不是就是这样:1* */1 * * * xxxxx.bash 这样就错了呦~ 以上产生的结果是每分钟执行一次, 因为从匹配角度来看每分钟都符合规则, 继而执行命令 因此对于整点定时任务有两种写法: 每整点执行一次:10 */1 * * * xxxxx.bash 每隔60分钟执行一次:1*/60 * * * * xxxxx.bash 注意我的描述啊, 整点和隔60分钟其实是两个东西, 根据具体业务要求去使用它 关于定时器这里有三个示例: 在上午8点到11点的第3和第15分钟执行 13,15 8-11 * * * command 每隔两天的上午8点到11点的第3和第15分钟执行 13,15 8-11 */2 * * command 每个星期一的上午8点到11点的第3和第15分钟执行 13,15 8-11 * * 1 command 详细的crontab操作可以参考这篇博客:crontab–定时器命令]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Channel控制并发数量]]></title>
    <url>%2F2018%2F12%2F04%2Fgo-channel-waitgroup%2F</url>
    <content type="text"><![CDATA[使用 go 关键字有时候需要控制一下并发的数量, 但不至于去修改 runtime.GOMAXPROCS 这个数值, 这里就用到了缓冲channel的特性 demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package poolimport ( "sync")// WaitGroup 一个异步结构体type WaitGroup struct &#123; workChan chan int wg sync.WaitGroup&#125;// NewPool 生成一个工作池, coreNum 限制func NewPool(coreNum int) *WaitGroup &#123; ch := make(chan int, coreNum) return &amp;WaitGroup&#123; workChan: ch, wg: sync.WaitGroup&#123;&#125;, &#125;&#125;// Add 添加func (ap *WaitGroup) Add(num int) &#123; for i := 0; i &lt; num; i++ &#123; ap.workChan &lt;- i ap.wg.Add(1) &#125;&#125;// Done 完结func (ap *WaitGroup) Done() &#123;LOOP: for &#123; select &#123; case &lt;-ap.workChan: break LOOP &#125; &#125; ap.wg.Done()&#125;// Wait 等待func (ap *WaitGroup) Wait() &#123; ap.wg.Wait()&#125; test: 123456789101112131415161718192021222324252627package poolimport ( "fmt" "testing" "time")func TestRun(t *testing.T) &#123; work := NewPool(4) for i := 0; i &lt; 50; i++ &#123; work.Add(1) go testFunc(i, work) &#125; fmt.Println("waiting...") work.Wait() t.Log("done")&#125;func testFunc(i int, wg *WaitGroup) &#123; defer wg.Done() fmt.Println(time.Now().Format("2006-01-02T15:04:05Z07:00"), "output: ", i) time.Sleep(time.Second * 1) fmt.Println(time.Now().Format("2006-01-02T15:04:05Z07:00"), "output: ", i, "done")&#125; 输出: 12345678910111213141516172018-12-04T14:22:27+08:00 output: 32018-12-04T14:22:27+08:00 output: 12018-12-04T14:22:27+08:00 output: 02018-12-04T14:22:27+08:00 output: 22018-12-04T14:22:28+08:00 output: 3 done2018-12-04T14:22:28+08:00 output: 0 done2018-12-04T14:22:28+08:00 output: 1 done2018-12-04T14:22:28+08:00 output: 52018-12-04T14:22:28+08:00 output: 62018-12-04T14:22:28+08:00 output: 2 done2018-12-04T14:22:28+08:00 output: 72018-12-04T14:22:28+08:00 output: 42018-12-04T14:22:29+08:00 output: 4 done2018-12-04T14:22:29+08:00 output: 82018-12-04T14:22:29+08:00 output: 7 done2018-12-04T14:22:29+08:00 output: 6 done..... 这里还是要带上 sync.WaitGroup, 保证最后一次循环时携程不会过早退出]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx转发到go服务当中]]></title>
    <url>%2F2018%2F11%2F25%2Fgo-nginx-docker%2F</url>
    <content type="text"><![CDATA[通过docker-compose编排的容器总是有一些奇怪的问题 问题核心就是go-server和nginx所属不同的容器, 需要外界能访问到go的服务就需要进行转发了 如果是在同一个容器中只需要: 1234567891011121314151617181920212223242526server &#123; listen 80; server_name .a.com; charset utf-8; access_log /home/a.com.access.log; location /(css|js|fonts|img)/ &#123; access_log off; expires 1d; root &quot;/path/to/app_a/static&quot;; try_files $uri @backend; &#125; location / &#123; try_files /_not_exists_ @backend; &#125; location @backend &#123; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:8080; &#125;&#125; beego-nginx部署 那么如果是两个容器当中呢? 基于上面的例子, 我们需要用到upstream, 123456789101112131415161718192021222324252627282930313233upstream go_server_proxy &#123; # 这里的server 需要用到 容器名:端口 的形式 server go_server:9090;&#125;server &#123; listen 80; server_name localhost; root /var/www; index index.html; charset utf-8; access_log /var/log/nginx/def.access.log; location /(css|js|fonts|img)/ &#123; access_log off; expires 1d; root &quot;/var/www/static&quot;; try_files $uri @backend; &#125; location / &#123; try_files /_not_exists_ @backend; &#125; location @backend &#123; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_pass http://go_server_proxy; &#125;&#125; 这样做的原因是容器之间的ip并不固定, 使用容器名做host地址是更简单的选择]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 火焰图分析]]></title>
    <url>%2F2018%2F11%2F01%2Fgo-flame-graph%2F</url>
    <content type="text"><![CDATA[go version go1.11.1 darwin/amd64 安装:123$ go get github.com/uber/go-torch$ cd $GOPATH/src/github.com/uber/go-torch$ git clone https://github.com/brendangregg/FlameGraph.git 安装测试工具123$ go get github.com/Masterminds/glide$ cd $GOPATH/src/github.com/uber/go-torch$ glide install 性能分析工具 glide install如果出现 Update failed for golang.org/x/sys: Cannot detect VCS 这种报错, 可以执行1$ glide mirror set https://golang.org/x/sys https://github.com/golang/sys 改变 $HOME/.gilde/mirrors.yaml 的镜像链接即可 运行时完成后输入 web12345678910$ go tool pprof --seconds 25 http://localhost:9090/debug/pprof/profileFetching profile over HTTP from http://localhost:9090/debug/pprof/profile?seconds=25Please wait... (25s)Saved profile in /Users/gpf/pprof/pprof.samples.cpu.002.pb.gzType: cpuTime: Nov 2, 2018 at 11:46am (CST)Duration: 25s, Total samples = 2.17s ( 8.68%)Entering interactive mode (type "help" for commands, "o" for options)(pprof) webFailed to execute dot. Is Graphviz installed? Error: exec: "dot": executable file not found in $PATH 出现 Failed to execute dot. Is Graphviz installed? Error: exec: &quot;dot&quot;: executable file not found in $PATH 报错, 需要安装 graphviz 在 mac 上就直接 brew install graphviz 即可]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>flame-graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-Diff]]></title>
    <url>%2F2018%2F10%2F26%2Fgit-diff%2F</url>
    <content type="text"><![CDATA[git 对比文件差异 通常 git diff COMMIT_ID_1 COMMIT_DI_2 查看 只查看更改过的文件目录 git diff --name-only COMMIT_ID_1 COMMIT_DI_2 快捷用法就是: git diff --name-only HEAD HEAD^ 对比和上次提交时的改动]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次 Git Revert 的经历]]></title>
    <url>%2F2018%2F10%2F25%2Fgit-revert%2F</url>
    <content type="text"><![CDATA[合作开发经常会提merge request嘛, 然后就提了一个不该提的, 还手抖给合并了…. 返现问题以后准备回退, 然后抬眼一看各分支的合并情况…. 哇脑壳痛, 这就用不了平时最喜欢的 reset 了, 查了查资料, 想取消某一次 merge request用 revert 是最合适的 接下来分三步,先找到要回退的那次 mr, 通常是这样的: 12345678910111213141516171819202122git log commit 365ea982c24f2c60150df6159734ab73b74515bc (origin/master, origin/HEAD)Merge: 465fbfb8 f15b39aeAuthor: xxx &lt;xxx&gt;Date: Thu Oct 25 15:41:10 2018 +0800 Merge branch 'master' of xxxxxxxxxxxxxxxcommit 465fbfb8084089f9d08516b4d75ba51ae5dcd5ceAuthor: xxx &lt;xxx&gt;Date: Thu Oct 25 15:41:03 2018 +0800 mergecommit 1e309ff40fd02d1c9c6e604c2649d8a94086a573Author: xxx &lt;zhangkaixuan&gt;Date: Thu Oct 25 15:40:37 2018 +0800 merge... 这样的, 这只是 log 的中间的一部分, 假设 mr 之后后续又有很多 mr 已经合并了, 那么先找到我们要回退的 commit id, 这里就假设一个叫 c76627674dedf4fc067cb0c5b2afbc123fd9c053 执行 git revert -m 1 c76627674dedf4fc067cb0c5b2afbc123fd9c053 通常执行这一步之后没什么冲突就可以了, 然后有冲突了, 就和正常的 merger conflicts 处理一样 解决完冲突, 执行 git revert --continue 这就算合并了 那么回滚到一半不想做了, 也好说, 执行 git revert --abort 以后, 大家就当无事发生过 关于 git revert -m 1 这个1指的是 mainline, 1 代表着 master 这条线资料参考: Why does git revert complain about a missing -m option?]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Vscode 设置终端字体]]></title>
    <url>%2F2018%2F10%2F16%2Fvscode-terminal-font-macOS%2F</url>
    <content type="text"><![CDATA[mac 上设置vscode终端样式(尤其是想用 powershell 主题的) Mac下配置vscode终端字体：在Mac 10.13.6下的解决方案（亲测可用），其他版本做参考。 123下载安装字体$cd /Library/Fonts$sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git config.json 位置123Windows %APPDATA%\Code\User\settings.jsonMac $HOME/Library/Application Support/Code/User/settings.jsonLinux $HOME/.config/Code/User/settings.json 在 vscode 配置中设置字体：123cd $HOME/Library/Application Support/Code/User/settings.json# 文件内指定字体主题"terminal.integrated.fontFamily": "Menlo for Powerline" 在Ubuntu 18.04.1LTS 下的解决方案（亲测可用），其他版本linux做参考。12345下载安装字体$cd /usr/share/fonts/truetype/$sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git刷新字体$sudo fc-cache -f -v 回到 Vs Code的用户设置.json 中加入以下代码1"terminal.integrated.fontFamily": "Menlo for Powerline", 文章来源]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 处理 Map[interface{}]interface{} 数据]]></title>
    <url>%2F2018%2F09%2F28%2Fgo-complex-interface%2F</url>
    <content type="text"><![CDATA[go 调用 rpc , 掉用其他的服务时会出现一些神奇的数据结构, 今天我们来实验一个 上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( "encoding/json" "log")// 这里是针对出现 map[interface&#123;&#125;]interface&#123;&#125; 类型数据进行的一次转化处理示例type respBody map[interface&#123;&#125;]interface&#123;&#125;func main() &#123; // 模拟一个从 hprose-php-server 传过来的数据 res := map[interface&#123;&#125;]interface&#123;&#125;&#123; "errorCode": 200, "errorMsg": "登录成功", "responseData": map[interface&#123;&#125;]interface&#123;&#125;&#123; "hx_password": "c427ee88c8abeeee4fcddbfbf8767025", "like_post": 0, "avatar": "http://img2.xxx.com/user/3_100_100.png", "beauty_list": []int&#123;1, 2, 3&#125;, "role": []string&#123;"admin", "emplyee", "boss"&#125;, "mission_status": map[interface&#123;&#125;]interface&#123;&#125;&#123; "ok": 233, &#125;, &#125;, &#125; tmp := respHandler(res) log.Println("tmp:", tmp) by, err := json.Marshal(tmp) log.Println("output json:", string(by), err)&#125;func respHandler(res interface&#123;&#125;) (tmp map[string]interface&#123;&#125;) &#123; // map 需要初始化一个出来 tmp = make(map[string]interface&#123;&#125;) log.Println("input res is : ", res) switch res.(type) &#123; case nil: return tmp case map[string]interface&#123;&#125;: return res.(map[string]interface&#123;&#125;) case map[interface&#123;&#125;]interface&#123;&#125;: log.Println("map[interface&#123;&#125;]interface&#123;&#125; res:", res) for k, v := range res.(map[interface&#123;&#125;]interface&#123;&#125;) &#123; log.Println("loop:", k, v) switch k.(type) &#123; case string: switch v.(type) &#123; case map[interface&#123;&#125;]interface&#123;&#125;: log.Println("map[interface&#123;&#125;]interface&#123;&#125; v:", v) tmp[k.(string)] = respHandler(v) continue default: log.Printf("default v: %v %v \n", k, v) tmp[k.(string)] = v &#125; default: continue &#125; &#125; return tmp default: // 暂时没遇到更复杂的数据 log.Println("unknow data:", res) &#125; return tmp&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>json</tag>
        <tag>switch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 开发时的一些初级问题]]></title>
    <url>%2F2018%2F09%2F25%2Fgo-primary-mistakes%2F</url>
    <content type="text"><![CDATA[平时碰到的一些小问题, 记一下 assignment to entry in nil map, map 赋值问题1234567891011121314151617181920212223242526272829303132333435363738394041424344// ServiceMap 可用服务列表type ServiceMap struct &#123; handlers map[string]BaseClient RWLock sync.RWMutex BaseService&#125;var ServiceMp *ServiceMapfunc init() &#123; // #1 ServiceMp = &amp;ServiceMap&#123;&#125; // #2.1 ServiceMp.handlers = make(map[string]BaseClient) ServiceMp.AddMethod("XyToken", BaseClient&#123; Module: "System", Class: "XyToken", Func: "getXyOpenKey", &#125;) log.Println("get method:", ServiceMp.handlers)&#125;// AddMethod 添加方法func (serv *ServiceMap) AddMethod(key string, body BaseClient) (err error) &#123; defer func() &#123; if err := recover(); err != nil &#123; log.Println("AddMethod error:", err) &#125; &#125;() if _, ok := serv.handlers[key]; !ok &#123; serv.RWLock.Lock() // #2.2 serv.handlers[key] = body serv.RWLock.Unlock() &#125; return nil&#125; #1 当文件里有一个全局的变量时, 需要先初始化 ServiceMp = &amp;ServiceMap{} 一个实体出来 #2 在 ServiceMap.handlers这个值添加方法的时候, 不能直接 serv.handlers[key] = body, 而是要先给它赋值一个空的切片,才能往里面加东西, 参考 #2.1 和 #2.2 interface conversion: interface {} is float64, not int通常json 转成 map[string]interface{} 时,数字类型就是float64的, 比如:想把它转成int类型使用就要auth.Sys = int(sys.(float64))这样(sys 就是一个 interface{} 类型的数字), 而不是auth.Sys = sys.(int), 后一种写法会有 painc 错误 xxx.(type) 只能用在 switch 当中, 不想这么写就用 reflect.Typeof(xxx)]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 的测试文件]]></title>
    <url>%2F2018%2F09%2F20%2Fgo-test%2F</url>
    <content type="text"><![CDATA[一些函数没有连续的会话状态是可以写出来顺便就写一个测试脚本了比如: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// redis.gopackage toolsimport ( "github.com/gomodule/redigo/redis" "time" "user-server/config")var ( redisClient *redis.Pool REDIS_HOST string REDIS_DB int REDIS_AUTH string MAX_ACTIVE int MAX_IDLE int IDLE_TIMEOUT int64)func init() &#123; REDIS_HOST = config.Conf.Redis.Host REDIS_DB = 0 REDIS_AUTH = "abc" MAX_ACTIVE = 10 MAX_IDLE = 1 /** *@MaxIdle 最大空闲链接 *@MaxActive 最大活跃链接 *@IdleTimeout 自动超时时间 */ redisClient = &amp;redis.Pool&#123; MaxIdle: MAX_IDLE, MaxActive: MAX_ACTIVE, IdleTimeout: 30 * time.Second, Dial: func() (redis.Conn, error) &#123; c, err := redis.Dial("tcp", REDIS_HOST) if err != nil &#123; return nil, err &#125; if REDIS_AUTH != "" &#123; c.Do("AUTH", REDIS_AUTH) &#125; c.Do("SELECT", REDIS_DB) return c, nil &#125;, &#125;&#125;func GetRedis() redis.Conn &#123; return redisClient.Get()&#125; 对应的测试文件 在同目录创建一个 redis_test.go 123456789101112package toolsimport ( "testing")func TestGetRedis(t *testing.T) &#123; co := GetRedis() defer co.Close() co.Do("SET", "test_redis_key", "test_redis_value")&#125; 测试脚本的标准格式是: 文件名为 xxx_test.go 作为测试文件标记 引入 testing 包 要测试的函数名为 TestXXXX(t *testing.T) 输出结果通过 t.Logf() t.Error() 这类的测试包提供的函数来调用 写完代码, 在目录下运行:123456# 运行当前目录所有测试文件并输出结果go test -v# 运行指定测试文件, 需要把被测试文件也带上go test -v redis.go redis_test.go# 运行指定的测试方法go test -v --test.run TestGetRedis]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
</search>
