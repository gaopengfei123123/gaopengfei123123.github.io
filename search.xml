<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Php开发过程中不常碰到的error (8.14更新)]]></title>
    <url>%2F2018%2F08%2F26%2Fphp-unsual-mistakes%2F</url>
    <content type="text"><![CDATA[这里做一些备注,以防再次碰到 url 当中的参数有 &amp;timestamp=1234567890这样的字段会被转义成xtamp=1234567890这个不仅存在于页面解析当中,当使用 curl 请求时拼接的参数有这种格式的也会发生转义解决方法有两个: 把 timestamp 这个参数放在 urlQuery 的最前面, ?timestamp=1234567890 这样避免出现 &amp;time发生转义的情况 将&amp;用&amp;amp;来代替 Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.出现这句话通常说明你在用的 php 版本是5.6.而且在php&lt;=5.6的时候,进行 application/json格式的 post 提交会把数据放在$HTTP_RAW_POST_DATA这个系统变量里面,在php&gt;=7的时候这个变量被移除了,统统归总到php://input这里解决方法: 根据系统提示的走: Although that indeed would be technically impossible (as $HTTP_RAW_POST_DATA is populated in the bootstrapping phase of the PHP process) allow one to override the setting by means of calling ini_set. 要确保自己的系统中没有使用 HTTP_RAW_POST_DATA这个变量,直接在php.ini里面禁掉它的设置,但是容易出现系统中又打开的情况(在框架中很常见) 改一下自己的提交方式, 使用 application/form-data或者application/x-www-form-urlencoded这种格式的提交, 然后在后端接收数据的时候再转成自己需要的格式(通常是数组) 参考资料 Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’这种情况出现在平时运行的好好的, 但是突然换 cli 模式后这个配置就出问题了,原因在当 host=localhost时走的是 unix:socket 链接, 当host=127.0.0.1走的是 tcp 链接,这在php-fpm和php-cli中有点区别,尤其是本地没有安装 mysql 的时候解决方法有三种: 将本地链接配置统一成 127.0.0.1 查看 MySQL 中的user表, host=localhost和host=127.0.0.1是不是用的同一个账号密码 配置php.ini文件中的pdo_mysql.default_socket= 写上完整的 socket 路径以上三种方法都可以试一下参考资料 常驻内存时发生的事情这个是 phper 很少碰到但是很常见的情况, 比如用 swoole 启动了一个常驻进程的服务, 那么就一定要小心使用静态变量,在同步模式下会发生变量污染, 还有就是 redis,mysql 这类的链接,你会发现长时间静置以后就会出现一些摸不着头脑的问题, 这种情况不妨想一下是不是 server 端回收了这个 socket,因此在 client 端怎么都写入不进去. 还有就是 php 在读取消息的时候,出现消息过长的情况,那么就要考虑EOF终止符的问题了… 单次 http 每一次请求都是全新的代码, 不用自己考虑 gc 的问题, 但是在常驻内存的时候,这些就是一个个的大坑了 mysql has gone away产生这个错误的主要原因是 mysql server 端断开了链接, client 端还拿着这个句柄去请求,解决方式有两种: show global variables like &#39;%timeout&#39;; 查看 wait_timeout 的时长,适当的调长一点, 这种方法治标不治本,而且有隐患 12mysql&gt; set global wait_timeout=10;mysql&gt; show global variables like 'wait_timeout'; 使用 mysql 之前需要 mysql_ping() 一下, 如果出现断开的错误就启动重连机制 js 和 php 交互传中文参数的编解码问题之前碰到了问题是:在 php 端 urlencode 的值为:1orderid%3D21111111110001954%26pid%3D257742%26reason%3D%E4%B8%AA%E4%BA%BA%E6%96%B9%E9%9D%A2%E5%8E%9F%E5%9B%A0_%E4%BD%BF%E7%94%A8%E7%BA%A2%E5%8C%85%E9%87%8D%E6%96%B0%E4%B8%8B%E5%8D%95%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f 需要 urldecode 一次 而在 js 端的结果是:1orderid%3D21111111110002170%26pid%3D257742%26reason%3D%25E4%25B8%25AA%25E4%25BA%25BA%25E6%2596%25B9%25E9%259D%25A2%25E5%258E%259F%25E5%259B%25A0_%25E4%25B8%25AA%25E4%25BA%25BA%25E8%25BA%25AB%25E4%25BD%2593%25E5%258E%259F%25E5%259B%25A0%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f 需要 urldecode 两次 查阅资料后:12345678910111213在后端是PHP程序的情况下，保持前端Javascript和PHP之间传值的统一编码可以使用以下函数进行处理： WEB前端JavaScript 编码：escape(encodeURI(string)) 解码：unescape(decodeURI(string)) WEB后端Php 编码：urlencode(string) 解码：urldecode(urldecode(string)) 为什么要encodeURI(url)两次才不会出现乱码？ PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent 的区别rawurlencode遵守是94年国际标准备忘录RFC 1738 urlencode实现的是传统做法，和上者的主要区别是对空格的转义是’+’而不是’%20’javascript的encodeURL也是94年标准，而javascript的escape是另一种用”%xxx”标记unicode编码的方法。推荐在PHP中使用用rawurlencode。弃用urlencode 样例source:超级无敌的人sadha sajdh数据样本sdls fhejrthcxzb.file.jpeg PHP urlencode:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha+sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls+fhejrthcxzb.file.jpeg PHP rawurlencode:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg Javascript encodeURI|encodeURIComponent:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg Javascript escape:%u8D85%u7EA7%u65E0%u654C%u7684%u4EBAsadha%20sajdh%u6570%u636E%u6837%u672Csdls%20fhejrthcxzb.file.jpeg 帖子原文 在前端还有个问题就是, js 的 encodeURIComponent 和 encodeURI 都不会转换 _-.!~*&#39;()# 这些保留字符, 而在后端的rawurlencode 则是会转换的, 因此需要前端单独把这几个给拎出来, 如下:12"*".charCodeAt(0) // 42String.fromCharCode(42) // * 这里有张图说的很明白图片来源 关于出现 &lt;U+200B&gt; 这种 zero-width space 字符如果出现 mb_substr 这类操作的时候, 会出现字数判断错误的问题, 这个有时候很难排查, 因为在 win 上,使用命令行或者 linux 上用cat命令是看不到字符间是有 &lt;U+200B&gt; 的, 如下: 这玩意儿出现的场景就是: 在前端输入框中输入几个字, 然后复制粘贴. 这样尽管看起来之间没有空格, 但是其中还是插入了这个字符这玩意就叫 zero-width space 零宽空格, 处理的办法也很简单, 前端传值之前给过滤一下, 比如 https://stackoverflow.com/questions/7055600/u200b-zero-width-space-characters-in-my-js-code-where-did-they-come-from 或 https://codeday.me/bug/20171122/97765.html 后端 php 处理的话和这个不一样, 使用 utf-8 的处理方式, 可以参考这篇文章 特殊字符的删除办法与原理 替换这种编码123$value = str_replace("\xe2\x80\x8b", '', $value);$value = str_replace("\xe2\x80\x8c", '', $value);$value = str_replace("\xe2\x80\x8d", '', $value); 编码对照如下:]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞定 Git 合并冲突]]></title>
    <url>%2F2018%2F08%2F03%2Fgit-merge-conflict%2F</url>
    <content type="text"><![CDATA[这次说一下通过命令行去批量解决文件冲突的问题, 这个方法适用你清楚的知道自己需要保留哪一个分支, 而不是两个分支里的改动都要一点 关键命令checkout 是个好方法, 能粗暴的解决很多问题 针对冲突文件保留自己的分支1git checkout --ours path/to/conflict_file 想保留别人的分支1git checkout --theirs path/to/conflict_file 批量的解决: 1grep -lr '&lt;&lt;&lt;&lt;&lt;&lt;&lt;' . | xargs git checkout --ours 一个鲜活的例子…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566➜ test mkdir merge-demo➜ test cd merge-demo➜ merge-demo ls➜ merge-demo echo 'first commit' &gt; index.txt➜ merge-demo cat index.txtfirst commit➜ merge-demo git initInitialized empty Git repository in /Users/gpf/Documents/test/merge-demo/.git/➜ merge-demo git:(master) ✗ git add -A➜ merge-demo git:(master) ✗ git commit -m 'init'[master (root-commit) e9f17b3] init 1 file changed, 1 insertion(+) create mode 100644 index.txt➜ merge-demo git:(master) git checkout -b testSwitched to a new branch 'test'➜ merge-demo git:(test) echo 'second commit by test' &gt; index.txt➜ merge-demo git:(test) ✗ git add -A &amp;&amp; git commit -m 'second commit'[test 4d20ff3] second commit 1 file changed, 1 insertion(+), 1 deletion(-)➜ merge-demo git:(test) cat index.txtsecond commit by test➜ merge-demo git:(test) git checkout masterSwitched to branch 'master'➜ merge-demo git:(master) echo 'third commit by master' &gt; index.txt➜ merge-demo git:(master) ✗ git add -A &amp;&amp; git commit -m 'third commit'[master 85e520e] third commit 1 file changed, 1 insertion(+), 1 deletion(-)➜ merge-demo git:(master) git merge testAuto-merging index.txtCONFLICT (content): Merge conflict in index.txtAutomatic merge failed; fix conflicts and then commit the result.➜ merge-demo git:(master) ✗ git statusOn branch masterYou have unmerged paths. (fix conflicts and run "git commit") (use "git merge --abort" to abort the merge)Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) both modified: index.txtno changes added to commit (use "git add" and/or "git commit -a")➜ merge-demo git:(master) ✗ cat index.txt&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADthird commit by master=======second commit by test&gt;&gt;&gt;&gt;&gt;&gt;&gt; test➜ merge-demo git:(master) ✗ git checkout --ours index.txt➜ merge-demo git:(master) ✗ cat index.txtthird commit by master➜ merge-demo git:(master) ✗ git statusOn branch masterYou have unmerged paths. (fix conflicts and run "git commit") (use "git merge --abort" to abort the merge)Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) both modified: index.txtno changes added to commit (use "git add" and/or "git commit -a")➜ merge-demo git:(master) ✗ git add -A &amp;&amp; git commit -m 'done'[master d2d2057] done]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>merge-conflict</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不正宗 Docker 入门教程-使用 Docker-Compose (3/3)]]></title>
    <url>%2F2018%2F07%2F20%2Fdocker-step-3%2F</url>
    <content type="text"><![CDATA[本章通过一个具体的demo来了解 docker-compose docker-compose 是做什么的在构建一个完整的服务时，我们通常启动一个容器， 一旦出现多个容器需要同时启动的时候手打是下下之策， 因为时间一长难免会忘记细节，写脚本也不是不可以，但是大家没有达成共识时脚本也很难维护… docker-compose 就是来解决这个痛点， 只需要按照统一的格式书写，那么大家生成的容器也都是一致的， 在团队开发的时候扔一个配置好的 docker-compose 能节省很多时间和口水 配置 docker-compose这是我构建的一个开发环境的容器:dnmp 首先下载下来1git clone https://github.com/gaopengfei123123/dnmp.git &amp;&amp; cd dnmp 我们第一件事就是先瞄一眼 .env 文件， 这里设置了很多常量，一会根据个人需求来调整 第二步才是打开 docker-compose.yml 文件， 看后缀都能猜到这是一个配置文件， 另外 docker-compose.yml 是根据缩进来进行分层的，注意书写格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# docker-compose.yml# 语法版本( 3 和 2 区别有点大, 比如 3 取消了 volume_from 的相关语法)version: "3"networks: frontend: driver: $&#123;NETWORKS_DRIVER&#125; backend: driver: $&#123;NETWORKS_DRIVER&#125;volumes: mysql_volume: driver: $&#123;VOLUMES_DRIVER&#125; redis_volume: driver: $&#123;VOLUMES_DRIVER&#125; rabbitmq_volume: driver: $&#123;VOLUMES_DRIVER&#125;# 服务编排services: # workspace: # image: tianon/true # container_name: dnmp-www # volumes: # - ./www:/usr/share/nginx/html# NGINX ############################################# nginx: container_name: dnmp-nginx build: context: ./nginx args: - PHP_UPSTREAM_CONTAINER=$&#123;NGINX_PHP_UPSTREAM_CONTAINER&#125; - PHP_UPSTREAM_PORT=$&#123;NGINX_PHP_UPSTREAM_PORT&#125; depends_on: - php-fpm ports: - "$&#123;NGINX_HOST_HTTP_PORT&#125;:80" - "$&#123;NGINX_HOST_HTTPS_PORT&#125;:443" volumes: # 没必要把配置文件用卷来挂载, 不然就算配置更新了 nginx 也是要重启的 # 挂载运行代码目录 - $&#123;APP_CODE_PATH_HOST&#125;:/var/www # 挂载日志目录 - $&#123;NGINX_HOST_LOG_PATH&#125;:/var/log/nginx # 使用 networks 取代 links 在同一个网络模式下的服务是互通的 # 在service 中使用其他的 service 就直接调用 service 名就行, 不用管 ip 地址, docker 会自己维护一套 networks: - frontend - backend# PHP-FPM ############################################# php-fpm: container_name: dnmp-php-fpm # 这里的args 是属于 build 下面的,用于构建./php-fpm/Dockerfile 文件中 ARG 参数指定 php 版本 build: context: ./php-fpm args: - PHP_VERSION=$&#123;PHP_VERSION&#125; volumes: - $&#123;APP_CODE_PATH_HOST&#125;:/var/www - ./php-fpm/php$&#123;PHP_VERSION&#125;.ini:/usr/local/etc/php/php.ini expose: - "9000" networks: - backend redis: container_name: dnmp-redis build: context: ./redis args: - REDIS_SET_PASSWORD=$&#123;REDIS_SET_PASSWORD&#125; ports: - $&#123;REDIS_HOST_PORT&#125;:6379 volumes: # 这里卷挂载的是本地文件 # - $&#123;DATA_PATH_HOST&#125;/redis:/data # 这里创建一个 redis_volume来存放数据 - redis_volume:/data# Mysql ############################################# mysql: container_name: dnmp-mysql # 镜像来源: https://github.com/docker-library/mysql/blob/fc3e856313423dc2d6a8d74cfd6b678582090fc7/5.7/Dockerfile image: mysql:$&#123;MYSQL_VERSION&#125; volumes: # - $&#123;DATA_PATH_HOST&#125;/mysql:/var/lib/mysql - mysql_volume:/var/lib/mysql # 容器只要停止就会重启 restart: always environment: MYSQL_ROOT_PASSWORD: $&#123;MYSQL_ROOT_PASSWORD&#125; MYSQL_DATABASE: $&#123;MYSQL_DATABASE&#125; MYSQL_USER: $&#123;MYSQL_USER&#125; MYSQL_PASSWORD: $&#123;MYSQL_PASSWORD&#125; ports: - $&#123;MYSQL_HOST_PORT&#125;:3306 接下来看看它的关键词都起着什么作用： version这个规定了文件的版本， 既然有 3 就肯定不用 2 啊， 虽然两者没冲突，但是我喜欢， 2 和 3 版本之间有轻微的变动，具体区别你可以在写配置文件时产生的报错信息来体验一下 network12345networks: frontend: driver: $&#123;NETWORKS_DRIVER&#125; backend: driver: $&#123;NETWORKS_DRIVER&#125; ${NETWORKS_DRIVER} 是从 .env 文件中取的值， 下面的同理 这一块就相当于执行 docker network create -d bridge frontend &amp;&amp; docker network create -d bridge backend在本地持久化的建立一个网络配置，稍后方便容器进行连接， 当然这里也不止是一个 driver 参数，具体配置情况还是参考docker network inspect dnmp_frontend 来看一下 没有设置名字的配置当需要名字的时候会 {当前docker-compose.yml文件名}_{key} 这种格式 有了 network 配置就极大的简化了老版的 --links 命令， 只要属于同一个 network 就能互相访问到， 而不是每新增一个服务就要把原来的服务都 link 一遍 volume1234567volumes: mysql_volume: driver: $&#123;VOLUMES_DRIVER&#125; redis_volume: driver: $&#123;VOLUMES_DRIVER&#125; rabbitmq_volume: driver: $&#123;VOLUMES_DRIVER&#125; 和 network 部分一样， 持久化的创建几个 volume, 相当于命令 docker network create mysql_volume等等 这算是 v3 的一个新特性， 在 v2 的时候， 为了共享数据大家会创建一个什么镜像都不继承的image， 所有容器的 volume 都会和它连接， 现在有了 volume 就没必要这么搞了 service这个是本章的重点， 我们来看下面的例子中的注释， 按序号来12345678910111213141516171819202122232425262728293031323334353637383940services: #1 创建一个服务叫做nginx服务 nginx: #2 为了显得个性化一点，我们指定这个容器的名字叫做 dnmp-nginx container_name: dnmp-nginx #3 标明这个服务的 Dockerfile 的地址，用相对路径方便项目迁移 build: #3.1 相当于命令： # docker build ./nginx -t dnmp-nginx \ # --build-arg PHP_UPSTREAM_CONTAINER=xxx \ # --build-arg PHP_UPSTREAM_PORT=zzz context: ./nginx #3.2 这里 $&#123;NGINX_PHP_UPSTREAM_PORT&#125; 的值是从 .env 文件中取的， args 属于构建时传入的参数 args: - PHP_UPSTREAM_CONTAINER=$&#123;NGINX_PHP_UPSTREAM_CONTAINER&#125; - PHP_UPSTREAM_PORT=$&#123;NGINX_PHP_UPSTREAM_PORT&#125; #4 在启动这个容器之前先启动 php-fpm 这个容器 depends_on: - php-fpm #5 将本地端口和容器端口绑定， 本地哪个端口就看 .env 里怎么写的 ports: - "$&#123;NGINX_HOST_HTTP_PORT&#125;:80" - "$&#123;NGINX_HOST_HTTPS_PORT&#125;:443" #6 设置需要挂载的卷, 这里时将本地目录和容器绑定， 也可以像 services.redis 那样和创建好的卷绑定 volumes: # 没必要把配置文件用卷来挂载, 不然就算配置更新了 nginx 也是要重启的 # 挂载运行代码目录 - $&#123;APP_CODE_PATH_HOST&#125;:/var/www # 挂载日志目录 - $&#123;NGINX_HOST_LOG_PATH&#125;:/var/log/nginx # 使用 networks 取代 links 在同一个网络模式下的服务是互通的 # 在service 中使用其他的 service 就直接调用 service 名就行, 不用管 ip 地址, docker 会自己维护一套 #7 设置容器从属的网络， 同一个网络下可互相访问 networks: - frontend - backend 在上文的 #3 步骤看其他的service也有直接使用image的， 这是直接从远程获取镜像的方式 配置文件写完了， 我们看下nginx的构建文件 12345678910111213141516171819202122232425262728293031# in file ./nginx/Dockerfile#1 选择继承的镜像FROM nginx:1.13.1-alpine#2 各种标签LABEL maintainer="GPF &lt;5173180@qq.com&gt;"#3 容器中执行命令， 且把本地的配置文件添加进去#https://yeasy.gitbooks.io/docker_practice/content/image/build.htmlRUN mkdir -p /etc/nginx/cert \ &amp;&amp; mkdir -p /etc/nginx/conf.d \ &amp;&amp; mkdir -p /etc/nginx/sitesCOPY ./nginx.conf /etc/ngixn/nginx.confCOPY ./conf.d/ /etc/nginx/conf.d/COPY ./cert/ /etc/nginx/cert/COPY ./sites /etc/nginx/sites/#4 这里也是设置构建参数， 不过相同 key 值会被 docker-compose 中的给覆盖掉ARG PHP_UPSTREAM_CONTAINER=php-fpmARG PHP_UPSTREAM_PORT=9000#5 $&#123;PHP_UPSTREAM_CONTAINER&#125; 就在构建时的参数使用方式RUN echo "upstream php-upstream &#123; server $&#123;PHP_UPSTREAM_CONTAINER&#125;:$&#123;PHP_UPSTREAM_PORT&#125;; &#125;" &gt; /etc/nginx/conf.d/upstream.conf#6 设置挂载的目录， 该目录下文件变化不会影响到容器VOLUME ["/var/log/nginx", "/var/www"]#7 设置目录运行时所处在容器中的目录地址WORKDIR /usr/share/nginx/html #5 就是显示了在 nginx 容器中怎么去访问 php-fpm 这个容器, 直接调用 service 名称就行 这里需要注意的时 ARG 和 ENV 的区别， 参考这篇文章： Docker中 Arg 和 Env 的区别 启动docker-compse在配置好 .env 文件和 docker-compose.yml 配置文件后就可以启动它了， 命令也很简单，在同级目录下运行：1docker-compose up -d 它会自动创建volume，network，services， 而且相关的运行参数都是按着配置文件来的， 这样一来每个完整docker-compose.yml中的service就相当于时一个整体，每个服务又属于各自的容器，这样操控是不是节省了很多代码呢？ 查看这些容器的运行状况也很是简单 12docker-compose ps# 或者使用更方便的一个工具： ctop ， github地址： https://github.com/bcicen/ctop 可操控单一容器一样， 但是它会把这一组容器都囊括了进去，操控起来只需要知道操控哪个服务，而一些参数就写在配置文件当中已经默认添加了 一些常用的命令：1234567891011121314# 终止整个服务集合docker-compose stop# 终止指定的服务 （这有个点就是启动的时候会先启动 depond_on 中的容器，关闭的时候不会影响到 depond_on 中的）docker-compose stop nginx# 查看容器的输出日志docker-compose logs -f [services...]# 构建镜像时不使用缓存（能避免很多因为缓存造成的问题）docker-compose build --no-cache --force-rm# 移除指定的容器docker-compose rm nginx 本来熟悉命令的最好方式就是 用-&gt;犯错-&gt;排错-&gt;用 这种循环, 有什么不懂的 谷歌bing 都能查到, 直接 docker-compose --help 也能猜出命令的大概作用, 这里就不细说了 还有个很不错的 docker-compose 项目就是 laradock, dnmp 就是仿照着它写的， 不过网络不好的情况下别运行 laradock， 它现在做的太臃肿了。。。。 看看它里面的镜像是怎么写的还是很有收获的 相关 不正宗 Docker 入门教程-启动一个容器(1/3) 不正宗 Docker 入门教程-构建一个镜像(2/3) 不正宗 Docker 入门教程-使用 Docker-Compose (3/3)]]></content>
      <tags>
        <tag>docker入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不正宗 Docker 入门教程-构建一个镜像(2/3)]]></title>
    <url>%2F2018%2F07%2F08%2Fdocker-step-2%2F</url>
    <content type="text"><![CDATA[本章讲的大概能让你明白虚拟机和 docker 的区别… docker 设置了两种构建镜像的方式: 通过 docker commit 构建镜像(不推荐)这个命令是将先有的容器制作成镜像, 不过建议仅用在排查问题的时候使用, 平时生成容器时最好不要用这种镜像, 因为不知道里面有什么改动, 对于开发者来说完全是一个黑盒 命令格式:1docker commit [参数] &lt;容器 ID 或 容器名&gt; [仓库名[:标签]] [flags] 比如(我随便找了一个本地容器 ID):12345➜ ~ docker commit -m "这是一个测试镜像" -a "GPF" 5ad06ec670eb local_nginx:v1sha256:134e09cdce58842dea03202aa5b6516ead8268afe78d2203be8595b4f0bc5ebe➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZElocal_nginx v1 134e09cdce58 2 seconds ago 109MB 这就把当前的容器转换成了镜像, 提交到远程就是:1docker push local_nginx:v1 和git很像对不对? 不过推送到远程时需要有个 dockerhub 的账号 docker history 命令可以查看镜像的构建记录12345678910111213➜ ~ docker history 134e09cdce58IMAGE CREATED CREATED BY SIZE COMMENT134e09cdce58 12 seconds ago nginx -g daemon off; 0B 这是一个测试镜像649dcb69b782 4 days ago /bin/sh -c #(nop) CMD ["nginx" "-g" "daemon… 0B&lt;missing&gt; 4 days ago /bin/sh -c #(nop) STOPSIGNAL [SIGTERM] 0B&lt;missing&gt; 4 days ago /bin/sh -c #(nop) EXPOSE 80/tcp 0B&lt;missing&gt; 4 days ago /bin/sh -c ln -sf /dev/stdout /var/log/nginx… 22B&lt;missing&gt; 4 days ago /bin/sh -c set -x &amp;&amp; apt-get update &amp;&amp; apt… 53.7MB&lt;missing&gt; 4 days ago /bin/sh -c #(nop) ENV NJS_VERSION=1.15.1.0.… 0B&lt;missing&gt; 4 days ago /bin/sh -c #(nop) ENV NGINX_VERSION=1.15.1-… 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) LABEL maintainer=NGINX Do… 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) CMD ["bash"] 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) ADD file:28fbc9fd012eef727… 55.3MB 通过 Dockerfile 构建镜像一个 Dockerfile 就是一个构建镜像的脚本, 常用的几个命令也不多, 也就FROM, COPY, RUN, ADD, ARG, ENV, VOLUME, EXPOSE, CMD, LABEL, 其他的一些命令就不再这里说了, 想了解完整的 Dockerfile 的关键词看这个 Dockerfile reference 一个简单的 demo接下来我们就用一个完整的 Dockerfile 来示范一下: 首先创建一个Dockerfile12mkdir dockerfile_demo &amp;&amp; cd dockerfile_demovi Dockerfile 12345678910111213# dockerfile 内容# 继承的 ubuntu 镜像的版本号FROM ubuntu:16.04# 将本地 workdir 的文件复制到镜像内部, 另外有个 ADD 指令和这个效果类似, 不过不推荐使用COPY ./sources.list /etc/apt/sources.list# 在镜像内部执行命令, 这里就是更新版本和安装 nginxRUN apt-get update &amp;&amp; apt-get install -y nginx# 修改 nginx 默认的 index.html 的内容RUN echo 'Hi, I am in your container'\ &gt;/var/www/html/index.html# 镜像对外暴露80端口EXPOSE 80 然后为了更新速度快一点, 就要换一个国内镜像1vi sources.list 123456789101112# sources.list 内容deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 然后还是在这个目录下, 运行:1docker build ./ -t local_ubuntu_nginx:v2 执行完毕后就能看到本地多了一个镜像123➜ Documents docker imagesREPOSITORY TAG IMAGE ID CREATED SIZElocal_ubuntu_nginx v2 b0f5984c042a 14 minutes ago 214MB 用这个镜像构建一个容器:123➜ Documents docker run -it --rm -p 8088:80 local_ubuntu_nginx:v2 /bin/bashroot@5cb9ff723bee:/# /usr/sbin/nginxroot@5cb9ff723bee:/# 保持终端打开, 本地访问 http://localhost:8088/ 就能看到欢迎界面了  如果这个是关闭交互端口, 这个就访问不到了, 这里要说一个关键点了 在 docker 中运行的程序不能使用后台运行的模式, 否则 docker 会任务这个容器不活跃或出现问题而自动关闭但是 docker 容器本身是可以后台运行的: docker run -d …… 关于 docker build 多说一句之前我们构建时执行的:1docker build ./ -t local_ubuntu_nginx:v2 这个 ./ 的路径指的是构建文本流(context)的路径, 而不是 Dockerfile的文件路径, 在 Dockerfile 中用的各种相对路径都是基于 context 的,我们完全可以是1docker build /path/to/context -f /path/to/anywhere/Dockerfile_demo -t local_ubuntu_nginx 你看, Dockerfile 的文件名不就变成 Dockerfile_demo 了, 如果有1COPY ./sources.list /etc/apt/sources.list 这样的操作, 那么它的完整路径应该是 /path/to/context/sources.list, 不过默认的情况下就是这两个路径是一起的, 不设置镜像tag的话就拿 Dockerfile 所在的目录名为镜像名,默认latest版本 多阶段构建有时候我们的运行环境和编译环境是两回事, 就拿 golang 来举例, 我们只会去维护代码, 而不去管它生成的二进制包是什么, 又因为golang 打包出来的二进制文件几乎是没有依赖, 只要执行这个文件就行, 那么在运行环境中和编译相关的程序就是多余的, 可以看一下官网的示例 Use multi-stage builds, 不能翻墙的看这个 123456789101112FROM golang:1.7.3WORKDIR /go/src/github.com/alexellis/href-counter/RUN go get -d -v golang.org/x/net/html COPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest RUN apk --no-cache add ca-certificatesWORKDIR /root/# 这个是关键, --from=0 是指从第一个镜像(from)中复制内容, 程序中的1 就是0COPY --from=0 /go/src/github.com/alexellis/href-counter/app .CMD ["./app"] 1$ docker build -t alexellis2/href-counter:latest . 这是我自己构建镜像时编译 swoole.so 的镜像和运行时的镜像大小我们只想要一个 swoole.so 像 gcc, make 都是不是代码运行时需要的模块, 因此只是在编译的时候用上, 吐一个swoole.so出来就行, 相关代码 12345678910111213141516171819202122232425262728293031FROM php:5.6.36-cli-alpine3.7 as builder# 中国特色RUN echo "http://mirrors.ustc.edu.cn/alpine/v3.7/main/" &gt; /etc/apk/repositories# 添加编译 swoole 需要的前置插件RUN apk update &amp;&amp; \ apk upgrade &amp;&amp; \ apk add alpine-sdk linux-headers &amp;&amp; \ apk add autoconf gcc makeRUN wget https://github.com/swoole/swoole-src/archive/1.8.12-stable.tar.gz &amp;&amp; \ tar zxvf 1.8.12-stable.tar.gz &amp;&amp; \ cd swoole-src-1.8.12-stable &amp;&amp; \ phpize &amp;&amp; \ ./configure &amp;&amp; \ make &amp;&amp; make installFROM php:5.6.36-cli-alpine3.7 as runtimer# 这里因为给每一个阶段加了别名, 这样更方便一点COPY --from=builder /usr/local/lib/php/extensions/no-debug-non-zts-20131226/swoole.so /usr/local/lib/php/extensions/no-debug-non-zts-20131226/swoole.soCOPY ./swoole.ini /usr/local/etc/php/conf.d/swoole.ini# 通常 run 是构建镜像时用的, 会保存一层缓存, cmd 就是镜像启动后执行的命令RUN ["php", "-m"]CMD ["php", "-a"] 构建镜像时需要注意的几点 尽量使用官方镜像, 同时版本选择 alpine &gt; debian &gt; ubuntu &gt; centos, alpine版本的镜像是最小的 COPY 和 ADD 尽量使用 COPY, COPY 只是单纯的复制, ADD 则会自动执行一些东西, 有可能出现意料外的问题 CMD 和 ENTERPOINT 这两个可以查一下区别, 我个人习惯用 CMD 容器中的程序都要前台执行的模式, 使用 daemon 模式会被退出(你想想本身一个后台运行的容器中有个后台运行的程序…) 每一个 RUN 指令就是一层缓存, 当其中一个步骤发生更改那么这之后的步骤也都重新构建 系统更新最好合成一个 RUN 比如: 1234RUN apk update &amp;&amp; \ apk upgrade &amp;&amp; \ apk add alpine-sdk linux-headers &amp;&amp; \ apk add autoconf gcc make 同样还是为了避免因为缓存时出现问题 多看看官方构建的镜像, 收获会很多, 比如 docker-nginx, docker-php 相关 不正宗 Docker 入门教程-启动一个容器(1/3) 不正宗 Docker 入门教程-构建一个镜像(2/3) 不正宗 Docker 入门教程-使用 Docker-Compose (3/3)]]></content>
      <tags>
        <tag>docker入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不正宗 Docker 入门教程-启动一个容器(1/3)]]></title>
    <url>%2F2018%2F07%2F06%2Fdocker-step-1%2F</url>
    <content type="text"><![CDATA[从命名上就知道这是一篇简单粗暴的docker新手入门教程， 为什么要简单粗暴？ 我认为有自学能力的人帮他入门就够了， 不能自学的一时半会儿也教不会， 不符合入门教程的初衷， 建议出门左拐去找找视频教程… 本章目标 大概了解 docker 是个什么玩意 知道常用的 docker 指令参数, 能启动一个容器(不然还想怎么样? 上天吗?) 安装环境强烈推荐使用 Docker for Mac 或 Docker for Windows, 这两个工具已经将 Kitematic 和 docker-compose 集成好了， 至于这两个工具是做什么的咱们后面再说， win10 版本需要专业版的， 不然开启不了Hyper-V， win7 就别想了，不支持… 怎么安装在 阿里云镜像容器服务 里面都说的很清楚了， 连国内镜像源都给你安排好了， 咱们就进入下一话题 PS: 如果是 CentOS 6 的就需要升级一下系统内核了， centOS6.5 安装docker， 毕竟都 8102 年了， docker 又是个比较新的东西， 对于稍微久一点的系统的支持就不那么友好 运行第一个容器安装完环境之后就启动一个镜像开开眼儿1docker run -d -p 8080:80 --name local_nginx nginx 然后访问 http://localhost:8080/ 就能看到 nginx 的初始界面了 中间发生了什么呢？ docker run 运行镜像的起手式， 详情查看 docker run --help -d 启动 docker 守护进程 -p 8080:80 将本地的 8080 端口绑定到容器的 80 端口上 --name local_nginx 分配一个容器名， 不写的话会默认分配要给， 不过这个还是很有用的 nginx 指定运行的镜像名，如果没有指定标签则默认是 latest， 这里其实是启动nginx:latest镜像 现在可以查看一下本机都在运行着什么镜像123PS D:\docker_study&gt; docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6732fa239270 nginx "nginx -g 'daemon of…" 18 minutes ago Up 18 minutes 0.0.0.0:8080-&gt;80/tcp local_nginx docker ps 只能看到正在运行中的容器， 想看到全部的就是 docker ps -a 进入这个容器的命令:123docker exec -it 6732fa239270 /bin/bash#或docker exec -it local_nginx /bin/bash 解释一下: docker exec 在容器中执行命令 -i 保持stdin打开 -t 分配一个伪终端(tty) 6732fa239270 或 local_nginx 这里你也发现了， 可以是通过 CONTAINER ID 也可以是 NAMES 这里的 CONTAINER ID分为128位长ID和32位短ID， 不过作用都是一样的 /bin/bash 运行容器中的 /bin/bash 脚本 进入容器中感觉其实和进入一个虚拟机一样， 但是容器和虚拟机有点区别， 这个我们下一小节会讲到 关闭容器1docker stop 6732fa239270 或 local_nginx 什么是容器？什么是镜像？ 之前我们使用 VirtualBox 装虚拟机的时候有装盘镜像, 但是启动后就是一个个的虚拟机了, 不过在 docker 中和虚拟机还是有点区别 就拿上图来说, container就是镜像的实例化, image 是容器的底层支撑, 其实他们的关系用代码中的类Class来比喻是最合适的: Class 就是我们实际开发中写的一个代码集合, Object 是 Class 实例化之后生成的一种资源变量 Image 也是预先写好的逻辑, 并存在一个地方, Container 是 Image 启动之后生成的一个虚拟系统 实例化出来的 Object 不会影响到 Class 中的内容 已经启动的 Container 也不会影响到 Image 中的逻辑 Class 可以继承别的 Class, 从而继承它的特性 Image 也是可以继承别的 Image, 并在它的基础上构建新的镜像 一个 Object 对应着一个 Class, 但是 一个 Class 可以实例化无数个 Object 同理, 一份 Image 可以生成无数个 Container, 这就是方便集群化部署的所在 简单的说 Container 就是 Image 的儿子, 模样和 Image 预想的一样, 但是 Container 运行之后会发生一些改变, 而且这种改变是可以保存的 7-11补充: 这位大佬讲的 image 和 虚拟机 之前的很清晰 -&gt; 宋宝华：Docker 最初的2小时(Docker从入门到入门), 不过推荐是先敲几个实际的例子运行一下再看, 工具先跑起来再去了解它嘛! 常用的运行参数和命令咱们先不说构建镜像的事儿(那是下一章的话题), 这里先了解一下 docker run 命令中比较常用的参数: -it 建立一个可在终端交互的容器比如:123docker run -it --name local_nginx nginx:latest /bin/bash# 或docker exec -it local_nginx bin/bash -p 用于宿主机和容器的端口绑定绑定多个端口就设置多个映射1234567docker run -d -p 8088:80 -p 4433:443 nginx:latest# 或 不写本地端口, docker 将帮你自动分配docker run -d -p :80 -p :443 nginx:latest# 或 加上 ip 就绑本地指定的 ipdocker run -d -p 127.0.0.1:8088:80 -p :443 nginx:latest# 或 照样不写本地端口就随机分配docker run -d -p 127.0.0.1::80 -p :443 nginx:latest 通过 docker ps 可以看一下上面两行命令的执行状态1234➜ test docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES57f65b46bd87 nginx:latest "nginx -g 'daemon of…" 1 second ago Up 3 seconds 0.0.0.0:32769-&gt;80/tcp, 0.0.0.0:32768-&gt;443/tcp happy_zhukovsky0c035ebabe44 nginx:latest "nginx -g 'daemon of…" About a minute ago Up About a minute 0.0.0.0:8088-&gt;80/tcp, 0.0.0.0:4433-&gt;443/tcp ecstatic_haibt -v 将宿主机的卷挂载到容器中的指定目录1docker run -d -p 8088:80 -v /Users/gpf/Documents/docker_study/docker_test/www/:/usr/share/nginx/html/ nginx:latest 这里本地的目录要写绝对路径, 不然会报错, 这样一来, 本地的/Users/gpf/Documents/docker_study/docker_test/www/ 就是容器中的/usr/share/nginx/html/, 就可以本地更改代码, 然后容器中运行 -d 后台运行想查看日志的话就 docker logs [containerID] 就行 docker exec 执行 docker 容器中的命令通常就是用来进入容器中搞七搞八的123docker exec -it 57f65b46bd87 /bin/bash# 或docker exsec -it local_nginx /bin/bash 这里注意两点: containerID 在很多情况下都可以用 container Name 来代替, 很多情况是等价的 命令最后的 /bin/bash 不是必须这么填, 而是执行的容器中的脚本, 如果你的镜像是 alpine版的就是 sh, 因为这个版本中就没有 bash 这个命令 docker ps 容器的运行状态docker stop [containerID 或 name] 停止容器目前版本也增加了 docker container stop [containerID 或 name] 其实作用是一样的, 不过 docker container 命令底下还有很多别的命令, docker 给各模块的命令做了细分 docker rm [containerID 或 name] 删除指定未运行的容器, 一个或多个1docker rm 6dee0a9b5232 582f708af9d3 docker rmi [imageID 或 tag] 删除宿主机指定的镜像这里要注意如果这个镜像还有容器在使用就不能删除掉, 这个时候要先把对应的容器删掉才行删除指定镜像的容器12docker stop $(docker ps | grep '这里写imageName' | awk '&#123; print $1&#125;')docker rm $(docker ps | grep '这里写imageName' | awk '&#123; print $1&#125;') 删除临时构建的镜像1docker rmi $(docker images | grep '&lt;none&gt;' | awk '&#123; print $3&#125;') prune 大杀器这一手还是慎用,一些情况下可造成 rm -rf /* 的效果1234567#移除所有未使用的镜像docker image prune#移除所有未运行的容器docker container prune#移除所有未使用的本地卷docker volume prune... PS: 因为有这一手, 所以可以看出官方的态度, 他们貌似也许可能没准大概差不多不建议把容器当成虚拟机一样把所有的东西都堆在一个镜像里面, 那样搞不止构建出来的镜像臃肿, 而且维护性移植性很差, 从目前网上的 docker 镜像资源来说, 基础镜像 alpine &gt; debian &gt; ubuntu &gt; centos, 优先使用最小的基础构建, 然后整个 image 只为一个服务而构建, 比如 redis 镜像里只要 redis, 没有什么 MySQL, memcache 什么的, 多个独立的 service 才组成一个 APP, 里面各个组件替换的话不用考虑其他组件的环境依赖什么的, 当然, 这个也是看业务的实际需要, 不能为了拆分而拆分, 在这之间能找到最合适自己的才是工具给我们带来的便利 docker network 容器之间的互联如果只是在一个容器里搞来搞去就真的是虚拟机了, docker 的强大之处就是它内部维护一个网络, 处在相同网络的容器是可以互通的12345# 新建一个 docker 网络, -d bridge 是指定网络模式, 当前是桥接网络docker network create -d bridge nginx_swarm# 启动两个 nginx 容器, 分别命名 nginx_swarm_a nginx_swarm_b , 两者都加入了 nginx_swarm 这个网络 --rm 是当容器停止后自动删除docker run -it --rm --name nginx_swarm_a --network nginx_swarm nginx /bin/bashdocker run -it --rm --name nginx_swarm_b --network nginx_swarm nginx /bin/bash 注意, 我们并没把接口暴露出去, 现在随便在一个容器中 ping 另一个容器12345678910# 这是在 nginx_swarm_a 中# 没有 ping 命令的先装一个 ping# apt-get update &amp;&amp; apt-get install -y iputils-pingroot@73d04107780f:/# ping -c 3 nginx_swarm_bPING nginx_swarm_b (172.18.0.3) 56(84) bytes of data.64 bytes from nginx_swarm_b.nginx_swarm (172.18.0.3): icmp_seq=1 ttl=64 time=0.084 ms64 bytes from nginx_swarm_b.nginx_swarm (172.18.0.3): icmp_seq=2 ttl=64 time=0.161 ms64 bytes from nginx_swarm_b.nginx_swarm (172.18.0.3): icmp_seq=3 ttl=64 time=0.146 ms--- nginx_swarm_b ping statistics --- docker 能自动的把 server name 转换成 ip, 我们只需要标明请求的是哪个容器, 而不是还要记住它的 ip 地址(当然 ip 地址也能设置) 总结弄明白以下几点启动一个容器应该是没什么问题了: 国内一定要使用国内镜像源, 不然会痛不欲生, 国内 docker 仓库镜像对比 分清镜像和容器的概念, 容器就是基于镜像构建出来的一个实例 不要往容器中保存数据, 容器应该是无状态的, 需要持久化保存的就docker run -v xx:xx 或者 docker create volume ... 用独立的卷来保存 docker 不是虚拟机 分清楚宿主机端口和容器端口 处在相同network下的容器才能通过容器明互相访问 参考资料:Docker — 从入门到实践nginx 官方镜像 相关 不正宗 Docker 入门教程-启动一个容器(1/3) 不正宗 Docker 入门教程-构建一个镜像(2/3) 不正宗 Docker 入门教程-使用 Docker-Compose (3/3)]]></content>
      <tags>
        <tag>docker入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 centOS65 环境下安装 Docker]]></title>
    <url>%2F2018%2F07%2F06%2Fdocker-install-centos65%2F</url>
    <content type="text"><![CDATA[早期的 docker 对稍微老点的系统支持都不是很友好, 也是因为操作系统的一些新特性才能让 docker 运行起来 在国内的云服务商提供的 CentOS65 镜像内核都是2.6.*的，不能满足docker需要的3.1.*，因此首先需要升级一下内核12345678#导入public keyrpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org#安装elrepo到内核为2.6.32的CentOS中rpm -Uvh http://www.elrepo.org/elrepo-release-6-6.el6.elrepo.noarch.rpm#安装kernel-lt(long term support)长期支持版本yum --enablerepo=elrepo-kernel install kernel-lt -y 如果yum安装的慢，可以通过rpm安装kernel-lt12访问http://elrepo.org/linux/kernel/el6/x86_64/RPMS/下载对应的rpm包，通过rpm方式安装：rpm -ivh kernel-lt-3.10.93-1.el6.elrepo.x86_64.rpm 安装完毕后编辑配置文件123456789101112131415161718192021222324vi /etc/grub.conf# grub.conf generated by anaconda## Note that you do not have to rerun grub after making changes to this file# NOTICE: You do not have a /boot partition. This means that# all kernel and initrd paths are relative to /, eg.# root (hd0,0)# kernel /boot/vmlinuz-version ro root=/dev/xvda1# initrd /boot/initrd-[generic-]version.img#boot=/dev/xvdadefault=0timeout=5splashimage=(hd0,0)/boot/grub/splash.xpm.gzhiddenmenutitle CentOS (3.10.105-1.el6.elrepo.x86_64) root (hd0,0) kernel /boot/vmlinuz-3.10.105-1.el6.elrepo.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-3.10.105-1.el6.elrepo.x86_64.imgtitle CentOS (2.6.32-573.22.1.el6.x86_64) root (hd0,0) kernel /boot/vmlinuz-2.6.32-573.22.1.el6.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-2.6.32-573.22.1.el6.x86_64.imgtitle CentOS (2.6.32-431.23.3.el6.x86_64) 我们用的 CentOS (3.10.105-1.el6.elrepo.x86_64)就排在第一个，因此改成 default=0 保存后重启系统12uname -aLinux iZm5eib1msf1eaxvrvhp60Z 3.10.105-1.el6.elrepo.x86_64 #1 SMP Fri Feb 10 10:48:08 EST 2017 x86_64 x86_64 x86_64 GNU/Linux 安装docker123yum install -y docker-engineservice docker startsudo docker version 如果出现 Cannot connect to the Docker daemon. Is &#39;docker -d&#39; running on this host? 这种提示，按以下解决步骤： 执行 service docker start 加上 sudo 执行 yum upgrade device-mapper 我是执行到第三步就可以正常运行了，如果还没解决问题的话就自己找去吧 资料1-centos安装docker升级内核到3.10 资料2-github/docker/issues/11356]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker中 Arg 和 Env 的区别]]></title>
    <url>%2F2018%2F06%2F28%2Fdocker-arg-env%2F</url>
    <content type="text"><![CDATA[在使用 docker-compoe 构建镜像的时候会感觉 ARG 和 ENV 的作用很相似, 但是这两个存在就肯定有它的原因 它们起作用的时机 arg 是在 build 的时候存在的, 可以在 Dockerfile 中当做变量来使用 env 是容器构建好之后的环境变量, 不能在 Dockerfile 中当参数使用 从这里可以看出来 ARG 就是专门为构建镜像而生的 拿一个具体的例子12345678910111213# DockerfileFROM redis:3.2-alpineLABEL maintainer="GPF &lt;5173180@qq.com&gt;"ARG REDIS_SET_PASSWORD=developerENV REDIS_PASSWORD $&#123;REDIS_SET_PASSWORD&#125;VOLUME /dataEXPOSE 6379CMD ["sh", "-c", "exec redis-server --requirepass \"$REDIS_PASSWORD\""] 这是一个构建 redis 的文件, 中间有这么一句12ARG REDIS_SET_PASSWORD=developerENV REDIS_PASSWORD $&#123;REDIS_SET_PASSWORD&#125; 它是为1CMD ["sh", "-c", "exec redis-server --requirepass \"$REDIS_PASSWORD\""] 这一句服务的, 这句就是在启动 redis 的时候设置密码, 因为当执行 CMD 的时候,说明容器已经构建成功运行了起来,此时 CMD是在容器中执行容器中的命令, 因此 CMD 中的变量是用的环境变量而不是在 Dockerfile 中的变量,因此需要把 ARG 中的值在构建的时候赋值给 ENV 另一个使用 ARG 的例子1234567891011121314151617181920212223FROM nginx:1.13.1-alpineLABEL maintainer="GPF &lt;5173180@qq.com&gt;"#https://yeasy.gitbooks.io/docker_practice/content/image/build.htmlRUN mkdir -p /etc/nginx/cert \ &amp;&amp; mkdir -p /etc/nginx/conf.d \ &amp;&amp; mkdir -p /etc/nginx/sitesCOPY ./nginx.conf /etc/ngixn/nginx.confCOPY ./conf.d/ /etc/nginx/conf.d/COPY ./cert/ /etc/nginx/cert/COPY ./sites /etc/nginx/sites/ARG PHP_UPSTREAM_CONTAINER=php-fpmARG PHP_UPSTREAM_PORT=9000RUN echo "upstream php-upstream &#123; server $&#123;PHP_UPSTREAM_CONTAINER&#125;:$&#123;PHP_UPSTREAM_PORT&#125;; &#125;" &gt; /etc/nginx/conf.d/upstream.confVOLUME ["/var/log/nginx", "/var/www"]WORKDIR /usr/share/nginx/html 这里就只是用了ARG123ARG PHP_UPSTREAM_CONTAINER=php-fpmARG PHP_UPSTREAM_PORT=9000RUN echo "upstream php-upstream &#123; server $&#123;PHP_UPSTREAM_CONTAINER&#125;:$&#123;PHP_UPSTREAM_PORT&#125;; &#125;" &gt; /etc/nginx/conf.d/upstream.conf 这里的变量用的就是 ARG 而不是 ENV了,因为这条命令运行在 Dockerfile 当中的, 像这种临时使用一下的变量没必要存环境变量的值就很适合使用 ARG]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-composer</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git调整 Ssh 登录参数]]></title>
    <url>%2F2018%2F06%2F23%2Fgit-sshcommand%2F</url>
    <content type="text"><![CDATA[指定 ssh 命令使用时的签名文件进入 app的.git/config 文件下12345678910111213141516 Engine:[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true # 添加一行这个就行 sshCommand = ssh -i ~/.ssh/id_rsa_gayhuber[remote "origin"] url = git@github.com:gayhuber/php-fpm.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 Gii 模板]]></title>
    <url>%2F2018%2F05%2F23%2Fyii-gii%2F</url>
    <content type="text"><![CDATA[开发是需要用到 gii,但是 gii 并不是完全符合自己的开发需求,所以需要对他做一点改造 这里先拿 basic 版举例, advance版同理 1.修改配置文件 web.php12345678910111213141516171819202122232425262728// file path: @app/config/web.phpif (YII_ENV_DEV) &#123; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'debug'; $config['modules']['debug'] = [ 'class' =&gt; 'yii\debug\Module', ]; $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'yii\gii\Module', // 这里把原来的 model generator 给覆盖成自己的 'generators' =&gt; [ 'model' =&gt; [ // 自定义的模板生成器 'class' =&gt; 'app\common\gii\model\Generator', //设置我们自己的模板 'templates' =&gt; [ //模板名 =&gt; 模板路径 'default' =&gt; '@app/common/gii/model/default', 'original' =&gt; '@app/common/gii/model/original_tpl', ] ] ], ];&#125; 现在在配置中指定了两种model 生成模板了 2.设置自定义的 Geneartor 和 template现在进@app/vendor/yiisoft/yii2-gii/src/generators/model把这个目录拷贝到 @app/common/gii/这里,位置随意, 只要保证 config 中能找到这个路径就行,现在我们就在 @app/common/gii/model这里操作 因为 Generator 继承的 \yii\gii\Generator, 需要实现两个方法, 一个是 getName() 另一个是 generate(), 我们主要修改的就是 generate(),12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// file path: @app/common/gii/model/Generatornamespace app\common\gii\model;use Yii;use yii\db\ActiveQuery;use yii\db\ActiveRecord;use yii\db\Connection;use yii\db\Schema;use yii\db\TableSchema;use yii\gii\CodeFile;use yii\helpers\Inflector;use yii\base\NotSupportedException;class Generator extends \yii\gii\Generator&#123; /** some code ..... */ /** * &#123;@inheritdoc&#125; */ public function generate() &#123; $files = []; $relations = $this-&gt;generateRelations(); $db = $this-&gt;getDbConnection(); foreach ($this-&gt;getTableNames() as $index =&gt; $tableName) &#123; // model : $modelClassName = $this-&gt;generateClassName($tableName); $queryClassName = ($this-&gt;generateQuery) ? $this-&gt;generateQueryClassName($modelClassName) : false; $tableSchema = $db-&gt;getTableSchema($tableName); $params = [ &apos;tableName&apos; =&gt; $tableName, &apos;className&apos; =&gt; $modelClassName, &apos;queryClassName&apos; =&gt; $queryClassName, &apos;tableSchema&apos; =&gt; $tableSchema, &apos;properties&apos; =&gt; $this-&gt;generateProperties($tableSchema), &apos;labels&apos; =&gt; $this-&gt;generateLabels($tableSchema), // 这是新增的 &apos;constMap&apos; =&gt; $this-&gt;generateConstMap($tableSchema), &apos;rules&apos; =&gt; $this-&gt;generateRules($tableSchema), &apos;relations&apos; =&gt; isset($relations[$tableName]) ? $relations[$tableName] : [], ]; // 同一个库中只生成一个 Model.php 之后的 model 都要继承这个 model if ($index == 0) &#123; $files[] = new CodeFile( Yii::getAlias(&apos;@&apos; . str_replace(&apos;\\&apos;, &apos;/&apos;, $this-&gt;ns)) . &apos;/Model.php&apos;, $this-&gt;render(&apos;cModel.php&apos;, $params) ); &#125; $files[] = new CodeFile( Yii::getAlias(&apos;@&apos; . str_replace(&apos;\\&apos;, &apos;/&apos;, $this-&gt;ns)) . &apos;/&apos; . $modelClassName . &apos;.php&apos;, $this-&gt;render(&apos;model.php&apos;, $params) ); &#125; return $files; &#125; protected function generateConstMap($table)&#123; // some code &#125; /** some code ..... */&#125; 在generate() 这个方法里的 $params 这里就是给模板准备参数, new CodeFile这里就是生成指定的模板 现在我们在模板中搞一下 3.设置 model 模板在@app/common/gii/model目录下有一个default目录,就是默认的 template,咱们在config.php中设置了12345'templates' =&gt; [ //模板名 =&gt; 模板路径 'default' =&gt; '@app/common/gii/model/default', 'original' =&gt; '@app/common/gii/model/original_tpl', ] 这两个, 把 default/ 复制一份叫 original_tpl/ 这在 gii 页面端选模板的时候能看到这写别名,如果是console模式的话只能使用default模板了 1234567891011121314151617181920212223242526272829303132// path: @app/common/gii/default/model.php&lt;?php/** * This is the template for generating the model class of a specified table. *//* @var $this yii\web\View *//* @var $generator yii\gii\generators\model\Generator *//* @var $tableName string full table name *//* @var $className string class name *//* @var $queryClassName string query class name *//* @var $tableSchema yii\db\TableSchema *//* @var $properties array list of properties (property =&gt; [type, name. comment]) *//* @var $labels string[] list of attribute labels (name =&gt; label) *//* @var $rules string[] list of validation rules *//* @var $relations array list of relations (name =&gt; relation declaration) *//* @var $constMap string[] list of attribute labels (name =&gt; label) */echo "&lt;?php\n";?&gt;namespace &lt;?= $generator-&gt;ns ?&gt;;use Yii;/** * This is the model class for table "&lt;?= $generator-&gt;generateTableName($tableName) ?&gt;". *&lt;?php foreach ($properties as $property =&gt; $data): ?&gt;...底下一些乱七八糟的代码.... 这里就看着办吧,就是正常的渲染模板 因为在generate()中还设置了一个1234567// 同一个库中只生成一个 Model.php 之后的 model 都要继承这个 modelif ($index == 0) &#123; $files[] = new CodeFile( Yii::getAlias('@' . str_replace('\\', '/', $this-&gt;ns)) . '/Model.php', $this-&gt;render('cModel.php', $params) );&#125; 新增了一个cModel.php,这个是我自己的业务需求, 同库的 model 全部继承这个 model, 这里只是设置了一下getDb()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/** * This is the template for generating the model class of a specified table. *//* @var $this yii\web\View *//* @var $generator yii\gii\generators\model\Generator *//* @var $tableName string full table name *//* @var $className string class name *//* @var $queryClassName string query class name *//* @var $tableSchema yii\db\TableSchema *//* @var $properties array list of properties (property =&gt; [type, name. comment]) *//* @var $labels string[] list of attribute labels (name =&gt; label) *//* @var $rules string[] list of validation rules *//* @var $relations array list of relations (name =&gt; relation declaration) *//* @var $constMap string[] list of attribute labels (name =&gt; label) */$date = date('Y/m/d H:i');$date = explode(' ', $date);$model = &lt;&lt;&lt;str&lt;?php/** * Created by Gii. * TemplatePath: @app\common\gii\model\default\cModel.php * Date: &#123;$date[0]&#125; * Time: &#123;$date[1]&#125; */namespace &#123;$generator-&gt;ns&#125;;use yii\db\ActiveRecord;use Yii;/** * 同文件夹下都要继承一下这个 model,目前是用来改库的链接地址 * Class Model * @package app\modules\v1\models\passport */class Model extends ActiveRecord&#123; /** * 重写表所对应的数据库链接信息 (如果函数不存在则默认为 db 的配置) * @return \yii\db\Connection */ public static function getDb() &#123; return Yii::\$app-&gt;get('&#123;$generator-&gt;db&#125;'); &#125;&#125;str;echo $model;?&gt; 这样依赖 gii 的模板自定义就算是完事了 4. console 模式下的 gii照例首先需要设置console.php的配置 12345678910111213141516//path @app/console.phpif (YII_ENV_DEV) &#123; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'app\common\gii\Module', 'generators' =&gt; [ 'model' =&gt; [ // 自定义的模板生成器 'class' =&gt; 'app\common\gii\model\Generator', //设置我们自己的模板 console 默认就是 default 模板 'templates' =&gt; [] ] ], ];&#125; generators 和 之前的配置一样,区别就是 module 下的 class 设置成自己的 Module 这里把@app/vendor/yiisoft/yii2-gii/src/Module.php复制一份到@app/common/gii/Module.php 改一下命名空间并且继承\yii\gii\Module 毕竟咱们是定制的, 这个代码不能在 vendor 中改,不然以后你再装新的 composer 包的时候会非常麻烦 12345678910111213141516171819202122232425// path: @app/common/gii/Module.php/**代码块*/ public function bootstrap($app) &#123; if ($app instanceof \yii\web\Application) &#123; $app-&gt;getUrlManager()-&gt;addRules([ ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id, 'route' =&gt; $this-&gt;id . '/default/index'], ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id . '/&lt;id:\w+&gt;', 'route' =&gt; $this-&gt;id . '/default/view'], ['class' =&gt; 'yii\web\UrlRule', 'pattern' =&gt; $this-&gt;id . '/&lt;controller:[\w\-]+&gt;/&lt;action:[\w\-]+&gt;', 'route' =&gt; $this-&gt;id . '/&lt;controller&gt;/&lt;action&gt;'], ], false); &#125; elseif ($app instanceof \yii\console\Application) &#123; $app-&gt;controllerMap[$this-&gt;id] = [ // 这里改成自己定制的 consoleController 'class' =&gt; 'app\common\gii\console\GenerateController', 'generators' =&gt; array_merge($this-&gt;coreGenerators(), $this-&gt;generators), 'module' =&gt; $this, ]; &#125; &#125;/**代码块*/ 只用把 console 的 GenerateController 指向咱们自定义的控制器, 复制目录@app/vendor/yiisoft/yii2-gii/src/console/ 到 @app/common/gii/console/, 这时我们就能对 gii console 模式下的代码进行调整了 可能在@app/common/gii/console/GenerateController.php中的代码让你摸不到头脑, 这里是在 actions()来着注册 router, 具体的 action 实现则是在 class 中指定了 1234567891011121314151617181920// path: @app/common/gii/console/GenerateController.php public function actions() &#123; $actions = []; foreach ($this-&gt;generators as $name =&gt; $generator) &#123; $actions[$name] = [ 'class' =&gt; 'yii\gii\console\GenerateAction', 'generator' =&gt; $generator, ]; // 依赖model generator 重新定义一个 gii 命令 if($name == 'model') &#123; $actions['all'] = [ 'class' =&gt; 'app\common\gii\console\GenerateAllAction', 'generator' =&gt; $generator, ]; &#125; &#125; return $actions; &#125; 因为所有的 Generator 都实现了 getName() 和 generate()这两个方法,action 也是只使用了这两个方法,可以自己翻下代码,这里就不详细讲了]]></content>
      <categories>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>gii</tag>
        <tag>yii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十进制与二进制,八进制,十六进制的换算]]></title>
    <url>%2F2018%2F05%2F23%2Fconversion-calculation%2F</url>
    <content type="text"><![CDATA[复习一下二进制,八进制,十六进制之间的互相转换和怎么用十进制去转换它们 首先做一个定义： B(Binary)表示二进制，O(Octal)表示八进制，D(Decimal)或不加表示十进制，H(Hexadecimal)表示十六进制，比如：(101011)B=(53)O=(43)D=(2B)H 十进制转换成二进制除二取余法二进制说白了就是 0 和 1 啊，在十进制的时候就是2的次方 以十进制的(43)D为例：123456743/2=21%121/2=10%110/2=5 %05 /2=2 %12 /2=1 %01 /2=0 %1以上把余数倒着排就是二进制的结果了，即101011 阶段相减法（适合低次方的速算）每次都减去最大的值，还是拿(42)D举例：42-32-8-2-1=0， 对应以下的表格为： 64 32 16 8 4 2 1 2^6 2^5 2^4 2^3 2^2 2^1 2^0 0 1 0 1 0 1 1 结果就是： 101011 十进制转二进制以 (101011)B 举例：11*2^0 + 1*2^1 + 1*2^3 + 1*2^5 = 43 十进制转八进制和十六进制都是用的除8或16取余法，不做赘述了，有点区别就是16进制的9以后就是abcd…代替的这等式就自己进行一下验算好了: (101011)B=(53)O=(43)D=(2B)H 二进制转八进制、十六进制先复习一个等式: 2^0 * 2^1 * 2^2 = 2^3， 那么二进制转八进制就是将二进制的数三个为一组合并一下：1101|011 =&gt; 53 同理， 二进制转16进制就是按四个为一组合并一下：10010|1011 =&gt; 2b 十六进制和八进制之间转换都是先转换成二进制，然后再转成想要的进制]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>binary</tag>
      </tags>
  </entry>
</search>
