<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[转 Yii2 断线重连问题]]></title>
    <url>%2F2018%2F12%2F19%2Fyii-mysql%2F</url>
    <content type="text"><![CDATA[yii2 + swoole 的模式下因为使用swoole做的常驻内存服务, 那么之前的设计思路会有一点偏差, 不是第一眼能看到的就是 mysql has gone away的问题 目前解决思路就是当sql命令报错mysql has gone away的时候就断开重连再重新执行一次 参考 Yii2实现mysql断线重连 重写一个command类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php namespace common\components; use Yii; /** * 新增加执行sql时断开重连 * 数据库连接断开异常 * errorInfo = [''HY000',2006,'错误信息'] * Class Command * @package common\components */ class Command extends \yii\db\Command &#123; const EVENT_DISCONNECT = 'disconnect'; /** * 处理修改类型sql的断线重连问题 * @return int * @throws \Exception * @throws \yii\db\Exception */ public function execute() &#123; try&#123; return parent::execute(); &#125;catch(\Exception $e)&#123; if($this-&gt;handleException($e)) return parent::execute(); throw $e; &#125; &#125; /** * 处理查询类sql断线重连问题 * @param string $method * @param null $fetchMode * @return mixed * @throws \Exception * @throws \yii\db\Exception */ protected function queryInternal($method, $fetchMode = null) &#123; try&#123; return parent::queryInternal($method, $fetchMode); &#125;catch(\Exception $e)&#123; if($this-&gt;handleException($e)) return parent::queryInternal($method, $fetchMode); throw $e; &#125; &#125; /** * 处理执行sql时捕获的异常信息 * 并且根据异常信息来决定是否需要重新连接数据库 * @param \Exception $e * @return bool true: 需要重新执行sql false: 不需要重新执行sql */ private function handleException(\Exception $e) &#123; //如果不是yii\db\Exception异常抛出该异常或者不是MySQL server has gone away $offset = stripos($e-&gt;getMessage(),'MySQL server has gone away'); if(($e instanceof \yii\db\Exception) == false OR $offset === false) //OR $e-&gt;errorInfo[0] != 'HY000' OR $e-&gt;errorInfo[1] != 2006) return false; $this-&gt;trigger(static::EVENT_DISCONNECT); //将pdo设置从null $this-&gt;pdoStatement = NULL; //$this-&gt;db-&gt;resetPdo(); $this-&gt;db-&gt;close(); return true; &#125; &#125; 在配置文件中关于db的配置给加上指定的class123456789101112&lt;?php return [ 'components' =&gt; [ 'db' =&gt; [ 'class' =&gt; 'yii\db\Connection', 'commandClass' =&gt; 'common\components\Command',// 加上这个 'username' =&gt; 'XXX', 'password' =&gt; 'XXX', 'dsn' =&gt; 'mysql:host=XXX;dbname=XXX;port=3306', ], ], ]; 相关文章:Yii2实现mysql断线重连在mysql中connection设置和wait-timeout的设置查看mysql连接情况，以及连接超时时间设置源码剖析Yii错误 Invalid parameter number: no parameters were boundYii 数据库重连告别General error: 2006 MySQL server has gone away]]></content>
      <categories>
        <category>yii2</category>
      </categories>
      <tags>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go Mysql数据库连接池的使用]]></title>
    <url>%2F2018%2F12%2F17%2Fgo-mysql-pool%2F</url>
    <content type="text"><![CDATA[建立一个mysql连接池将极大的缩短应用的响应时间, 减少频繁的io开销以及gc, 这在golang里面也是很容易就实现的 示例代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// main.gopackage mainimport ( "database/sql" "fmt" _ "github.com/GO-SQL-Driver/MySQL" "net/http" "time")var db *sql.DBfunc init() &#123; db, _ = sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8") // 设置最大连接数 db.SetMaxOpenConns(300) // 设置最大空闲连接数 db.SetMaxIdleConns(100) // 设置每个链接的过期时间 db.SetConnMaxLifetime(time.Second * 5) err := db.Ping() checkErr(err)&#125;func main() &#123; startServer(":9999")&#125;func startServer(port string) &#123; http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; record := doSomething() fmt.Fprintln(w, record) &#125;) fmt.Printf("listening http://localhost%s\n", port) err := http.ListenAndServe(port, nil) checkErr(err)&#125;func doSomething() map[string]string &#123; rows, err := db.Query("SELECT * FROM test LIMIT 1") checkErr(err) defer rows.Close() columns, _ := rows.Columns() scanArgs := make([]interface&#123;&#125;, len(columns)) values := make([]interface&#123;&#125;, len(columns)) for j := range values &#123; scanArgs[j] = &amp;values[j] &#125; record := make(map[string]string) for rows.Next() &#123; //将行数据保存到record字典 err = rows.Scan(scanArgs...) for i, col := range values &#123; if col != nil &#123; record[columns[i]] = string(col.([]byte)) &#125; &#125; &#125; // fmt.Println(record) return record&#125;func doSomething2() map[string]string &#123; dbConn, _ := sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8") defer dbConn.Close() rows, err := dbConn.Query("SELECT * FROM test LIMIT 1") checkErr(err) defer rows.Close() columns, _ := rows.Columns() scanArgs := make([]interface&#123;&#125;, len(columns)) values := make([]interface&#123;&#125;, len(columns)) for j := range values &#123; scanArgs[j] = &amp;values[j] &#125; record := make(map[string]string) for rows.Next() &#123; //将行数据保存到record字典 err = rows.Scan(scanArgs...) for i, col := range values &#123; if col != nil &#123; record[columns[i]] = string(col.([]byte)) &#125; &#125; &#125; // fmt.Println(record) return record&#125;func checkErr(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; 测试代码: 12345678910111213141516171819202122232425262728293031323334353637383940// main_test.gopackage mainimport ( "testing")func TestDoSomething(t *testing.T) &#123; record := doSomething() t.Log(record)&#125;func BenchmarkDoSomething(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; doSomething() &#125;&#125;func BenchmarkDoSomethingParallel(b *testing.B) &#123; b.RunParallel(func(pb *testing.PB) &#123; for pb.Next() &#123; doSomething() &#125; &#125;)&#125;func BenchmarkDoSomethingWithoutPoll(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; doSomething2() &#125;&#125;func BenchmarkDoSomethingWithoutPollParallel(b *testing.B) &#123; b.RunParallel(func(pb *testing.PB) &#123; for pb.Next() &#123; doSomething2() &#125; &#125;)&#125; 测试输出对比:12345678910$ go test --bench=.goos: darwingoarch: amd64BenchmarkDoSomething-4 20000 67898 ns/opBenchmarkDoSomethingParallel-4 50000 29347 ns/opBenchmarkDoSomethingWithoutPoll-4 1000 8400516 ns/opBenchmarkDoSomethingWithoutPollParallel-4 2000 8167164 ns/opPASSok _/Users/gpf/Documents/go/code/mysql_curd/pool 28.857s 关键就是这几个方法:1234567db, _ = sql.Open("mysql", "root:123123@tcp(localhost:33060)/go?charset=utf8")// 设置最大连接数db.SetMaxOpenConns(300)// 设置最大空闲连接数db.SetMaxIdleConns(100)// 设置每个链接的过期时间db.SetConnMaxLifetime(time.Second * 5) 设置超时时间很有必要, 避免出现server端主动关闭的情况 mysql has gone away... 代码来源]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go里的点点点语法]]></title>
    <url>%2F2018%2F12%2F14%2Fgo-dotdotdot%2F</url>
    <content type="text"><![CDATA[golang 代码里面有时会出现 ... 这个操作, 初次看到也是摸不到头脑,其实他是用来做数组的析构用的 举个例子就明白了: 123456789101112131415161718192021package mainimport "fmt"func main() &#123; pm := []string&#123;"a", "b", "c"&#125; test("abc", pm...) // 相当于 test("abc", "a", "b", "c") ap := []string&#123;"f", "g"&#125; rs := append(pm, ap...) // 相当于 append(pm, ap[0], ap[1], 以此类推) fmt.Println("rs:", rs)&#125;func test(name string, pms ...string) &#123; fmt.Println("output name:", name) for k, v := range pms &#123; fmt.Printf("k: %v, v: %v \n", k, v) &#125; return&#125; 输出: 12345output name: abck: 0, v: ak: 1, v: bk: 2, v: crs: [a b c f g] 这里做了两个示例: 在func中的 ... eg: func test(name string, pms ...string)代表着不限参数数量, 而多出的参数都放在了 var pms []string 这个数组当中, 在go中典型的使用例子就是 fmt.Print 这一系列的方法 在传参的时候使用... 是用来表示将数组中每个元素单独传入函数中较长用的就是出现数组合并的时候, 使用append() 方法时:这样写正确 12ap := []string&#123;"f", "g"&#125; rs := append(pm, ap...) // 相当于 append(pm, ap[0], ap[1], 以此类推) 这样写就报错12ap := []string&#123;"f", "g"&#125;rs := append(pm, ap)]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crontab 设置一小时执行一次]]></title>
    <url>%2F2018%2F12%2F11%2Flinux-crontab%2F</url>
    <content type="text"><![CDATA[如果主管给你个任务, 让你每小时执行一次脚本, 是不是就是这样:1* */1 * * * xxxxx.bash 这样就错了呦~ 以上产生的结果是每分钟执行一次, 因为从匹配角度来看每分钟都符合规则, 继而执行命令 因此对于整点定时任务有两种写法: 每整点执行一次:10 */1 * * * xxxxx.bash 每隔60分钟执行一次:1*/60 * * * * xxxxx.bash 注意我的描述啊, 整点和隔60分钟其实是两个东西, 根据具体业务要求去使用它 关于定时器这里有三个示例: 在上午8点到11点的第3和第15分钟执行 13,15 8-11 * * * command 每隔两天的上午8点到11点的第3和第15分钟执行 13,15 8-11 */2 * * command 每个星期一的上午8点到11点的第3和第15分钟执行 13,15 8-11 * * 1 command 详细的crontab操作可以参考这篇博客:crontab–定时器命令]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Channel控制并发数量]]></title>
    <url>%2F2018%2F12%2F04%2Fgo-channel-waitgroup%2F</url>
    <content type="text"><![CDATA[使用 go 关键字有时候需要控制一下并发的数量, 但不至于去修改 runtime.GOMAXPROCS 这个数值, 这里就用到了缓冲channel的特性 demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package poolimport ( "sync")// WaitGroup 一个异步结构体type WaitGroup struct &#123; workChan chan int wg sync.WaitGroup&#125;// NewPool 生成一个工作池, coreNum 限制func NewPool(coreNum int) *WaitGroup &#123; ch := make(chan int, coreNum) return &amp;WaitGroup&#123; workChan: ch, wg: sync.WaitGroup&#123;&#125;, &#125;&#125;// Add 添加func (ap *WaitGroup) Add(num int) &#123; for i := 0; i &lt; num; i++ &#123; ap.workChan &lt;- i ap.wg.Add(1) &#125;&#125;// Done 完结func (ap *WaitGroup) Done() &#123;LOOP: for &#123; select &#123; case &lt;-ap.workChan: break LOOP &#125; &#125; ap.wg.Done()&#125;// Wait 等待func (ap *WaitGroup) Wait() &#123; ap.wg.Wait()&#125; test: 123456789101112131415161718192021222324252627package poolimport ( "fmt" "testing" "time")func TestRun(t *testing.T) &#123; work := NewPool(4) for i := 0; i &lt; 50; i++ &#123; work.Add(1) go testFunc(i, work) &#125; fmt.Println("waiting...") work.Wait() t.Log("done")&#125;func testFunc(i int, wg *WaitGroup) &#123; defer wg.Done() fmt.Println(time.Now().Format("2006-01-02T15:04:05Z07:00"), "output: ", i) time.Sleep(time.Second * 1) fmt.Println(time.Now().Format("2006-01-02T15:04:05Z07:00"), "output: ", i, "done")&#125; 输出: 12345678910111213141516172018-12-04T14:22:27+08:00 output: 32018-12-04T14:22:27+08:00 output: 12018-12-04T14:22:27+08:00 output: 02018-12-04T14:22:27+08:00 output: 22018-12-04T14:22:28+08:00 output: 3 done2018-12-04T14:22:28+08:00 output: 0 done2018-12-04T14:22:28+08:00 output: 1 done2018-12-04T14:22:28+08:00 output: 52018-12-04T14:22:28+08:00 output: 62018-12-04T14:22:28+08:00 output: 2 done2018-12-04T14:22:28+08:00 output: 72018-12-04T14:22:28+08:00 output: 42018-12-04T14:22:29+08:00 output: 4 done2018-12-04T14:22:29+08:00 output: 82018-12-04T14:22:29+08:00 output: 7 done2018-12-04T14:22:29+08:00 output: 6 done..... 这里还是要带上 sync.WaitGroup, 保证最后一次循环时携程不会过早退出]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx转发到go服务当中]]></title>
    <url>%2F2018%2F11%2F25%2Fgo-nginx-docker%2F</url>
    <content type="text"><![CDATA[通过docker-compose编排的容器总是有一些奇怪的问题 问题核心就是go-server和nginx所属不同的容器, 需要外界能访问到go的服务就需要进行转发了 如果是在同一个容器中只需要: 1234567891011121314151617181920212223242526server &#123; listen 80; server_name .a.com; charset utf-8; access_log /home/a.com.access.log; location /(css|js|fonts|img)/ &#123; access_log off; expires 1d; root &quot;/path/to/app_a/static&quot;; try_files $uri @backend; &#125; location / &#123; try_files /_not_exists_ @backend; &#125; location @backend &#123; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:8080; &#125;&#125; beego-nginx部署 那么如果是两个容器当中呢? 基于上面的例子, 我们需要用到upstream, 123456789101112131415161718192021222324252627282930313233upstream go_server_proxy &#123; # 这里的server 需要用到 容器名:端口 的形式 server go_server:9090;&#125;server &#123; listen 80; server_name localhost; root /var/www; index index.html; charset utf-8; access_log /var/log/nginx/def.access.log; location /(css|js|fonts|img)/ &#123; access_log off; expires 1d; root &quot;/var/www/static&quot;; try_files $uri @backend; &#125; location / &#123; try_files /_not_exists_ @backend; &#125; location @backend &#123; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_pass http://go_server_proxy; &#125;&#125; 这样做的原因是容器之间的ip并不固定, 使用容器名做host地址是更简单的选择]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 火焰图分析]]></title>
    <url>%2F2018%2F11%2F01%2Fgo-flame-graph%2F</url>
    <content type="text"><![CDATA[go version go1.11.1 darwin/amd64 安装:123$ go get github.com/uber/go-torch$ cd $GOPATH/src/github.com/uber/go-torch$ git clone https://github.com/brendangregg/FlameGraph.git 安装测试工具123$ go get github.com/Masterminds/glide$ cd $GOPATH/src/github.com/uber/go-torch$ glide install 性能分析工具 glide install如果出现 Update failed for golang.org/x/sys: Cannot detect VCS 这种报错, 可以执行1$ glide mirror set https://golang.org/x/sys https://github.com/golang/sys 改变 $HOME/.gilde/mirrors.yaml 的镜像链接即可 运行时完成后输入 web12345678910$ go tool pprof --seconds 25 http://localhost:9090/debug/pprof/profileFetching profile over HTTP from http://localhost:9090/debug/pprof/profile?seconds=25Please wait... (25s)Saved profile in /Users/gpf/pprof/pprof.samples.cpu.002.pb.gzType: cpuTime: Nov 2, 2018 at 11:46am (CST)Duration: 25s, Total samples = 2.17s ( 8.68%)Entering interactive mode (type "help" for commands, "o" for options)(pprof) webFailed to execute dot. Is Graphviz installed? Error: exec: "dot": executable file not found in $PATH 出现 Failed to execute dot. Is Graphviz installed? Error: exec: &quot;dot&quot;: executable file not found in $PATH 报错, 需要安装 graphviz 在 mac 上就直接 brew install graphviz 即可]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>flame-graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-Diff]]></title>
    <url>%2F2018%2F10%2F26%2Fgit-diff%2F</url>
    <content type="text"><![CDATA[git 对比文件差异 通常 git diff COMMIT_ID_1 COMMIT_DI_2 查看 只查看更改过的文件目录 git diff --name-only COMMIT_ID_1 COMMIT_DI_2 快捷用法就是: git diff --name-only HEAD HEAD^ 对比和上次提交时的改动]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次 Git Revert 的经历]]></title>
    <url>%2F2018%2F10%2F25%2Fgit-revert%2F</url>
    <content type="text"><![CDATA[合作开发经常会提merge request嘛, 然后就提了一个不该提的, 还手抖给合并了…. 返现问题以后准备回退, 然后抬眼一看各分支的合并情况…. 哇脑壳痛, 这就用不了平时最喜欢的 reset 了, 查了查资料, 想取消某一次 merge request用 revert 是最合适的 接下来分三步,先找到要回退的那次 mr, 通常是这样的: 12345678910111213141516171819202122git log commit 365ea982c24f2c60150df6159734ab73b74515bc (origin/master, origin/HEAD)Merge: 465fbfb8 f15b39aeAuthor: xxx &lt;xxx&gt;Date: Thu Oct 25 15:41:10 2018 +0800 Merge branch 'master' of xxxxxxxxxxxxxxxcommit 465fbfb8084089f9d08516b4d75ba51ae5dcd5ceAuthor: xxx &lt;xxx&gt;Date: Thu Oct 25 15:41:03 2018 +0800 mergecommit 1e309ff40fd02d1c9c6e604c2649d8a94086a573Author: xxx &lt;zhangkaixuan&gt;Date: Thu Oct 25 15:40:37 2018 +0800 merge... 这样的, 这只是 log 的中间的一部分, 假设 mr 之后后续又有很多 mr 已经合并了, 那么先找到我们要回退的 commit id, 这里就假设一个叫 c76627674dedf4fc067cb0c5b2afbc123fd9c053 执行 git revert -m 1 c76627674dedf4fc067cb0c5b2afbc123fd9c053 通常执行这一步之后没什么冲突就可以了, 然后有冲突了, 就和正常的 merger conflicts 处理一样 解决完冲突, 执行 git revert --continue 这就算合并了 那么回滚到一半不想做了, 也好说, 执行 git revert --abort 以后, 大家就当无事发生过 关于 git revert -m 1 这个1指的是 mainline, 1 代表着 master 这条线资料参考: Why does git revert complain about a missing -m option?]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 Vscode 设置终端字体]]></title>
    <url>%2F2018%2F10%2F16%2Fvscode-terminal-font-macOS%2F</url>
    <content type="text"><![CDATA[mac 上设置vscode终端样式(尤其是想用 powershell 主题的) Mac下配置vscode终端字体：在Mac 10.13.6下的解决方案（亲测可用），其他版本做参考。 123下载安装字体$cd /Library/Fonts$sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git config.json 位置123Windows %APPDATA%\Code\User\settings.jsonMac $HOME/Library/Application Support/Code/User/settings.jsonLinux $HOME/.config/Code/User/settings.json 在 vscode 配置中设置字体：123cd $HOME/Library/Application Support/Code/User/settings.json# 文件内指定字体主题"terminal.integrated.fontFamily": "Menlo for Powerline" 在Ubuntu 18.04.1LTS 下的解决方案（亲测可用），其他版本linux做参考。12345下载安装字体$cd /usr/share/fonts/truetype/$sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git刷新字体$sudo fc-cache -f -v 回到 Vs Code的用户设置.json 中加入以下代码1"terminal.integrated.fontFamily": "Menlo for Powerline", 文章来源]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
</search>
