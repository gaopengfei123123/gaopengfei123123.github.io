<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang 处理 Map[interface{}]interface{} 数据]]></title>
    <url>%2F2018%2F09%2F28%2Fgo-complex-interface%2F</url>
    <content type="text"><![CDATA[go 调用 rpc , 掉用其他的服务时会出现一些神奇的数据结构, 今天我们来实验一个 上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( "encoding/json" "log")// 这里是针对出现 map[interface&#123;&#125;]interface&#123;&#125; 类型数据进行的一次转化处理示例type respBody map[interface&#123;&#125;]interface&#123;&#125;func main() &#123; // 模拟一个从 hprose-php-server 传过来的数据 res := map[interface&#123;&#125;]interface&#123;&#125;&#123; "errorCode": 200, "errorMsg": "登录成功", "responseData": map[interface&#123;&#125;]interface&#123;&#125;&#123; "hx_password": "c427ee88c8abeeee4fcddbfbf8767025", "like_post": 0, "avatar": "http://img2.xxx.com/user/3_100_100.png", "beauty_list": []int&#123;1, 2, 3&#125;, "role": []string&#123;"admin", "emplyee", "boss"&#125;, "mission_status": map[interface&#123;&#125;]interface&#123;&#125;&#123; "ok": 233, &#125;, &#125;, &#125; tmp := respHandler(res) log.Println("tmp:", tmp) by, err := json.Marshal(tmp) log.Println("output json:", string(by), err)&#125;func respHandler(res interface&#123;&#125;) (tmp map[string]interface&#123;&#125;) &#123; // map 需要初始化一个出来 tmp = make(map[string]interface&#123;&#125;) log.Println("input res is : ", res) switch res.(type) &#123; case nil: return tmp case map[string]interface&#123;&#125;: return res.(map[string]interface&#123;&#125;) case map[interface&#123;&#125;]interface&#123;&#125;: log.Println("map[interface&#123;&#125;]interface&#123;&#125; res:", res) for k, v := range res.(map[interface&#123;&#125;]interface&#123;&#125;) &#123; log.Println("loop:", k, v) switch k.(type) &#123; case string: switch v.(type) &#123; case map[interface&#123;&#125;]interface&#123;&#125;: log.Println("map[interface&#123;&#125;]interface&#123;&#125; v:", v) tmp[k.(string)] = respHandler(v) continue default: log.Printf("default v: %v %v \n", k, v) tmp[k.(string)] = v &#125; default: continue &#125; &#125; return tmp default: // 暂时没遇到更复杂的数据 log.Println("unknow data:", res) &#125; return tmp&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>switch</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 开发时的一些初级问题]]></title>
    <url>%2F2018%2F09%2F25%2Fgo-primary-mistakes%2F</url>
    <content type="text"><![CDATA[平时碰到的一些小问题, 记一下 assignment to entry in nil map, map 赋值问题1234567891011121314151617181920212223242526272829303132333435363738394041424344// ServiceMap 可用服务列表type ServiceMap struct &#123; handlers map[string]BaseClient RWLock sync.RWMutex BaseService&#125;var ServiceMp *ServiceMapfunc init() &#123; // #1 ServiceMp = &amp;ServiceMap&#123;&#125; // #2.1 ServiceMp.handlers = make(map[string]BaseClient) ServiceMp.AddMethod("XyToken", BaseClient&#123; Module: "System", Class: "XyToken", Func: "getXyOpenKey", &#125;) log.Println("get method:", ServiceMp.handlers)&#125;// AddMethod 添加方法func (serv *ServiceMap) AddMethod(key string, body BaseClient) (err error) &#123; defer func() &#123; if err := recover(); err != nil &#123; log.Println("AddMethod error:", err) &#125; &#125;() if _, ok := serv.handlers[key]; !ok &#123; serv.RWLock.Lock() // #2.2 serv.handlers[key] = body serv.RWLock.Unlock() &#125; return nil&#125; #1 当文件里有一个全局的变量时, 需要先初始化 ServiceMp = &amp;ServiceMap{} 一个实体出来 #2 在 ServiceMap.handlers这个值添加方法的时候, 不能直接 serv.handlers[key] = body, 而是要先给它赋值一个空的切片,才能往里面加东西, 参考 #2.1 和 #2.2 interface conversion: interface {} is float64, not int通常json 转成 map[string]interface{} 时,数字类型就是float64的, 比如:想把它转成int类型使用就要auth.Sys = int(sys.(float64))这样(sys 就是一个 interface{} 类型的数字), 而不是auth.Sys = sys.(int), 后一种写法会有 painc 错误 xxx.(type) 只能用在 switch 当中, 不想这么写就用 reflect.Typeof(xxx)]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 的测试文件]]></title>
    <url>%2F2018%2F09%2F20%2Fgo-test%2F</url>
    <content type="text"><![CDATA[一些函数没有连续的会话状态是可以写出来顺便就写一个测试脚本了比如: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// redis.gopackage toolsimport ( "github.com/gomodule/redigo/redis" "time" "user-server/config")var ( redisClient *redis.Pool REDIS_HOST string REDIS_DB int REDIS_AUTH string MAX_ACTIVE int MAX_IDLE int IDLE_TIMEOUT int64)func init() &#123; REDIS_HOST = config.Conf.Redis.Host REDIS_DB = 0 REDIS_AUTH = "abc" MAX_ACTIVE = 10 MAX_IDLE = 1 /** *@MaxIdle 最大空闲链接 *@MaxActive 最大活跃链接 *@IdleTimeout 自动超时时间 */ redisClient = &amp;redis.Pool&#123; MaxIdle: MAX_IDLE, MaxActive: MAX_ACTIVE, IdleTimeout: 30 * time.Second, Dial: func() (redis.Conn, error) &#123; c, err := redis.Dial("tcp", REDIS_HOST) if err != nil &#123; return nil, err &#125; if REDIS_AUTH != "" &#123; c.Do("AUTH", REDIS_AUTH) &#125; c.Do("SELECT", REDIS_DB) return c, nil &#125;, &#125;&#125;func GetRedis() redis.Conn &#123; return redisClient.Get()&#125; 对应的测试文件 在同目录创建一个 redis_test.go 123456789101112package toolsimport ( "testing")func TestGetRedis(t *testing.T) &#123; co := GetRedis() defer co.Close() co.Do("SET", "test_redis_key", "test_redis_value")&#125; 测试脚本的标准格式是: 文件名为 xxx_test.go 作为测试文件标记 引入 testing 包 要测试的函数名为 TestXXXX(t *testing.T) 输出结果通过 t.Logf() t.Error() 这类的测试包提供的函数来调用 写完代码, 在目录下运行:123456# 运行当前目录所有测试文件并输出结果go test -v# 运行指定测试文件, 需要把被测试文件也带上go test -v redis.go redis_test.go# 运行指定的测试方法go test -v --test.run TestGetRedis]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go Interface 的机制]]></title>
    <url>%2F2018%2F09%2F12%2Fgo-interface-tip%2F</url>
    <content type="text"><![CDATA[对 interface 赋值变量的时候经常出的问题 日常开发时有个这样的例子: 123456789101112131415161718192021222324package mainimport "fmt"type Human interface &#123; Run()&#125;type Boy struct &#123; Name string&#125;func (b *Boy) Run() &#123; fmt.Println("my name is " + b.Name)&#125;func main() &#123; xiaoming := Boy&#123;Name: "xiao ming"&#125; var h Human // h = xiaoming // #1 会报错, Boy does not implement Human (Run method has pointer receiver) h = &amp;xiaoming h.Run()&#125; 如果用 #1 这行代码时会出现以下错误:123# command-line-arguments./main.go:23:4: cannot use xiaoming (type Boy) as type Human in assignment: Boy does not implement Human (Run method has pointer receiver) 然而用下面的 h = &amp;xiaoming 是正常的 这个问题，首先得先了解一下Golang 中 方法的集合的概念，一个struct虽然可以通过值类型和引用类型两种方式定义方法，但是不通的对象类型对应了不同的方法集： 1234Values Methods Receivers----------------------------------------------- T (t T)*T (t T) and (t *T) 值类型的对象只有（t T) 结构的方法，虽然值类型的对象也可以调用(t *T) 方法，但这实际上是Golang编译器自动转化成了&amp;t的形式来调用方法，并不是表明值类型的对象拥有该方法。 换一个维度来看上面的表格可能更加直观： 12345Methods Receivers Values-----------------------------------------------(t T) T and *T(t *T) *T 这就意味着指针类型的receiver 方法实现接口时，只有指针类型的对象实现了该接口。 对应上面的例子来说，只有&amp;user实现了notifier接口，而user根本没有实现该接口。所以上面代码会报出这样的异常。]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[身为 Phper 为什么我选择 Go 语言?]]></title>
    <url>%2F2018%2F09%2F12%2Fgo-why%2F</url>
    <content type="text"><![CDATA[想换个语言开发的同学可以看这里 概况go 相比 php 有哪些优势? go 的部署简单, 运行时只要把一个二进制文件扔到机器上就行, 这一点在容器化方面优势很大 可控的多线程和更简单的多线程间通信 编译型语言对动态语言天生的性能优势, 变量在开发过程中不会突然从 str 变成 array 微服务相关的项目多 自 go 1.5 以后, 底层完全采用的 go 自己的代码重构 go 本身的优势 开发效率和运行的效率都在可接受范围 成熟的官方库和活跃的社区, 还有官方出品的工具链 语法简单(25个关键字), 对于初学者来说不用受配置环境的苦 良好兼容 c 语言 语言层面支持并发 运行时对外部的依赖极少 go 较于 php 的劣势 编译造成的繁琐操作 代码量偏多 至今没有一个成熟的依赖库管理工具, 缺乏版本管理 字典类型要考虑并发读写安全的问题, 需要有锁的概念, 这一点 swoole 也有类似的情况 go 的特色defer 延迟处理12345678910111213141516func OpenFile() bool&#123; file.Open("file/path") if condition1 &#123; file.Close() return false &#125; if condition2 &#123; file.Close() return false &#125; file.Close() return true&#125; 对比一下12345678910111213func OpenFile() bool&#123; file.Open("file/path") defer file.Close() if condition1 &#123; return false &#125; if condition2 &#123; return false &#125; return true&#125; 123456789101112...func main () &#123; for i :=0;i &lt; 5 ; i++&#123; defer fmt.Println("输出：",i) &#125;&#125;...// 输出： 4// 输出： 3// 输出： 2// 输出： 1// 输出： 0 多返回值1234567func multipartReturn(a int, b int) (res int, err error) &#123; res = a + b if res &gt; 3 &#123; return res, nil &#125; return 0, errors.New("math: square root of negative number")&#125; goroutinue 并发12345678910111213141516func main() &#123; go loop(true) loop(false)&#125;func loop(desc bool) &#123; if desc &#123; for i := 10; i &gt; 0; i-- &#123; fmt.Printf("loop1: %d \n", i) &#125; &#125; else &#123; for j := 0; j &lt; 10; j++ &#123; fmt.Printf("loop2: %d \n", j) &#125; &#125;&#125; channel 多线程通信12345678910111213141516171819202122232425func main() &#123; // 创建一个缓冲 ch := make(chan string, 3) go loopPro(true, ch) go loopPro(false, ch) for i := 0; i &lt; 20; i++ &#123; fmt.Print(&lt;-ch) &#125;&#125;// 加入 channel 的概念func loopPro(desc bool, ch chan&lt;- string) &#123; if desc &#123; for i := 10; i &gt; 0; i-- &#123; time.Sleep(time.Second) ch &lt;- fmt.Sprintf("loop1: %d \n", i) &#125; &#125; else &#123; for j := 0; j &lt; 10; j++ &#123; time.Sleep(time.Second) ch &lt;- fmt.Sprintf("loop2: %d \n", j) &#125; &#125;&#125; 跨平台http-server的 demo1234567891011121314151617181920212223242526package mainimport ( "fmt" "net/http")func main() &#123; fmt.Println("route: http://localhost:9090/") fmt.Println("route: http://localhost:9090/hello") mux := http.NewServeMux() mux.HandleFunc("/hello", helloHandler) mux.HandleFunc("/", pageHandler) http.ListenAndServe(":9090", mux)&#125;func helloHandler(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte("hello world"))&#125;func pageHandler(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte("hi baby"))&#125; 可根编译成指定平台的执行文件12CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.goCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go 调用 c 代码1234567891011121314151617package main/* 下面是 C 代码 */// int add(int a, int b) &#123;// return a + b;// &#125;import "C"import "fmt"func main() &#123; a := C.int(1) b := C.int(2) value := C.add(a, b) fmt.Printf("%v\n", value)&#125; 代码来源 大体了解一下语法安装官网安装包地址: https://golang.org/dl/以 centos 为例1234$ wget https://dl.google.com/go/go1.11.linux-amd64.tar.gz$ tar -C /usr/local -zxvf go1.11.linux-amd64.tar.gz$ export PATH=$PATH:/usr/local/go/bin/$ go GOROOT 不用管它…GOPATH 目录结构123bin/ # 生成的执行文件 pkg/ # 编译时用到的外部库执行文件src/ # 我们开发的各种库和 go get 到的各种库源码 Hello world123456789package mainimport ( "fmt")func main() &#123; fmt.Println("hello world")&#125; 运行 go run main.go 资源类型常用: int/int8/int16/int32/int64 uint/uint8/uint16/uint32/uint64 float32/float64 string array slice(切片) map(字典) point(指针) 面向对象: struct interface 特色: chan 变量赋值123456789101112131415161718192021222324var a inta = 1// 或a := 1// 数组var arr [10]int// 切片var slice1 []int = make([]int, 3)var slice1 := make([]int, 3, 10) // 预留了10字节内存slice1 = []int&#123;1, 2, 3&#125;slice2 := slice1[2:] // [3]var any interface&#123;&#125; // 空接口接一切any = slice2 // [3]// 字典var mp map[string]stringmp["a"] = "诶"mp["b"] = "必"// 同上 mp := map[string]string&#123;"a": "aaa", "b": "bbb"&#125;// 这样写得清楚这是干什么的var mp map[string]interface&#123;&#125; 逻辑处理1234567891011121314151617for i := 0;i &lt; 5 ; i++ &#123; fmt.Println("输出：",i)&#125;if i &gt; 1 &#123; ....&#125;// 隐式执行 breakswitch os := runtime.GOOS; os &#123; case "darwin": fmt.Println("OS X.") case "linux": fmt.Println("Linux.") default: fmt.Printf("%s.", os)&#125; 面向对象struct12345678910111213141516171819202122232425262728293031package mainimport ( "fmt")type human struct &#123; Name string Age int&#125;// 隐式的继承 human 的属性type ming struct &#123; human Skill string&#125;// 添加结构体所属的方法func (h human) Say() &#123; fmt.Printf("我叫%s,今年%d", h.Name, h.Age)&#125;func main() &#123; var xm ming xm.Name = "小明" xm.Age = 18 xm.Skill = "跑得快" fmt.Println(xm) xm.Say()&#125; interface 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。 – 鸭子类型 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( "fmt")type Animal interface &#123; Speak() string&#125;type Dog struct &#123;&#125;func (d Dog) Speak() string &#123; return "Woof!"&#125;type Cat struct &#123;&#125;func (c Cat) Speak() string &#123; return "Meow!"&#125;type PHPProgrammer struct &#123;&#125;func (p PHPProgrammer) Speak() string &#123; return "PHP is the best language! "&#125;type PassBy struct &#123;&#125;func main() &#123; animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;, PHPProgrammer&#123;&#125;&#125; // animals[3] = PassBy&#123;&#125; // 编译不会通过, 因为没有实现 Animal 接口 for _, animal := range animals &#123; fmt.Println(animal.Speak()) &#125;&#125; demo 代码地址]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php开发过程中不常碰到的error (8.14更新)]]></title>
    <url>%2F2018%2F08%2F26%2Fphp-unsual-mistakes%2F</url>
    <content type="text"><![CDATA[这里做一些备注,以防再次碰到 url 当中的参数有 &amp;timestamp=1234567890这样的字段会被转义成xtamp=1234567890这个不仅存在于页面解析当中,当使用 curl 请求时拼接的参数有这种格式的也会发生转义解决方法有两个: 把 timestamp 这个参数放在 urlQuery 的最前面, ?timestamp=1234567890 这样避免出现 &amp;time发生转义的情况 将&amp;用&amp;amp;来代替 Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.出现这句话通常说明你在用的 php 版本是5.6.而且在php&lt;=5.6的时候,进行 application/json格式的 post 提交会把数据放在$HTTP_RAW_POST_DATA这个系统变量里面,在php&gt;=7的时候这个变量被移除了,统统归总到php://input这里解决方法: 根据系统提示的走: Although that indeed would be technically impossible (as $HTTP_RAW_POST_DATA is populated in the bootstrapping phase of the PHP process) allow one to override the setting by means of calling ini_set. 要确保自己的系统中没有使用 HTTP_RAW_POST_DATA这个变量,直接在php.ini里面禁掉它的设置,但是容易出现系统中又打开的情况(在框架中很常见) 改一下自己的提交方式, 使用 application/form-data或者application/x-www-form-urlencoded这种格式的提交, 然后在后端接收数据的时候再转成自己需要的格式(通常是数组) 参考资料 Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’这种情况出现在平时运行的好好的, 但是突然换 cli 模式后这个配置就出问题了,原因在当 host=localhost时走的是 unix:socket 链接, 当host=127.0.0.1走的是 tcp 链接,这在php-fpm和php-cli中有点区别,尤其是本地没有安装 mysql 的时候解决方法有三种: 将本地链接配置统一成 127.0.0.1 查看 MySQL 中的user表, host=localhost和host=127.0.0.1是不是用的同一个账号密码 配置php.ini文件中的pdo_mysql.default_socket= 写上完整的 socket 路径以上三种方法都可以试一下参考资料 常驻内存时发生的事情这个是 phper 很少碰到但是很常见的情况, 比如用 swoole 启动了一个常驻进程的服务, 那么就一定要小心使用静态变量,在同步模式下会发生变量污染, 还有就是 redis,mysql 这类的链接,你会发现长时间静置以后就会出现一些摸不着头脑的问题, 这种情况不妨想一下是不是 server 端回收了这个 socket,因此在 client 端怎么都写入不进去. 还有就是 php 在读取消息的时候,出现消息过长的情况,那么就要考虑EOF终止符的问题了… 单次 http 每一次请求都是全新的代码, 不用自己考虑 gc 的问题, 但是在常驻内存的时候,这些就是一个个的大坑了 mysql has gone away产生这个错误的主要原因是 mysql server 端断开了链接, client 端还拿着这个句柄去请求,解决方式有两种: show global variables like &#39;%timeout&#39;; 查看 wait_timeout 的时长,适当的调长一点, 这种方法治标不治本,而且有隐患 12mysql&gt; set global wait_timeout=10;mysql&gt; show global variables like 'wait_timeout'; 使用 mysql 之前需要 mysql_ping() 一下, 如果出现断开的错误就启动重连机制 js 和 php 交互传中文参数的编解码问题之前碰到了问题是:在 php 端 urlencode 的值为:1orderid%3D21111111110001954%26pid%3D257742%26reason%3D%E4%B8%AA%E4%BA%BA%E6%96%B9%E9%9D%A2%E5%8E%9F%E5%9B%A0_%E4%BD%BF%E7%94%A8%E7%BA%A2%E5%8C%85%E9%87%8D%E6%96%B0%E4%B8%8B%E5%8D%95%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f 需要 urldecode 一次 而在 js 端的结果是:1orderid%3D21111111110002170%26pid%3D257742%26reason%3D%25E4%25B8%25AA%25E4%25BA%25BA%25E6%2596%25B9%25E9%259D%25A2%25E5%258E%259F%25E5%259B%25A0_%25E4%25B8%25AA%25E4%25BA%25BA%25E8%25BA%25AB%25E4%25BD%2593%25E5%258E%259F%25E5%259B%25A0%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f 需要 urldecode 两次 查阅资料后:12345678910111213在后端是PHP程序的情况下，保持前端Javascript和PHP之间传值的统一编码可以使用以下函数进行处理： WEB前端JavaScript 编码：escape(encodeURI(string)) 解码：unescape(decodeURI(string)) WEB后端Php 编码：urlencode(string) 解码：urldecode(urldecode(string)) 为什么要encodeURI(url)两次才不会出现乱码？ PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent 的区别rawurlencode遵守是94年国际标准备忘录RFC 1738 urlencode实现的是传统做法，和上者的主要区别是对空格的转义是’+’而不是’%20’javascript的encodeURL也是94年标准，而javascript的escape是另一种用”%xxx”标记unicode编码的方法。推荐在PHP中使用用rawurlencode。弃用urlencode 样例source:超级无敌的人sadha sajdh数据样本sdls fhejrthcxzb.file.jpeg PHP urlencode:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha+sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls+fhejrthcxzb.file.jpeg PHP rawurlencode:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg Javascript encodeURI|encodeURIComponent:%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg Javascript escape:%u8D85%u7EA7%u65E0%u654C%u7684%u4EBAsadha%20sajdh%u6570%u636E%u6837%u672Csdls%20fhejrthcxzb.file.jpeg 帖子原文 在前端还有个问题就是, js 的 encodeURIComponent 和 encodeURI 都不会转换 _-.!~*&#39;()# 这些保留字符, 而在后端的rawurlencode 则是会转换的, 因此需要前端单独把这几个给拎出来, 如下:12"*".charCodeAt(0) // 42String.fromCharCode(42) // * 这里有张图说的很明白图片来源 关于出现 &lt;U+200B&gt; 这种 zero-width space 字符如果出现 mb_substr 这类操作的时候, 会出现字数判断错误的问题, 这个有时候很难排查, 因为在 win 上,使用命令行或者 linux 上用cat命令是看不到字符间是有 &lt;U+200B&gt; 的, 如下: 这玩意儿出现的场景就是: 在前端输入框中输入几个字, 然后复制粘贴. 这样尽管看起来之间没有空格, 但是其中还是插入了这个字符这玩意就叫 zero-width space 零宽空格, 处理的办法也很简单, 前端传值之前给过滤一下, 比如 https://stackoverflow.com/questions/7055600/u200b-zero-width-space-characters-in-my-js-code-where-did-they-come-from 或 https://codeday.me/bug/20171122/97765.html 后端 php 处理的话和这个不一样, 使用 utf-8 的处理方式, 可以参考这篇文章 特殊字符的删除办法与原理 替换这种编码123$value = str_replace("\xe2\x80\x8b", '', $value);$value = str_replace("\xe2\x80\x8c", '', $value);$value = str_replace("\xe2\x80\x8d", '', $value); 编码对照如下: mac 设置crontab -e ： “/usr/bin/vi” exited with status 1输入以下命令1234export EDITOR=vimsudo touch /etc/crontabcrontab -ecrontab -l 把默认编辑器从 vi 改成 vim 原文]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 Docker-Compose 搭建一个 Elk]]></title>
    <url>%2F2018%2F08%2F20%2Fdocker-elk%2F</url>
    <content type="text"><![CDATA[找了不少使用 docker-elk 搭建的博客, 英文的阅读吃力不说, 镜像源也是慢的让人头皮发麻, 因此重新编排了一个docker-compose,源都是从 https://hub.docker.com/ 上找的, 即使拉的国内镜像源应该也能很好的支持了吧? 环境 Docker 18.06.0-ce docker-compose 1.22.0给每个容器最少分配 1G 的内存 软件版本 logstash: 5.* elasticsearch: 5.* kibana: 5.* 启动前的配置在各个目录下都有对应的 config 配置, 根据各自的情况自行处理 拿默认的 logstash/confg/test.conf 中的配置举例:1234567891011121314151617181920212223242526272829303132input &#123; file &#123; #这里的路径指的是 logstash 容器中的路径, 外部接入需要使用 volume 进行目录映射 path =&gt; "/logs/input/*" &#125; # 在 logstash 容器中的输入 stdin &#123;&#125; # 因为做了本地5000端口和容器5000端口进行绑定, 所以可以用 nc 工具测试一下 # echo "Test Logstash TCP Input Plugin" | nc localhost 5000 tcp &#123; type =&gt; "tcp" port =&gt; 5000 mode =&gt; "server" &#125;&#125;output &#123; file &#123; #这里的路径指的是 logstash 容器中的路径, 外部接入需要使用 volume 进行目录映射 path =&gt; "/logs/output/%&#123;+yyyy-MM-dd-HH&#125;/%&#123;host&#125;.log" &#125; stdout &#123; codec =&gt; rubydebug &#125; elasticsearch &#123; hosts =&gt; "elasticsearch:9200" # 这里设置的 index 在 kibana 中会用到 index =&gt; "file-log-%&#123;+YYYY.MM&#125;" &#125;&#125; 启动容器执行12git clone https://github.com/gaopengfei123123/docker-elk.git &amp;&amp; cd docker-elkdocker-compose up -d --build 等一会看到执行成功的提示123Creating docker-elk_elasticsearch_1 ... doneCreating docker-elk_logstash_1 ... doneCreating docker-elk_kibana_1 ... done 在本地浏览器输入 http://localhost:5601/ 进入 kibana 界面 注意, 第一次启动时有可能会出现提示 elasticsearch not found 这类的问题, 可以先等个一两分钟刷新一下就好了, 如果还是不行就谷歌或者提 issue 解决一下 同目录下输入1docker-compose stop 则停止所有服务 测试一下在 logs/input/ 目录下新增个 test.log 文件, 然后输入点东西验证一下, 或者命令行执行echo &quot;Test Logstash TCP Input Plugin&quot; | nc localhost 5000 通过 tcp 发送日志 1docker-compose logs -f 查看各容器日志输出 TODO 引入 kafka 做缓冲 搭建 es 集群 github 地址]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞定 Git 合并冲突]]></title>
    <url>%2F2018%2F08%2F03%2Fgit-merge-conflict%2F</url>
    <content type="text"><![CDATA[这次说一下通过命令行去批量解决文件冲突的问题, 这个方法适用你清楚的知道自己需要保留哪一个分支, 而不是两个分支里的改动都要一点 关键命令checkout 是个好方法, 能粗暴的解决很多问题 针对冲突文件保留自己的分支1git checkout --ours path/to/conflict_file 想保留别人的分支1git checkout --theirs path/to/conflict_file 批量的解决: 1grep -lr '&lt;&lt;&lt;&lt;&lt;&lt;&lt;' . | xargs git checkout --ours 一个鲜活的例子…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566➜ test mkdir merge-demo➜ test cd merge-demo➜ merge-demo ls➜ merge-demo echo 'first commit' &gt; index.txt➜ merge-demo cat index.txtfirst commit➜ merge-demo git initInitialized empty Git repository in /Users/gpf/Documents/test/merge-demo/.git/➜ merge-demo git:(master) ✗ git add -A➜ merge-demo git:(master) ✗ git commit -m 'init'[master (root-commit) e9f17b3] init 1 file changed, 1 insertion(+) create mode 100644 index.txt➜ merge-demo git:(master) git checkout -b testSwitched to a new branch 'test'➜ merge-demo git:(test) echo 'second commit by test' &gt; index.txt➜ merge-demo git:(test) ✗ git add -A &amp;&amp; git commit -m 'second commit'[test 4d20ff3] second commit 1 file changed, 1 insertion(+), 1 deletion(-)➜ merge-demo git:(test) cat index.txtsecond commit by test➜ merge-demo git:(test) git checkout masterSwitched to branch 'master'➜ merge-demo git:(master) echo 'third commit by master' &gt; index.txt➜ merge-demo git:(master) ✗ git add -A &amp;&amp; git commit -m 'third commit'[master 85e520e] third commit 1 file changed, 1 insertion(+), 1 deletion(-)➜ merge-demo git:(master) git merge testAuto-merging index.txtCONFLICT (content): Merge conflict in index.txtAutomatic merge failed; fix conflicts and then commit the result.➜ merge-demo git:(master) ✗ git statusOn branch masterYou have unmerged paths. (fix conflicts and run "git commit") (use "git merge --abort" to abort the merge)Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) both modified: index.txtno changes added to commit (use "git add" and/or "git commit -a")➜ merge-demo git:(master) ✗ cat index.txt&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADthird commit by master=======second commit by test&gt;&gt;&gt;&gt;&gt;&gt;&gt; test➜ merge-demo git:(master) ✗ git checkout --ours index.txt➜ merge-demo git:(master) ✗ cat index.txtthird commit by master➜ merge-demo git:(master) ✗ git statusOn branch masterYou have unmerged paths. (fix conflicts and run "git commit") (use "git merge --abort" to abort the merge)Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) both modified: index.txtno changes added to commit (use "git add" and/or "git commit -a")➜ merge-demo git:(master) ✗ git add -A &amp;&amp; git commit -m 'done'[master d2d2057] done]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>merge-conflict</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不正宗 Docker 入门教程-使用 Docker-Compose (3/3)]]></title>
    <url>%2F2018%2F07%2F20%2Fdocker-step-3%2F</url>
    <content type="text"><![CDATA[本章通过一个具体的demo来了解 docker-compose docker-compose 是做什么的在构建一个完整的服务时，我们通常启动一个容器， 一旦出现多个容器需要同时启动的时候手打是下下之策， 因为时间一长难免会忘记细节，写脚本也不是不可以，但是大家没有达成共识时脚本也很难维护… docker-compose 就是来解决这个痛点， 只需要按照统一的格式书写，那么大家生成的容器也都是一致的， 在团队开发的时候扔一个配置好的 docker-compose 能节省很多时间和口水 配置 docker-compose这是我构建的一个开发环境的容器:dnmp 首先下载下来1git clone https://github.com/gaopengfei123123/dnmp.git &amp;&amp; cd dnmp 我们第一件事就是先瞄一眼 .env 文件， 这里设置了很多常量，一会根据个人需求来调整 第二步才是打开 docker-compose.yml 文件， 看后缀都能猜到这是一个配置文件， 另外 docker-compose.yml 是根据缩进来进行分层的，注意书写格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# docker-compose.yml# 语法版本( 3 和 2 区别有点大, 比如 3 取消了 volume_from 的相关语法)version: "3"networks: frontend: driver: $&#123;NETWORKS_DRIVER&#125; backend: driver: $&#123;NETWORKS_DRIVER&#125;volumes: mysql_volume: driver: $&#123;VOLUMES_DRIVER&#125; redis_volume: driver: $&#123;VOLUMES_DRIVER&#125; rabbitmq_volume: driver: $&#123;VOLUMES_DRIVER&#125;# 服务编排services: # workspace: # image: tianon/true # container_name: dnmp-www # volumes: # - ./www:/usr/share/nginx/html# NGINX ############################################# nginx: container_name: dnmp-nginx build: context: ./nginx args: - PHP_UPSTREAM_CONTAINER=$&#123;NGINX_PHP_UPSTREAM_CONTAINER&#125; - PHP_UPSTREAM_PORT=$&#123;NGINX_PHP_UPSTREAM_PORT&#125; depends_on: - php-fpm ports: - "$&#123;NGINX_HOST_HTTP_PORT&#125;:80" - "$&#123;NGINX_HOST_HTTPS_PORT&#125;:443" volumes: # 没必要把配置文件用卷来挂载, 不然就算配置更新了 nginx 也是要重启的 # 挂载运行代码目录 - $&#123;APP_CODE_PATH_HOST&#125;:/var/www # 挂载日志目录 - $&#123;NGINX_HOST_LOG_PATH&#125;:/var/log/nginx # 使用 networks 取代 links 在同一个网络模式下的服务是互通的 # 在service 中使用其他的 service 就直接调用 service 名就行, 不用管 ip 地址, docker 会自己维护一套 networks: - frontend - backend# PHP-FPM ############################################# php-fpm: container_name: dnmp-php-fpm # 这里的args 是属于 build 下面的,用于构建./php-fpm/Dockerfile 文件中 ARG 参数指定 php 版本 build: context: ./php-fpm args: - PHP_VERSION=$&#123;PHP_VERSION&#125; volumes: - $&#123;APP_CODE_PATH_HOST&#125;:/var/www - ./php-fpm/php$&#123;PHP_VERSION&#125;.ini:/usr/local/etc/php/php.ini expose: - "9000" networks: - backend redis: container_name: dnmp-redis build: context: ./redis args: - REDIS_SET_PASSWORD=$&#123;REDIS_SET_PASSWORD&#125; ports: - $&#123;REDIS_HOST_PORT&#125;:6379 volumes: # 这里卷挂载的是本地文件 # - $&#123;DATA_PATH_HOST&#125;/redis:/data # 这里创建一个 redis_volume来存放数据 - redis_volume:/data# Mysql ############################################# mysql: container_name: dnmp-mysql # 镜像来源: https://github.com/docker-library/mysql/blob/fc3e856313423dc2d6a8d74cfd6b678582090fc7/5.7/Dockerfile image: mysql:$&#123;MYSQL_VERSION&#125; volumes: # - $&#123;DATA_PATH_HOST&#125;/mysql:/var/lib/mysql - mysql_volume:/var/lib/mysql # 容器只要停止就会重启 restart: always environment: MYSQL_ROOT_PASSWORD: $&#123;MYSQL_ROOT_PASSWORD&#125; MYSQL_DATABASE: $&#123;MYSQL_DATABASE&#125; MYSQL_USER: $&#123;MYSQL_USER&#125; MYSQL_PASSWORD: $&#123;MYSQL_PASSWORD&#125; ports: - $&#123;MYSQL_HOST_PORT&#125;:3306 接下来看看它的关键词都起着什么作用： version这个规定了文件的版本， 既然有 3 就肯定不用 2 啊， 虽然两者没冲突，但是我喜欢， 2 和 3 版本之间有轻微的变动，具体区别你可以在写配置文件时产生的报错信息来体验一下 network12345networks: frontend: driver: $&#123;NETWORKS_DRIVER&#125; backend: driver: $&#123;NETWORKS_DRIVER&#125; ${NETWORKS_DRIVER} 是从 .env 文件中取的值， 下面的同理 这一块就相当于执行 docker network create -d bridge frontend &amp;&amp; docker network create -d bridge backend在本地持久化的建立一个网络配置，稍后方便容器进行连接， 当然这里也不止是一个 driver 参数，具体配置情况还是参考docker network inspect dnmp_frontend 来看一下 没有设置名字的配置当需要名字的时候会 {当前docker-compose.yml文件名}_{key} 这种格式 有了 network 配置就极大的简化了老版的 --links 命令， 只要属于同一个 network 就能互相访问到， 而不是每新增一个服务就要把原来的服务都 link 一遍 volume1234567volumes: mysql_volume: driver: $&#123;VOLUMES_DRIVER&#125; redis_volume: driver: $&#123;VOLUMES_DRIVER&#125; rabbitmq_volume: driver: $&#123;VOLUMES_DRIVER&#125; 和 network 部分一样， 持久化的创建几个 volume, 相当于命令 docker network create mysql_volume等等 这算是 v3 的一个新特性， 在 v2 的时候， 为了共享数据大家会创建一个什么镜像都不继承的image， 所有容器的 volume 都会和它连接， 现在有了 volume 就没必要这么搞了 service这个是本章的重点， 我们来看下面的例子中的注释， 按序号来12345678910111213141516171819202122232425262728293031323334353637383940services: #1 创建一个服务叫做nginx服务 nginx: #2 为了显得个性化一点，我们指定这个容器的名字叫做 dnmp-nginx container_name: dnmp-nginx #3 标明这个服务的 Dockerfile 的地址，用相对路径方便项目迁移 build: #3.1 相当于命令： # docker build ./nginx -t dnmp-nginx \ # --build-arg PHP_UPSTREAM_CONTAINER=xxx \ # --build-arg PHP_UPSTREAM_PORT=zzz context: ./nginx #3.2 这里 $&#123;NGINX_PHP_UPSTREAM_PORT&#125; 的值是从 .env 文件中取的， args 属于构建时传入的参数 args: - PHP_UPSTREAM_CONTAINER=$&#123;NGINX_PHP_UPSTREAM_CONTAINER&#125; - PHP_UPSTREAM_PORT=$&#123;NGINX_PHP_UPSTREAM_PORT&#125; #4 在启动这个容器之前先启动 php-fpm 这个容器 depends_on: - php-fpm #5 将本地端口和容器端口绑定， 本地哪个端口就看 .env 里怎么写的 ports: - "$&#123;NGINX_HOST_HTTP_PORT&#125;:80" - "$&#123;NGINX_HOST_HTTPS_PORT&#125;:443" #6 设置需要挂载的卷, 这里时将本地目录和容器绑定， 也可以像 services.redis 那样和创建好的卷绑定 volumes: # 没必要把配置文件用卷来挂载, 不然就算配置更新了 nginx 也是要重启的 # 挂载运行代码目录 - $&#123;APP_CODE_PATH_HOST&#125;:/var/www # 挂载日志目录 - $&#123;NGINX_HOST_LOG_PATH&#125;:/var/log/nginx # 使用 networks 取代 links 在同一个网络模式下的服务是互通的 # 在service 中使用其他的 service 就直接调用 service 名就行, 不用管 ip 地址, docker 会自己维护一套 #7 设置容器从属的网络， 同一个网络下可互相访问 networks: - frontend - backend 在上文的 #3 步骤看其他的service也有直接使用image的， 这是直接从远程获取镜像的方式 配置文件写完了， 我们看下nginx的构建文件 12345678910111213141516171819202122232425262728293031# in file ./nginx/Dockerfile#1 选择继承的镜像FROM nginx:1.13.1-alpine#2 各种标签LABEL maintainer="GPF &lt;5173180@qq.com&gt;"#3 容器中执行命令， 且把本地的配置文件添加进去#https://yeasy.gitbooks.io/docker_practice/content/image/build.htmlRUN mkdir -p /etc/nginx/cert \ &amp;&amp; mkdir -p /etc/nginx/conf.d \ &amp;&amp; mkdir -p /etc/nginx/sitesCOPY ./nginx.conf /etc/ngixn/nginx.confCOPY ./conf.d/ /etc/nginx/conf.d/COPY ./cert/ /etc/nginx/cert/COPY ./sites /etc/nginx/sites/#4 这里也是设置构建参数， 不过相同 key 值会被 docker-compose 中的给覆盖掉ARG PHP_UPSTREAM_CONTAINER=php-fpmARG PHP_UPSTREAM_PORT=9000#5 $&#123;PHP_UPSTREAM_CONTAINER&#125; 就在构建时的参数使用方式RUN echo "upstream php-upstream &#123; server $&#123;PHP_UPSTREAM_CONTAINER&#125;:$&#123;PHP_UPSTREAM_PORT&#125;; &#125;" &gt; /etc/nginx/conf.d/upstream.conf#6 设置挂载的目录， 该目录下文件变化不会影响到容器VOLUME ["/var/log/nginx", "/var/www"]#7 设置目录运行时所处在容器中的目录地址WORKDIR /usr/share/nginx/html #5 就是显示了在 nginx 容器中怎么去访问 php-fpm 这个容器, 直接调用 service 名称就行 这里需要注意的时 ARG 和 ENV 的区别， 参考这篇文章： Docker中 Arg 和 Env 的区别 启动docker-compse在配置好 .env 文件和 docker-compose.yml 配置文件后就可以启动它了， 命令也很简单，在同级目录下运行：1docker-compose up -d 它会自动创建volume，network，services， 而且相关的运行参数都是按着配置文件来的， 这样一来每个完整docker-compose.yml中的service就相当于时一个整体，每个服务又属于各自的容器，这样操控是不是节省了很多代码呢？ 查看这些容器的运行状况也很是简单 12docker-compose ps# 或者使用更方便的一个工具： ctop ， github地址： https://github.com/bcicen/ctop 可操控单一容器一样， 但是它会把这一组容器都囊括了进去，操控起来只需要知道操控哪个服务，而一些参数就写在配置文件当中已经默认添加了 一些常用的命令：1234567891011121314# 终止整个服务集合docker-compose stop# 终止指定的服务 （这有个点就是启动的时候会先启动 depond_on 中的容器，关闭的时候不会影响到 depond_on 中的）docker-compose stop nginx# 查看容器的输出日志docker-compose logs -f [services...]# 构建镜像时不使用缓存（能避免很多因为缓存造成的问题）docker-compose build --no-cache --force-rm# 移除指定的容器docker-compose rm nginx 本来熟悉命令的最好方式就是 用-&gt;犯错-&gt;排错-&gt;用 这种循环, 有什么不懂的 谷歌bing 都能查到, 直接 docker-compose --help 也能猜出命令的大概作用, 这里就不细说了 还有个很不错的 docker-compose 项目就是 laradock, dnmp 就是仿照着它写的， 不过网络不好的情况下别运行 laradock， 它现在做的太臃肿了。。。。 看看它里面的镜像是怎么写的还是很有收获的 相关 不正宗 Docker 入门教程-启动一个容器(1/3) 不正宗 Docker 入门教程-构建一个镜像(2/3) 不正宗 Docker 入门教程-使用 Docker-Compose (3/3)]]></content>
      <tags>
        <tag>docker入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不正宗 Docker 入门教程-构建一个镜像(2/3)]]></title>
    <url>%2F2018%2F07%2F08%2Fdocker-step-2%2F</url>
    <content type="text"><![CDATA[本章讲的大概能让你明白虚拟机和 docker 的区别… docker 设置了两种构建镜像的方式: 通过 docker commit 构建镜像(不推荐)这个命令是将先有的容器制作成镜像, 不过建议仅用在排查问题的时候使用, 平时生成容器时最好不要用这种镜像, 因为不知道里面有什么改动, 对于开发者来说完全是一个黑盒 命令格式:1docker commit [参数] &lt;容器 ID 或 容器名&gt; [仓库名[:标签]] [flags] 比如(我随便找了一个本地容器 ID):12345➜ ~ docker commit -m "这是一个测试镜像" -a "GPF" 5ad06ec670eb local_nginx:v1sha256:134e09cdce58842dea03202aa5b6516ead8268afe78d2203be8595b4f0bc5ebe➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZElocal_nginx v1 134e09cdce58 2 seconds ago 109MB 这就把当前的容器转换成了镜像, 提交到远程就是:1docker push local_nginx:v1 和git很像对不对? 不过推送到远程时需要有个 dockerhub 的账号 docker history 命令可以查看镜像的构建记录12345678910111213➜ ~ docker history 134e09cdce58IMAGE CREATED CREATED BY SIZE COMMENT134e09cdce58 12 seconds ago nginx -g daemon off; 0B 这是一个测试镜像649dcb69b782 4 days ago /bin/sh -c #(nop) CMD ["nginx" "-g" "daemon… 0B&lt;missing&gt; 4 days ago /bin/sh -c #(nop) STOPSIGNAL [SIGTERM] 0B&lt;missing&gt; 4 days ago /bin/sh -c #(nop) EXPOSE 80/tcp 0B&lt;missing&gt; 4 days ago /bin/sh -c ln -sf /dev/stdout /var/log/nginx… 22B&lt;missing&gt; 4 days ago /bin/sh -c set -x &amp;&amp; apt-get update &amp;&amp; apt… 53.7MB&lt;missing&gt; 4 days ago /bin/sh -c #(nop) ENV NJS_VERSION=1.15.1.0.… 0B&lt;missing&gt; 4 days ago /bin/sh -c #(nop) ENV NGINX_VERSION=1.15.1-… 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) LABEL maintainer=NGINX Do… 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) CMD ["bash"] 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) ADD file:28fbc9fd012eef727… 55.3MB 通过 Dockerfile 构建镜像一个 Dockerfile 就是一个构建镜像的脚本, 常用的几个命令也不多, 也就FROM, COPY, RUN, ADD, ARG, ENV, VOLUME, EXPOSE, CMD, LABEL, 其他的一些命令就不再这里说了, 想了解完整的 Dockerfile 的关键词看这个 Dockerfile reference 一个简单的 demo接下来我们就用一个完整的 Dockerfile 来示范一下: 首先创建一个Dockerfile12mkdir dockerfile_demo &amp;&amp; cd dockerfile_demovi Dockerfile 12345678910111213# dockerfile 内容# 继承的 ubuntu 镜像的版本号FROM ubuntu:16.04# 将本地 workdir 的文件复制到镜像内部, 另外有个 ADD 指令和这个效果类似, 不过不推荐使用COPY ./sources.list /etc/apt/sources.list# 在镜像内部执行命令, 这里就是更新版本和安装 nginxRUN apt-get update &amp;&amp; apt-get install -y nginx# 修改 nginx 默认的 index.html 的内容RUN echo 'Hi, I am in your container'\ &gt;/var/www/html/index.html# 镜像对外暴露80端口EXPOSE 80 然后为了更新速度快一点, 就要换一个国内镜像1vi sources.list 123456789101112# sources.list 内容deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 然后还是在这个目录下, 运行:1docker build ./ -t local_ubuntu_nginx:v2 执行完毕后就能看到本地多了一个镜像123➜ Documents docker imagesREPOSITORY TAG IMAGE ID CREATED SIZElocal_ubuntu_nginx v2 b0f5984c042a 14 minutes ago 214MB 用这个镜像构建一个容器:123➜ Documents docker run -it --rm -p 8088:80 local_ubuntu_nginx:v2 /bin/bashroot@5cb9ff723bee:/# /usr/sbin/nginxroot@5cb9ff723bee:/# 保持终端打开, 本地访问 http://localhost:8088/ 就能看到欢迎界面了  如果这个是关闭交互端口, 这个就访问不到了, 这里要说一个关键点了 在 docker 中运行的程序不能使用后台运行的模式, 否则 docker 会任务这个容器不活跃或出现问题而自动关闭但是 docker 容器本身是可以后台运行的: docker run -d …… 关于 docker build 多说一句之前我们构建时执行的:1docker build ./ -t local_ubuntu_nginx:v2 这个 ./ 的路径指的是构建文本流(context)的路径, 而不是 Dockerfile的文件路径, 在 Dockerfile 中用的各种相对路径都是基于 context 的,我们完全可以是1docker build /path/to/context -f /path/to/anywhere/Dockerfile_demo -t local_ubuntu_nginx 你看, Dockerfile 的文件名不就变成 Dockerfile_demo 了, 如果有1COPY ./sources.list /etc/apt/sources.list 这样的操作, 那么它的完整路径应该是 /path/to/context/sources.list, 不过默认的情况下就是这两个路径是一起的, 不设置镜像tag的话就拿 Dockerfile 所在的目录名为镜像名,默认latest版本 多阶段构建有时候我们的运行环境和编译环境是两回事, 就拿 golang 来举例, 我们只会去维护代码, 而不去管它生成的二进制包是什么, 又因为golang 打包出来的二进制文件几乎是没有依赖, 只要执行这个文件就行, 那么在运行环境中和编译相关的程序就是多余的, 可以看一下官网的示例 Use multi-stage builds, 不能翻墙的看这个 123456789101112FROM golang:1.7.3WORKDIR /go/src/github.com/alexellis/href-counter/RUN go get -d -v golang.org/x/net/html COPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest RUN apk --no-cache add ca-certificatesWORKDIR /root/# 这个是关键, --from=0 是指从第一个镜像(from)中复制内容, 程序中的1 就是0COPY --from=0 /go/src/github.com/alexellis/href-counter/app .CMD ["./app"] 1$ docker build -t alexellis2/href-counter:latest . 这是我自己构建镜像时编译 swoole.so 的镜像和运行时的镜像大小我们只想要一个 swoole.so 像 gcc, make 都是不是代码运行时需要的模块, 因此只是在编译的时候用上, 吐一个swoole.so出来就行, 相关代码 12345678910111213141516171819202122232425262728293031FROM php:5.6.36-cli-alpine3.7 as builder# 中国特色RUN echo "http://mirrors.ustc.edu.cn/alpine/v3.7/main/" &gt; /etc/apk/repositories# 添加编译 swoole 需要的前置插件RUN apk update &amp;&amp; \ apk upgrade &amp;&amp; \ apk add alpine-sdk linux-headers &amp;&amp; \ apk add autoconf gcc makeRUN wget https://github.com/swoole/swoole-src/archive/1.8.12-stable.tar.gz &amp;&amp; \ tar zxvf 1.8.12-stable.tar.gz &amp;&amp; \ cd swoole-src-1.8.12-stable &amp;&amp; \ phpize &amp;&amp; \ ./configure &amp;&amp; \ make &amp;&amp; make installFROM php:5.6.36-cli-alpine3.7 as runtimer# 这里因为给每一个阶段加了别名, 这样更方便一点COPY --from=builder /usr/local/lib/php/extensions/no-debug-non-zts-20131226/swoole.so /usr/local/lib/php/extensions/no-debug-non-zts-20131226/swoole.soCOPY ./swoole.ini /usr/local/etc/php/conf.d/swoole.ini# 通常 run 是构建镜像时用的, 会保存一层缓存, cmd 就是镜像启动后执行的命令RUN ["php", "-m"]CMD ["php", "-a"] 构建镜像时需要注意的几点 尽量使用官方镜像, 同时版本选择 alpine &gt; debian &gt; ubuntu &gt; centos, alpine版本的镜像是最小的 COPY 和 ADD 尽量使用 COPY, COPY 只是单纯的复制, ADD 则会自动执行一些东西, 有可能出现意料外的问题 CMD 和 ENTERPOINT 这两个可以查一下区别, 我个人习惯用 CMD 容器中的程序都要前台执行的模式, 使用 daemon 模式会被退出(你想想本身一个后台运行的容器中有个后台运行的程序…) 每一个 RUN 指令就是一层缓存, 当其中一个步骤发生更改那么这之后的步骤也都重新构建 系统更新最好合成一个 RUN 比如: 1234RUN apk update &amp;&amp; \ apk upgrade &amp;&amp; \ apk add alpine-sdk linux-headers &amp;&amp; \ apk add autoconf gcc make 同样还是为了避免因为缓存时出现问题 多看看官方构建的镜像, 收获会很多, 比如 docker-nginx, docker-php 相关 不正宗 Docker 入门教程-启动一个容器(1/3) 不正宗 Docker 入门教程-构建一个镜像(2/3) 不正宗 Docker 入门教程-使用 Docker-Compose (3/3)]]></content>
      <tags>
        <tag>docker入门</tag>
      </tags>
  </entry>
</search>
