<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>&lt;hello-world/&gt;</title>
  
  <subtitle>代码改变世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.justwe.site/"/>
  <updated>2018-12-17T07:07:53.898Z</updated>
  <id>http://blog.justwe.site/</id>
  
  <author>
    <name>GPF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go Mysql数据库连接池的使用</title>
    <link href="http://blog.justwe.site/2018/12/17/go-mysql-pool/"/>
    <id>http://blog.justwe.site/2018/12/17/go-mysql-pool/</id>
    <published>2018-12-17T06:48:26.000Z</published>
    <updated>2018-12-17T07:07:53.898Z</updated>
    
    <content type="html"><![CDATA[<p>建立一个mysql连接池将极大的缩短应用的响应时间, 减少频繁的io开销以及gc, 这在golang里面也是很容易就实现的</p><a id="more"></a><p>示例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">_ <span class="string">"github.com/GO-SQL-Driver/MySQL"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, _ = sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123123@tcp(localhost:33060)/go?charset=utf8"</span>)</span><br><span class="line"><span class="comment">// 设置最大连接数</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">300</span>)</span><br><span class="line"><span class="comment">// 设置最大空闲连接数</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// 设置每个链接的过期时间</span></span><br><span class="line">db.SetConnMaxLifetime(time.Second * <span class="number">5</span>)</span><br><span class="line">err := db.Ping()</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">startServer(<span class="string">":9999"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(port <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">record := doSomething()</span><br><span class="line">fmt.Fprintln(w, record)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"listening http://localhost%s\n"</span>, port)</span><br><span class="line">err := http.ListenAndServe(port, <span class="literal">nil</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">rows, err := db.Query(<span class="string">"SELECT * FROM test LIMIT 1"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">columns, _ := rows.Columns()</span><br><span class="line">scanArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line">values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> values &#123;</span><br><span class="line">scanArgs[j] = &amp;values[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="comment">//将行数据保存到record字典</span></span><br><span class="line">err = rows.Scan(scanArgs...)</span><br><span class="line"><span class="keyword">for</span> i, col := <span class="keyword">range</span> values &#123;</span><br><span class="line"><span class="keyword">if</span> col != <span class="literal">nil</span> &#123;</span><br><span class="line">record[columns[i]] = <span class="keyword">string</span>(col.([]<span class="keyword">byte</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Println(record)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> record</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething2</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">dbConn, _ := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123123@tcp(localhost:33060)/go?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">defer</span> dbConn.Close()</span><br><span class="line"></span><br><span class="line">rows, err := dbConn.Query(<span class="string">"SELECT * FROM test LIMIT 1"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">columns, _ := rows.Columns()</span><br><span class="line">scanArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line">values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> values &#123;</span><br><span class="line">scanArgs[j] = &amp;values[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="comment">//将行数据保存到record字典</span></span><br><span class="line">err = rows.Scan(scanArgs...)</span><br><span class="line"><span class="keyword">for</span> i, col := <span class="keyword">range</span> values &#123;</span><br><span class="line"><span class="keyword">if</span> col != <span class="literal">nil</span> &#123;</span><br><span class="line">record[columns[i]] = <span class="keyword">string</span>(col.([]<span class="keyword">byte</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Println(record)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> record</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDoSomething</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">record := doSomething()</span><br><span class="line"></span><br><span class="line">t.Log(record)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDoSomething</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">doSomething()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDoSomethingWithoutPoll</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">doSomething2()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出对比:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> --bench=.</span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkDoSomething-4                     20000             64147 ns/op</span><br><span class="line">BenchmarkDoSomethingWithoutPoll-4           1000           8259274 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      _/Users/gpf/Documents/go/code/mysql_curd/pool   10.360s</span><br></pre></td></tr></table></figure></p><p>关键就是这几个方法:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db, _ = sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123123@tcp(localhost:33060)/go?charset=utf8"</span>)</span><br><span class="line"><span class="comment">// 设置最大连接数</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">300</span>)</span><br><span class="line"><span class="comment">// 设置最大空闲连接数</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// 设置每个链接的过期时间</span></span><br><span class="line">db.SetConnMaxLifetime(time.Second * <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>设置超时时间很有必要, 避免出现server端主动关闭的情况 <code>mysql has gone away...</code></p><p><a href="http://www.01happy.com/golang-go-sql-drive-mysql-connection-pooling/" target="_blank" rel="noopener">代码来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建立一个mysql连接池将极大的缩短应用的响应时间, 减少频繁的io开销以及gc, 这在golang里面也是很容易就实现的&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="mysql" scheme="http://blog.justwe.site/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Go里的点点点语法</title>
    <link href="http://blog.justwe.site/2018/12/14/go-dotdotdot/"/>
    <id>http://blog.justwe.site/2018/12/14/go-dotdotdot/</id>
    <published>2018-12-14T02:37:32.000Z</published>
    <updated>2018-12-14T02:49:03.449Z</updated>
    
    <content type="html"><![CDATA[<p>golang 代码里面有时会出现 <code>...</code> 这个操作, 初次看到也是摸不到头脑,<br>其实他是用来做数组的析构用的</p><a id="more"></a><p>举个例子就明白了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pm := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">test(<span class="string">"abc"</span>, pm...) <span class="comment">// 相当于 test("abc", "a", "b", "c")</span></span><br><span class="line"></span><br><span class="line">ap := []<span class="keyword">string</span>&#123;<span class="string">"f"</span>, <span class="string">"g"</span>&#125;</span><br><span class="line">rs := <span class="built_in">append</span>(pm, ap...)  <span class="comment">// 相当于 append(pm, ap[0], ap[1], 以此类推)</span></span><br><span class="line">fmt.Println(<span class="string">"rs:"</span>, rs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(name <span class="keyword">string</span>, pms ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"output name:"</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> pms &#123;</span><br><span class="line">fmt.Printf(<span class="string">"k: %v, v: %v \n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output name: abc</span><br><span class="line">k: 0, v: a</span><br><span class="line">k: 1, v: b</span><br><span class="line">k: 2, v: c</span><br><span class="line">rs: [a b c f g]</span><br></pre></td></tr></table></figure><p>这里做了两个示例: </p><ol><li><p>在func中的 <code>...</code> eg: <code>func test(name string, pms ...string)</code><br>代表着不限参数数量, 而多出的参数都放在了 <code>var pms []string</code> 这个数组当中, 在go中典型的使用例子就是 <code>fmt.Print</code> 这一系列的方法</p></li><li><p>在传参的时候使用<code>...</code> 是用来表示将数组中每个元素单独传入函数中<br>较长用的就是出现数组合并的时候, 使用<code>append()</code> 方法时:<br>这样写正确</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ap := []<span class="keyword">string</span>&#123;<span class="string">"f"</span>, <span class="string">"g"</span>&#125;</span><br><span class="line">   rs := <span class="built_in">append</span>(pm, ap...)  <span class="comment">// 相当于 append(pm, ap[0], ap[1], 以此类推)</span></span><br></pre></td></tr></table></figure></li></ol><p>这样写就报错<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ap := []<span class="keyword">string</span>&#123;<span class="string">"f"</span>, <span class="string">"g"</span>&#125;</span><br><span class="line">rs := <span class="built_in">append</span>(pm, ap)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang 代码里面有时会出现 &lt;code&gt;...&lt;/code&gt; 这个操作, 初次看到也是摸不到头脑,&lt;br&gt;其实他是用来做数组的析构用的&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Crontab 设置一小时执行一次</title>
    <link href="http://blog.justwe.site/2018/12/11/linux-crontab/"/>
    <id>http://blog.justwe.site/2018/12/11/linux-crontab/</id>
    <published>2018-12-11T02:55:47.000Z</published>
    <updated>2018-12-11T03:21:59.706Z</updated>
    
    <content type="html"><![CDATA[<p>如果主管给你个任务, 让你每小时执行一次脚本, 是不是就是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * xxxxx.bash</span><br></pre></td></tr></table></figure></p><p>这样就错了呦~</p><a id="more"></a><p>以上产生的结果是每分钟执行一次, 因为从匹配角度来看每分钟都符合规则, 继而执行命令</p><p>因此对于整点定时任务有两种写法:</p><p>每<strong>整点</strong>执行一次:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 */1 * * * xxxxx.bash</span><br></pre></td></tr></table></figure></p><p>每<strong>隔60分钟</strong>执行一次:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/60 * * * * xxxxx.bash</span><br></pre></td></tr></table></figure></p><p>注意我的描述啊, 整点和隔60分钟其实是两个东西, 根据具体业务要求去使用它</p><p><img src="/images/crontab.png" alt=""></p><p>关于定时器这里有三个示例:</p><ol><li><p>在上午8点到11点的第3和第15分钟执行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每隔两天的上午8点到11点的第3和第15分钟执行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 */2 * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每个星期一的上午8点到11点的第3和第15分钟执行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li></ol><p>详细的crontab操作可以参考这篇博客:<br><a href="https://blog.csdn.net/u014726937/article/details/51182666" target="_blank" rel="noopener">crontab–定时器命令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果主管给你个任务, 让你每小时执行一次脚本, 是不是就是这样:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* */1 * * * xxxxx.bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样就错了呦~&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.justwe.site/categories/tools/"/>
    
    
      <category term="linux" scheme="http://blog.justwe.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>通过Channel控制并发数量</title>
    <link href="http://blog.justwe.site/2018/12/04/go-channel-waitgroup/"/>
    <id>http://blog.justwe.site/2018/12/04/go-channel-waitgroup/</id>
    <published>2018-12-04T06:14:30.000Z</published>
    <updated>2018-12-04T06:26:24.991Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>go</code> 关键字有时候需要控制一下并发的数量, 但不至于去修改 <code>runtime.GOMAXPROCS</code> 这个数值, 这里就用到了缓冲<code>channel</code>的特性</p><a id="more"></a><p>demo:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WaitGroup 一个异步结构体</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">workChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">wg       sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPool 生成一个工作池, coreNum 限制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">(coreNum <span class="keyword">int</span>)</span> *<span class="title">WaitGroup</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, coreNum)</span><br><span class="line"><span class="keyword">return</span> &amp;WaitGroup&#123;</span><br><span class="line">workChan: ch,</span><br><span class="line">wg:       sync.WaitGroup&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ap *WaitGroup)</span> <span class="title">Add</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">ap.workChan &lt;- i</span><br><span class="line">ap.wg.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done 完结</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ap *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ap.workChan:</span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ap.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ap *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">ap.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRun</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">work := NewPool(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">work.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> testFunc(i, work)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"waiting..."</span>)</span><br><span class="line">work.Wait()</span><br><span class="line">t.Log(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFunc</span><span class="params">(i <span class="keyword">int</span>, wg *WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">"2006-01-02T15:04:05Z07:00"</span>), <span class="string">"output: "</span>, i)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">"2006-01-02T15:04:05Z07:00"</span>), <span class="string">"output: "</span>, i, <span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2018-12-04T14:22:27+08:00 output:  3</span><br><span class="line">2018-12-04T14:22:27+08:00 output:  1</span><br><span class="line">2018-12-04T14:22:27+08:00 output:  0</span><br><span class="line">2018-12-04T14:22:27+08:00 output:  2</span><br><span class="line">2018-12-04T14:22:28+08:00 output:  3 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:28+08:00 output:  0 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:28+08:00 output:  1 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:28+08:00 output:  5</span><br><span class="line">2018-12-04T14:22:28+08:00 output:  6</span><br><span class="line">2018-12-04T14:22:28+08:00 output:  2 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:28+08:00 output:  7</span><br><span class="line">2018-12-04T14:22:28+08:00 output:  4</span><br><span class="line">2018-12-04T14:22:29+08:00 output:  4 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:29+08:00 output:  8</span><br><span class="line">2018-12-04T14:22:29+08:00 output:  7 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:29+08:00 output:  6 <span class="keyword">done</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>这里还是要带上 <code>sync.WaitGroup</code>, 保证最后一次循环时携程不会过早退出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;go&lt;/code&gt; 关键字有时候需要控制一下并发的数量, 但不至于去修改 &lt;code&gt;runtime.GOMAXPROCS&lt;/code&gt; 这个数值, 这里就用到了缓冲&lt;code&gt;channel&lt;/code&gt;的特性&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Nginx转发到go服务当中</title>
    <link href="http://blog.justwe.site/2018/11/25/go-nginx-docker/"/>
    <id>http://blog.justwe.site/2018/11/25/go-nginx-docker/</id>
    <published>2018-11-25T07:39:36.000Z</published>
    <updated>2018-11-25T07:52:38.746Z</updated>
    
    <content type="html"><![CDATA[<p>通过docker-compose编排的容器总是有一些奇怪的问题</p><a id="more"></a><p>问题核心就是go-server和nginx所属不同的容器, 需要外界能访问到go的服务就需要进行转发了</p><p>如果是在同一个容器中只需要:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  .a.com;</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    access_log  /home/a.com.access.log;</span><br><span class="line"></span><br><span class="line">    location /(css|js|fonts|img)/ &#123;</span><br><span class="line">        access_log off;</span><br><span class="line">        expires 1d;</span><br><span class="line"></span><br><span class="line">        root &quot;/path/to/app_a/static&quot;;</span><br><span class="line">        try_files $uri @backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files /_not_exists_ @backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @backend &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_set_header Host            $http_host;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://beego.me/docs/deploy/nginx.md" target="_blank" rel="noopener">beego-nginx部署</a></p><p>那么如果是两个容器当中呢? 基于上面的例子, 我们需要用到<code>upstream</code>, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">upstream go_server_proxy &#123;</span><br><span class="line">    # 这里的server 需要用到 容器名:端口 的形式</span><br><span class="line">    server go_server:9090;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root /var/www;</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    access_log  /var/log/nginx/def.access.log;</span><br><span class="line"></span><br><span class="line">    location /(css|js|fonts|img)/ &#123;</span><br><span class="line">        access_log off;</span><br><span class="line">        expires 1d;</span><br><span class="line"></span><br><span class="line">        root &quot;/var/www/static&quot;;</span><br><span class="line">        try_files $uri @backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files /_not_exists_ @backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @backend &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_set_header Host            $http_host;</span><br><span class="line">        proxy_pass  http://go_server_proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的原因是容器之间的ip并不固定, 使用容器名做host地址是更简单的选择</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过docker-compose编排的容器总是有一些奇怪的问题&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="docker" scheme="http://blog.justwe.site/tags/docker/"/>
    
      <category term="nginx" scheme="http://blog.justwe.site/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Go 火焰图分析</title>
    <link href="http://blog.justwe.site/2018/11/01/go-flame-graph/"/>
    <id>http://blog.justwe.site/2018/11/01/go-flame-graph/</id>
    <published>2018-11-01T09:03:33.000Z</published>
    <updated>2018-11-25T07:38:45.761Z</updated>
    
    <content type="html"><![CDATA[<p>go version go1.11.1 darwin/amd64</p><p>安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/uber/go-torch</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/uber/go-torch</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/brendangregg/FlameGraph.git</span><br></pre></td></tr></table></figure></p><p>安装测试工具<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/Masterminds/glide</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/uber/go-torch</span><br><span class="line">$ glide install</span><br></pre></td></tr></table></figure></p><p>性能分析工具</p><a id="more"></a><p><code>glide install</code>如果出现  <code>Update failed for golang.org/x/sys: Cannot detect VCS</code> 这种报错, 可以执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ glide mirror <span class="built_in">set</span> https://golang.org/x/sys https://github.com/golang/sys</span><br></pre></td></tr></table></figure></p><p>改变 <code>$HOME/.gilde/mirrors.yaml</code> 的镜像链接即可</p><p>运行时完成后输入 web<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go tool pprof --seconds 25 http://localhost:9090/debug/pprof/profile</span><br><span class="line">Fetching profile over HTTP from http://localhost:9090/debug/pprof/profile?seconds=25</span><br><span class="line">Please <span class="built_in">wait</span>... (25s)</span><br><span class="line">Saved profile <span class="keyword">in</span> /Users/gpf/pprof/pprof.samples.cpu.002.pb.gz</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Nov 2, 2018 at 11:46am (CST)</span><br><span class="line">Duration: 25s, Total samples = 2.17s ( 8.68%)</span><br><span class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) web</span><br><span class="line">Failed to execute dot. Is Graphviz installed? Error: <span class="built_in">exec</span>: <span class="string">"dot"</span>: executable file not found <span class="keyword">in</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p><p>出现 <code>Failed to execute dot. Is Graphviz installed? Error: exec: &quot;dot&quot;: executable file not found in $PATH</code> 报错, 需要安装 <code>graphviz</code>  在 mac 上就直接 <code>brew install graphviz</code> 即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go version go1.11.1 darwin/amd64&lt;/p&gt;
&lt;p&gt;安装:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ go get github.com/uber/go-torch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/uber/go-torch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/brendangregg/FlameGraph.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;安装测试工具&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ go get github.com/Masterminds/glide&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/uber/go-torch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ glide install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;性能分析工具&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="flame-graph" scheme="http://blog.justwe.site/tags/flame-graph/"/>
    
  </entry>
  
  <entry>
    <title>Git-Diff</title>
    <link href="http://blog.justwe.site/2018/10/26/git-diff/"/>
    <id>http://blog.justwe.site/2018/10/26/git-diff/</id>
    <published>2018-10-26T07:01:51.000Z</published>
    <updated>2018-10-26T07:05:19.648Z</updated>
    
    <content type="html"><![CDATA[<p>git 对比文件差异</p><a id="more"></a><p>通常 <code>git diff COMMIT_ID_1 COMMIT_DI_2</code> 查看</p><p>只查看更改过的文件目录</p><p><code>git diff  --name-only COMMIT_ID_1 COMMIT_DI_2</code></p><p>快捷用法就是:</p><p><code>git diff  --name-only HEAD HEAD^</code></p><p>对比和上次提交时的改动</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 对比文件差异&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.justwe.site/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.justwe.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>记一次 Git Revert 的经历</title>
    <link href="http://blog.justwe.site/2018/10/25/git-revert/"/>
    <id>http://blog.justwe.site/2018/10/25/git-revert/</id>
    <published>2018-10-25T08:27:06.000Z</published>
    <updated>2018-10-25T09:17:03.714Z</updated>
    
    <content type="html"><![CDATA[<p>合作开发经常会提<code>merge request</code>嘛, 然后就提了一个不该提的, 还手抖给合并了….</p><a id="more"></a><p>返现问题以后准备回退, 然后抬眼一看各分支的合并情况….<br><img src="http://blog-image.onlyoneip.com/git-merge-line.png" alt=""></p><p>哇脑壳痛, 这就用不了平时最喜欢的 <code>reset</code> 了, 查了查资料, 想<strong>取消某一次 merge request</strong>用 <code>revert</code> 是最合适的</p><p>接下来分三步,先找到要回退的那次 mr, 通常是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line"></span><br><span class="line">commit 365ea982c24f2c60150df6159734ab73b74515bc (origin/master, origin/HEAD)</span><br><span class="line">Merge: 465fbfb8 f15b39ae</span><br><span class="line">Author: xxx &lt;xxx&gt;</span><br><span class="line">Date:   Thu Oct 25 15:41:10 2018 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'master'</span> of xxxxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">commit 465fbfb8084089f9d08516b4d75ba51ae5dcd5ce</span><br><span class="line">Author: xxx &lt;xxx&gt;</span><br><span class="line">Date:   Thu Oct 25 15:41:03 2018 +0800</span><br><span class="line"></span><br><span class="line">    merge</span><br><span class="line"></span><br><span class="line">commit 1e309ff40fd02d1c9c6e604c2649d8a94086a573</span><br><span class="line">Author: xxx &lt;zhangkaixuan&gt;</span><br><span class="line">Date:   Thu Oct 25 15:40:37 2018 +0800</span><br><span class="line"></span><br><span class="line">    merge</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样的, 这只是 log 的中间的一部分, 假设 mr 之后后续又有很多 mr 已经合并了, 那么先找到我们要回退的 <code>commit id</code>, 这里就假设一个叫 <code>c76627674dedf4fc067cb0c5b2afbc123fd9c053</code></p><ol><li><p>执行 <code>git revert -m 1 c76627674dedf4fc067cb0c5b2afbc123fd9c053</code></p><p> 通常执行这一步之后没什么冲突就可以了, 然后有冲突了, 就和正常的 merger conflicts 处理一样</p></li><li><p>解决完冲突, 执行 <code>git revert --continue</code> 这就算合并了</p><p> 那么回滚到一半不想做了, 也好说, 执行 <code>git revert --abort</code> 以后, 大家就当无事发生过</p></li></ol><p>关于 <code>git revert -m 1</code> 这个<code>1</code>指的是 <code>mainline</code>, 1 代表着 master 这条线<br><a href="https://stackoverflow.com/a/5971033/9561528" target="_blank" rel="noopener">资料参考: Why does git revert complain about a missing -m option?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合作开发经常会提&lt;code&gt;merge request&lt;/code&gt;嘛, 然后就提了一个不该提的, 还手抖给合并了….&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.justwe.site/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.justwe.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>转 Vscode 设置终端字体</title>
    <link href="http://blog.justwe.site/2018/10/16/vscode-terminal-font-macOS/"/>
    <id>http://blog.justwe.site/2018/10/16/vscode-terminal-font-macOS/</id>
    <published>2018-10-16T07:50:28.000Z</published>
    <updated>2018-10-16T07:59:17.477Z</updated>
    
    <content type="html"><![CDATA[<p>mac 上设置vscode终端样式(尤其是想用 powershell 主题的)</p><a id="more"></a><h3 id="Mac下配置vscode终端字体："><a href="#Mac下配置vscode终端字体：" class="headerlink" title="Mac下配置vscode终端字体："></a>Mac下配置vscode终端字体：</h3><p>在Mac 10.13.6下的解决方案（亲测可用），其他版本做参考。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下载安装字体</span><br><span class="line"><span class="variable">$cd</span> /Library/Fonts</span><br><span class="line"><span class="variable">$sudo</span> git <span class="built_in">clone</span> https://github.com/abertsch/Menlo-for-Powerline.git</span><br></pre></td></tr></table></figure><p>config.json 位置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows %APPDATA%\Code\User\settings.json</span><br><span class="line">Mac <span class="variable">$HOME</span>/Library/Application Support/Code/User/settings.json</span><br><span class="line">Linux <span class="variable">$HOME</span>/.config/Code/User/settings.json</span><br></pre></td></tr></table></figure></p><p>在 vscode 配置中设置字体：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/Library/Application Support/Code/User/settings.json</span><br><span class="line"><span class="comment"># 文件内指定字体主题</span></span><br><span class="line"><span class="string">"terminal.integrated.fontFamily"</span>: <span class="string">"Menlo for Powerline"</span></span><br></pre></td></tr></table></figure></p><h3 id="在Ubuntu-18-04-1LTS-下的解决方案（亲测可用），其他版本linux做参考。"><a href="#在Ubuntu-18-04-1LTS-下的解决方案（亲测可用），其他版本linux做参考。" class="headerlink" title="在Ubuntu 18.04.1LTS 下的解决方案（亲测可用），其他版本linux做参考。"></a>在Ubuntu 18.04.1LTS 下的解决方案（亲测可用），其他版本linux做参考。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下载安装字体</span><br><span class="line"><span class="variable">$cd</span> /usr/share/fonts/truetype/</span><br><span class="line"><span class="variable">$sudo</span> git <span class="built_in">clone</span> https://github.com/abertsch/Menlo-for-Powerline.git</span><br><span class="line">刷新字体</span><br><span class="line"><span class="variable">$sudo</span> <span class="built_in">fc</span>-cache -f -v</span><br></pre></td></tr></table></figure><p>回到  Vs Code的用户设置.json  中加入以下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"terminal.integrated.fontFamily": "Menlo for Powerline",</span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/chenghai37/article/details/81417293" target="_blank" rel="noopener">文章来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac 上设置vscode终端样式(尤其是想用 powershell 主题的)&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.justwe.site/categories/tools/"/>
    
    
      <category term="tools" scheme="http://blog.justwe.site/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Golang 处理 Map[interface{}]interface{} 数据</title>
    <link href="http://blog.justwe.site/2018/09/28/go-complex-interface/"/>
    <id>http://blog.justwe.site/2018/09/28/go-complex-interface/</id>
    <published>2018-09-28T08:58:31.000Z</published>
    <updated>2018-09-28T09:04:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>go 调用 rpc , 掉用其他的服务时会出现一些神奇的数据结构, 今天我们来实验一个</p><a id="more"></a><p>上代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是针对出现 map[interface&#123;&#125;]interface&#123;&#125; 类型数据进行的一次转化处理示例</span></span><br><span class="line"><span class="keyword">type</span> respBody <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个从 hprose-php-server 传过来的数据</span></span><br><span class="line">res := <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"errorCode"</span>: <span class="number">200</span>,</span><br><span class="line"><span class="string">"errorMsg"</span>:  <span class="string">"登录成功"</span>,</span><br><span class="line"><span class="string">"responseData"</span>: <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"hx_password"</span>: <span class="string">"c427ee88c8abeeee4fcddbfbf8767025"</span>,</span><br><span class="line"><span class="string">"like_post"</span>:   <span class="number">0</span>,</span><br><span class="line"><span class="string">"avatar"</span>:      <span class="string">"http://img2.xxx.com/user/3_100_100.png"</span>,</span><br><span class="line"><span class="string">"beauty_list"</span>: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line"><span class="string">"role"</span>:        []<span class="keyword">string</span>&#123;<span class="string">"admin"</span>, <span class="string">"emplyee"</span>, <span class="string">"boss"</span>&#125;,</span><br><span class="line"><span class="string">"mission_status"</span>: <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"ok"</span>: <span class="number">233</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp := respHandler(res)</span><br><span class="line">log.Println(<span class="string">"tmp:"</span>, tmp)</span><br><span class="line"></span><br><span class="line">by, err := json.Marshal(tmp)</span><br><span class="line">log.Println(<span class="string">"output json:"</span>, <span class="keyword">string</span>(by), err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">respHandler</span><span class="params">(res <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(tmp <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// map 需要初始化一个出来</span></span><br><span class="line">tmp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">log.Println(<span class="string">"input res is : "</span>, res)</span><br><span class="line"><span class="keyword">switch</span> res.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">return</span> tmp</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line"><span class="keyword">return</span> res.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">log.Println(<span class="string">"map[interface&#123;&#125;]interface&#123;&#125; res:"</span>, res)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> res.(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">log.Println(<span class="string">"loop:"</span>, k, v)</span><br><span class="line"><span class="keyword">switch</span> k.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line"><span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">log.Println(<span class="string">"map[interface&#123;&#125;]interface&#123;&#125; v:"</span>, v)</span><br><span class="line">tmp[k.(<span class="keyword">string</span>)] = respHandler(v)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">log.Printf(<span class="string">"default v: %v %v \n"</span>, k, v)</span><br><span class="line">tmp[k.(<span class="keyword">string</span>)] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 暂时没遇到更复杂的数据</span></span><br><span class="line">log.Println(<span class="string">"unknow data:"</span>, res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 调用 rpc , 掉用其他的服务时会出现一些神奇的数据结构, 今天我们来实验一个&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="json" scheme="http://blog.justwe.site/tags/json/"/>
    
      <category term="switch" scheme="http://blog.justwe.site/tags/switch/"/>
    
  </entry>
  
  <entry>
    <title>Go 开发时的一些初级问题</title>
    <link href="http://blog.justwe.site/2018/09/25/go-primary-mistakes/"/>
    <id>http://blog.justwe.site/2018/09/25/go-primary-mistakes/</id>
    <published>2018-09-25T02:57:02.000Z</published>
    <updated>2018-09-28T09:03:32.263Z</updated>
    
    <content type="html"><![CDATA[<p>平时碰到的一些小问题, 记一下</p><a id="more"></a><h4 id="assignment-to-entry-in-nil-map-map-赋值问题"><a href="#assignment-to-entry-in-nil-map-map-赋值问题" class="headerlink" title="assignment to entry in nil map, map 赋值问题"></a>assignment to entry in nil map, map 赋值问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ServiceMap 可用服务列表</span></span><br><span class="line"><span class="keyword">type</span> ServiceMap <span class="keyword">struct</span> &#123;</span><br><span class="line">handlers <span class="keyword">map</span>[<span class="keyword">string</span>]BaseClient</span><br><span class="line">RWLock   sync.RWMutex</span><br><span class="line">BaseService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ServiceMp *ServiceMap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1</span></span><br><span class="line">    ServiceMp = &amp;ServiceMap&#123;&#125;</span><br><span class="line">    <span class="comment">// #2.1</span></span><br><span class="line">ServiceMp.handlers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]BaseClient)</span><br><span class="line"></span><br><span class="line">ServiceMp.AddMethod(<span class="string">"XyToken"</span>, BaseClient&#123;</span><br><span class="line">Module: <span class="string">"System"</span>,</span><br><span class="line">Class:  <span class="string">"XyToken"</span>,</span><br><span class="line">Func:   <span class="string">"getXyOpenKey"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">"get method:"</span>, ServiceMp.handlers)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddMethod 添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(serv *ServiceMap)</span> <span class="title">AddMethod</span><span class="params">(key <span class="keyword">string</span>, body BaseClient)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"AddMethod error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := serv.handlers[key]; !ok &#123;</span><br><span class="line">        serv.RWLock.Lock()</span><br><span class="line">        <span class="comment">// #2.2</span></span><br><span class="line">serv.handlers[key] = body</span><br><span class="line">serv.RWLock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>#1</code> 当文件里有一个全局的变量时, 需要先初始化 <code>ServiceMp = &amp;ServiceMap{}</code> 一个实体出来 </li><li><code>#2</code> 在 <code>ServiceMap.handlers</code>这个值添加方法的时候, 不能直接 <code>serv.handlers[key] = body</code>, 而是要先给它赋值一个空的切片,才能往里面加东西, 参考 <code>#2.1 和 #2.2</code></li></ul><h4 id="interface-conversion-interface-is-float64-not-int"><a href="#interface-conversion-interface-is-float64-not-int" class="headerlink" title="interface conversion: interface {} is float64, not int"></a>interface conversion: interface {} is float64, not int</h4><p>通常json 转成 <code>map[string]interface{}</code> 时,数字类型就是<code>float64</code>的, </p><p>比如:想把它转成<code>int</code>类型使用就要<code>auth.Sys = int(sys.(float64))</code>这样(sys 就是一个 interface{} 类型的数字), 而不是<code>auth.Sys = sys.(int)</code>, 后一种写法会有 painc 错误</p><h4 id="xxx-type-只能用在-switch-当中-不想这么写就用-reflect-Typeof-xxx"><a href="#xxx-type-只能用在-switch-当中-不想这么写就用-reflect-Typeof-xxx" class="headerlink" title="xxx.(type) 只能用在 switch 当中, 不想这么写就用 reflect.Typeof(xxx)"></a>xxx.(type) 只能用在 switch 当中, 不想这么写就用 reflect.Typeof(xxx)</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时碰到的一些小问题, 记一下&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 的测试文件</title>
    <link href="http://blog.justwe.site/2018/09/20/go-test/"/>
    <id>http://blog.justwe.site/2018/09/20/go-test/</id>
    <published>2018-09-20T02:45:51.000Z</published>
    <updated>2018-09-20T02:55:06.095Z</updated>
    
    <content type="html"><![CDATA[<p>一些函数没有连续的会话状态是可以写出来顺便就写一个测试脚本了<br><a id="more"></a><br>比如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis.go</span></span><br><span class="line"><span class="keyword">package</span> tools</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gomodule/redigo/redis"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"user-server/config"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">redisClient  *redis.Pool</span><br><span class="line">REDIS_HOST   <span class="keyword">string</span></span><br><span class="line">REDIS_DB     <span class="keyword">int</span></span><br><span class="line">REDIS_AUTH   <span class="keyword">string</span></span><br><span class="line">MAX_ACTIVE   <span class="keyword">int</span></span><br><span class="line">MAX_IDLE     <span class="keyword">int</span></span><br><span class="line">IDLE_TIMEOUT <span class="keyword">int64</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">REDIS_HOST = config.Conf.Redis.Host</span><br><span class="line">REDIS_DB = <span class="number">0</span></span><br><span class="line">REDIS_AUTH = <span class="string">"abc"</span></span><br><span class="line">MAX_ACTIVE = <span class="number">10</span></span><br><span class="line">MAX_IDLE = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*@MaxIdle 最大空闲链接</span></span><br><span class="line"><span class="comment">*@MaxActive 最大活跃链接</span></span><br><span class="line"><span class="comment">*@IdleTimeout 自动超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">redisClient = &amp;redis.Pool&#123;</span><br><span class="line">MaxIdle:     MAX_IDLE,</span><br><span class="line">MaxActive:   MAX_ACTIVE,</span><br><span class="line">IdleTimeout: <span class="number">30</span> * time.Second,</span><br><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span> &#123;</span><br><span class="line">c, err := redis.Dial(<span class="string">"tcp"</span>, REDIS_HOST)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> REDIS_AUTH != <span class="string">""</span> &#123;</span><br><span class="line">c.Do(<span class="string">"AUTH"</span>, REDIS_AUTH)</span><br><span class="line">&#125;</span><br><span class="line">c.Do(<span class="string">"SELECT"</span>, REDIS_DB)</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRedis</span><span class="params">()</span> <span class="title">redis</span>.<span class="title">Conn</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisClient.Get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的测试文件 在同目录创建一个 <code>redis_test.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tools</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetRedis</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">co := GetRedis()</span><br><span class="line"><span class="keyword">defer</span> co.Close()</span><br><span class="line"></span><br><span class="line">co.Do(<span class="string">"SET"</span>, <span class="string">"test_redis_key"</span>, <span class="string">"test_redis_value"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试脚本的标准格式是:</p><ul><li>文件名为 <code>xxx_test.go</code> 作为测试文件标记</li><li>引入 <code>testing</code> 包</li><li>要测试的函数名为 <code>TestXXXX(t *testing.T)</code> 输出结果通过  <code>t.Logf()</code> <code>t.Error()</code> 这类的测试包提供的函数来调用</li></ul><p>写完代码, 在目录下运行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行当前目录所有测试文件并输出结果</span></span><br><span class="line">go <span class="built_in">test</span> -v</span><br><span class="line"><span class="comment"># 运行指定测试文件, 需要把被测试文件也带上</span></span><br><span class="line">go <span class="built_in">test</span> -v redis.go redis_test.go</span><br><span class="line"><span class="comment"># 运行指定的测试方法</span></span><br><span class="line">go <span class="built_in">test</span> -v --test.run TestGetRedis</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些函数没有连续的会话状态是可以写出来顺便就写一个测试脚本了&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go Interface 的机制</title>
    <link href="http://blog.justwe.site/2018/09/12/go-interface-tip/"/>
    <id>http://blog.justwe.site/2018/09/12/go-interface-tip/</id>
    <published>2018-09-12T06:53:03.000Z</published>
    <updated>2018-09-12T07:07:37.407Z</updated>
    
    <content type="html"><![CDATA[<p>对 interface 赋值变量的时候经常出的问题</p><a id="more"></a><p>日常开发时有个这样的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">interface</span> &#123;</span><br><span class="line">Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Boy <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Boy)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"my name is "</span> + b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">xiaoming := Boy&#123;Name: <span class="string">"xiao ming"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> h Human</span><br><span class="line"><span class="comment">// h = xiaoming // #1 会报错, Boy does not implement Human (Run method has pointer receiver)</span></span><br><span class="line">h = &amp;xiaoming</span><br><span class="line">h.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用 <code>#1</code> 这行代码时会出现以下错误:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./main.go:23:4: cannot use xiaoming (<span class="built_in">type</span> Boy) as <span class="built_in">type</span> Human <span class="keyword">in</span> assignment:</span><br><span class="line">        Boy does not implement Human (Run method has pointer receiver)</span><br></pre></td></tr></table></figure></p><p>然而用下面的 <code>h = &amp;xiaoming</code> 是正常的</p><p>这个问题，首先得先了解一下Golang 中 方法的集合的概念，一个struct虽然可以通过值类型和引用类型两种方式定义方法，但是不通的对象类型对应了不同的方法集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Values                    Methods Receivers</span><br><span class="line">-----------------------------------------------</span><br><span class="line"> T                        (t T)</span><br><span class="line">*T                        (t T) and (t *T)</span><br></pre></td></tr></table></figure><p>值类型的对象只有（t T) 结构的方法，虽然值类型的对象也可以调用(t *T) 方法，但这实际上是Golang编译器自动转化成了&amp;t的形式来调用方法，并不是表明值类型的对象拥有该方法。</p><p>换一个维度来看上面的表格可能更加直观：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Methods Receivers         Values</span><br><span class="line">-----------------------------------------------</span><br><span class="line">(t T)                     T and *T</span><br><span class="line"></span><br><span class="line">(t *T)                    *T</span><br></pre></td></tr></table></figure><p>这就意味着指针类型的receiver 方法实现接口时，只有指针类型的对象实现了该接口。</p><p>对应上面的例子来说，只有&amp;user实现了notifier接口，而user根本没有实现该接口。所以上面代码会报出这样的异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 interface 赋值变量的时候经常出的问题&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="interface" scheme="http://blog.justwe.site/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>身为 Phper 为什么我选择 Go 语言?</title>
    <link href="http://blog.justwe.site/2018/09/12/go-why/"/>
    <id>http://blog.justwe.site/2018/09/12/go-why/</id>
    <published>2018-09-12T06:45:50.000Z</published>
    <updated>2018-09-12T06:51:01.550Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想换个语言开发的同学可以看这里</p></blockquote><a id="more"></a><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><h3 id="go-相比-php-有哪些优势"><a href="#go-相比-php-有哪些优势" class="headerlink" title="go 相比 php 有哪些优势?"></a>go 相比 php 有哪些优势?</h3><ul><li>go 的部署简单, 运行时只要把一个二进制文件扔到机器上就行, 这一点在容器化方面优势很大</li><li>可控的多线程和更简单的多线程间通信</li><li>编译型语言对动态语言天生的性能优势, 变量在开发过程中不会突然从 str 变成 array</li><li>微服务相关的项目多</li><li>自 go 1.5 以后, 底层完全采用的 go 自己的代码重构</li></ul><h3 id="go-本身的优势"><a href="#go-本身的优势" class="headerlink" title="go 本身的优势"></a>go 本身的优势</h3><ul><li>开发效率和运行的效率都在可接受范围</li><li>成熟的官方库和活跃的社区, 还有官方出品的工具链</li><li>语法简单(25个关键字), 对于初学者来说不用受配置环境的苦</li><li>良好兼容 c 语言</li><li>语言层面支持并发</li><li>运行时对外部的依赖极少</li></ul><h3 id="go-较于-php-的劣势"><a href="#go-较于-php-的劣势" class="headerlink" title="go 较于 php 的劣势"></a>go 较于 php 的劣势</h3><ul><li>编译造成的繁琐操作</li><li>代码量偏多</li><li>至今没有一个成熟的依赖库管理工具, 缺乏版本管理</li><li>字典类型要考虑并发读写安全的问题, 需要有<code>锁</code>的概念, 这一点 swoole 也有类似的情况</li></ul><hr><h2 id="go-的特色"><a href="#go-的特色" class="headerlink" title="go 的特色"></a>go 的特色</h2><h3 id="defer-延迟处理"><a href="#defer-延迟处理" class="headerlink" title="defer 延迟处理"></a>defer 延迟处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">  file.Open(<span class="string">"file/path"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  file.Close()</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">  file.Open(<span class="string">"file/path"</span>)</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i :=<span class="number">0</span>;i &lt; <span class="number">5</span> ; i++&#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"输出："</span>,i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 输出： 4</span></span><br><span class="line"><span class="comment">// 输出： 3</span></span><br><span class="line"><span class="comment">// 输出： 2</span></span><br><span class="line"><span class="comment">// 输出： 1</span></span><br><span class="line"><span class="comment">// 输出： 0</span></span><br></pre></td></tr></table></figure><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multipartReturn</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">res = a + b</span><br><span class="line"><span class="keyword">if</span> res &gt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"math: square root of negative number"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="goroutinue-并发"><a href="#goroutinue-并发" class="headerlink" title="goroutinue 并发"></a>goroutinue 并发</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> loop(<span class="literal">true</span>)</span><br><span class="line">loop(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loop</span><span class="params">(desc <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> desc &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">10</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">fmt.Printf(<span class="string">"loop1: %d \n"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"loop2: %d \n"</span>, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel-多线程通信"><a href="#channel-多线程通信" class="headerlink" title="channel 多线程通信"></a>channel 多线程通信</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">go</span> loopPro(<span class="literal">true</span>, ch)</span><br><span class="line"><span class="keyword">go</span> loopPro(<span class="literal">false</span>, ch)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">fmt.Print(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入 channel 的概念</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loopPro</span><span class="params">(desc <span class="keyword">bool</span>, ch <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> desc &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">10</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"loop1: %d \n"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"loop2: %d \n"</span>, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p><code>http-server</code>的 demo<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"route: http://localhost:9090/"</span>)</span><br><span class="line">fmt.Println(<span class="string">"route: http://localhost:9090/hello"</span>)</span><br><span class="line"></span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line"></span><br><span class="line">mux.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br><span class="line">mux.HandleFunc(<span class="string">"/"</span>, pageHandler)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">":9090"</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pageHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hi baby"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可根编译成指定平台的执行文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure></p><h3 id="调用-c-代码"><a href="#调用-c-代码" class="headerlink" title="调用 c 代码"></a>调用 c 代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下面是 C 代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int add(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">//     return a + b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := C.<span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">b := C.<span class="keyword">int</span>(<span class="number">2</span>)</span><br><span class="line">value := C.add(a, b)</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://bastengao.com/blog/2017/12/go-cgo-c.html" target="_blank" rel="noopener">代码来源</a></p><hr><h2 id="大体了解一下语法"><a href="#大体了解一下语法" class="headerlink" title="大体了解一下语法"></a>大体了解一下语法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官网安装包地址: <a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a><br>以 centos 为例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.google.com/go/go1.11.linux-amd64.tar.gz</span><br><span class="line">$ tar -C /usr/<span class="built_in">local</span> -zxvf go1.11.linux-amd64.tar.gz</span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin/</span><br><span class="line">$ go</span><br></pre></td></tr></table></figure></p><p>GOROOT 不用管它…<br>GOPATH 目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/                                # 生成的执行文件                </span><br><span class="line">pkg/                                # 编译时用到的外部库执行文件</span><br><span class="line">src/                                # 我们开发的各种库和 go get 到的各种库源码</span><br></pre></td></tr></table></figure></p><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>go run main.go</code></p><h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><p>常用: </p><ul><li><code>int/int8/int16/int32/int64</code></li><li><code>uint/uint8/uint16/uint32/uint64</code></li><li><code>float32/float64</code></li><li><code>string</code></li><li><code>array</code></li><li><code>slice</code>(切片)</li><li><code>map</code>(字典)</li><li><code>point</code>(指针)</li></ul><p>面向对象: </p><ul><li><code>struct</code></li><li><code>interface</code></li></ul><p>特色: </p><ul><li><code>chan</code></li></ul><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> slice1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">10</span>)    <span class="comment">// 预留了10字节内存</span></span><br><span class="line">slice1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice2 := slice1[<span class="number">2</span>:]<span class="comment">// [3]</span></span><br><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;         <span class="comment">// 空接口接一切</span></span><br><span class="line">any = slice2<span class="comment">// [3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">var</span> mp <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">mp[<span class="string">"a"</span>] = <span class="string">"诶"</span></span><br><span class="line">mp[<span class="string">"b"</span>] = <span class="string">"必"</span></span><br><span class="line"><span class="comment">// 同上 </span></span><br><span class="line">mp := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>: <span class="string">"aaa"</span>, <span class="string">"b"</span>: <span class="string">"bbb"</span>&#125;</span><br><span class="line"><span class="comment">// 这样写得清楚这是干什么的</span></span><br><span class="line"><span class="keyword">var</span> mp <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑处理"><a href="#逻辑处理" class="headerlink" title="逻辑处理"></a>逻辑处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">5</span> ; i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">"输出："</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">1</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式执行 break</span></span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%s."</span>, os)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> human <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式的继承 human 的属性</span></span><br><span class="line"><span class="keyword">type</span> ming <span class="keyword">struct</span> &#123;</span><br><span class="line">human</span><br><span class="line">Skill <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加结构体所属的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h human)</span> <span class="title">Say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"我叫%s,今年%d"</span>, h.Name, h.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> xm ming</span><br><span class="line">xm.Name = <span class="string">"小明"</span></span><br><span class="line">xm.Age = <span class="number">18</span></span><br><span class="line">xm.Skill = <span class="string">"跑得快"</span></span><br><span class="line">fmt.Println(xm)</span><br><span class="line"></span><br><span class="line">xm.Say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h4><blockquote><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。 – <a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">鸭子类型</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Speak() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Woof!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Meow!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PHPProgrammer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHPProgrammer)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"PHP is the best language! "</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PassBy <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;, PHPProgrammer&#123;&#125;&#125;</span><br><span class="line"><span class="comment">// animals[3] = PassBy&#123;&#125;// 编译不会通过, 因为没有实现 Animal 接口</span></span><br><span class="line"><span class="keyword">for</span> _, animal := <span class="keyword">range</span> animals &#123;</span><br><span class="line">fmt.Println(animal.Speak())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/gaopengfei123123/why-go" target="_blank" rel="noopener">demo 代码地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;想换个语言开发的同学可以看这里&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Php开发过程中不常碰到的error (8.14更新)</title>
    <link href="http://blog.justwe.site/2018/08/26/php-unsual-mistakes/"/>
    <id>http://blog.justwe.site/2018/08/26/php-unsual-mistakes/</id>
    <published>2018-08-26T02:30:23.000Z</published>
    <updated>2018-11-07T06:45:51.845Z</updated>
    
    <content type="html"><![CDATA[<p>这里做一些备注,以防再次碰到<br><a id="more"></a></p><h3 id="url-当中的参数有-amp-timestamp-1234567890这样的字段会被转义成xtamp-1234567890"><a href="#url-当中的参数有-amp-timestamp-1234567890这样的字段会被转义成xtamp-1234567890" class="headerlink" title="url 当中的参数有 &amp;timestamp=1234567890这样的字段会被转义成xtamp=1234567890"></a>url 当中的参数有 <code>&amp;timestamp=1234567890</code>这样的字段会被转义成<code>xtamp=1234567890</code></h3><p>这个不仅存在于页面解析当中,当使用 curl 请求时拼接的参数有这种格式的也会发生转义<br>解决方法有两个:</p><ol><li>把 timestamp 这个参数放在 urlQuery 的最前面, <code>?timestamp=1234567890</code> 这样避免出现 <code>&amp;time</code>发生转义的情况</li><li>将<code>&amp;</code>用<code>&amp;amp;</code>来代替</li></ol><h3 id="Automatically-populating-HTTP-RAW-POST-DATA-is-deprecated-and-will-be-removed-in-a-future-version"><a href="#Automatically-populating-HTTP-RAW-POST-DATA-is-deprecated-and-will-be-removed-in-a-future-version" class="headerlink" title="Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version."></a>Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.</h3><p>出现这句话通常说明你在用的 php 版本是5.6.而且在<code>php&lt;=5.6</code>的时候,进行 <code>application/json</code>格式的 post 提交会把数据放在<code>$HTTP_RAW_POST_DATA</code>这个系统变量里面,在<code>php&gt;=7</code>的时候这个变量被移除了,统统归总到<code>php://input</code>这里<br>解决方法:</p><ol><li><p>根据系统提示的走:</p><blockquote><p>Although that indeed would be technically impossible (as $HTTP_RAW_POST_DATA is populated in the bootstrapping phase of the PHP process) allow one to override the setting by means of calling ini_set.</p></blockquote><p> 要确保自己的系统中没有使用 <code>HTTP_RAW_POST_DATA</code>这个变量,直接在<code>php.ini</code>里面禁掉它的设置,但是容易出现系统中又打开的情况(在框架中很常见)</p></li><li>改一下自己的提交方式, 使用 <code>application/form-data</code>或者<code>application/x-www-form-urlencoded</code>这种格式的提交, 然后在后端接收数据的时候再转成自己需要的格式(通常是数组)<br> <a href="https://www.bram.us/2014/10/26/php-5-6-automatically-populating-http_raw_post_data-is-deprecated-and-will-be-removed-in-a-future-version/" target="_blank" rel="noopener">参考资料</a></li></ol><h3 id="Exception-‘yii-db-Exception’-with-message-‘SQLSTATE-HY000-2002-No-such-file-or-directory’"><a href="#Exception-‘yii-db-Exception’-with-message-‘SQLSTATE-HY000-2002-No-such-file-or-directory’" class="headerlink" title="Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’"></a>Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’</h3><p>这种情况出现在平时运行的好好的, 但是突然换 cli 模式后这个配置就出问题了,原因在当 <code>host=localhost</code>时走的是 unix:socket 链接, 当<code>host=127.0.0.1</code>走的是 tcp 链接,这在<code>php-fpm</code>和<code>php-cli</code>中有点区别,尤其是本地没有安装 mysql 的时候<br>解决方法有三种:</p><ol><li>将本地链接配置统一成 <code>127.0.0.1</code></li><li>查看 MySQL 中的<code>user</code>表, <code>host=localhost</code>和<code>host=127.0.0.1</code>是不是用的同一个账号密码</li><li>配置<code>php.ini</code>文件中的<code>pdo_mysql.default_socket=</code> 写上完整的 socket 路径<br>以上三种方法都可以试一下<br><a href="http://www.cnblogs.com/mengdeep/p/7487910.html" target="_blank" rel="noopener">参考资料</a></li></ol><h3 id="常驻内存时发生的事情"><a href="#常驻内存时发生的事情" class="headerlink" title="常驻内存时发生的事情"></a>常驻内存时发生的事情</h3><p>这个是 phper 很少碰到但是很常见的情况, 比如用 swoole 启动了一个常驻进程的服务, 那么就一定要小心使用静态变量,在同步模式下会发生变量污染, 还有就是 redis,mysql 这类的链接,你会发现长时间静置以后就会出现一些摸不着头脑的问题, 这种情况不妨想一下是不是 server 端回收了这个 socket,因此在 client 端怎么都写入不进去.  还有就是 php 在读取消息的时候,出现消息过长的情况,那么就要考虑EOF终止符的问题了… 单次 http 每一次请求都是全新的代码, 不用自己考虑 gc 的问题, 但是在常驻内存的时候,这些就是一个个的大坑了</p><h3 id="mysql-has-gone-away"><a href="#mysql-has-gone-away" class="headerlink" title="mysql has gone away"></a>mysql has gone away</h3><p>产生这个错误的主要原因是 mysql server 端断开了链接, client 端还拿着这个句柄去请求,解决方式有两种:</p><ol><li><p><code>show global variables like &#39;%timeout&#39;;</code> 查看 wait_timeout 的时长,适当的调长一点, 这种方法治标不治本,而且有隐患</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global wait_timeout=10;</span><br><span class="line">mysql&gt; show global variables like <span class="string">'wait_timeout'</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 mysql 之前需要 mysql_ping() 一下, 如果出现断开的错误就启动重连机制</p></li></ol><h3 id="js-和-php-交互传中文参数的编解码问题"><a href="#js-和-php-交互传中文参数的编解码问题" class="headerlink" title="js 和 php 交互传中文参数的编解码问题"></a>js 和 php 交互传中文参数的编解码问题</h3><p>之前碰到了问题是:<br>在 php 端 urlencode 的值为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderid%3D21111111110001954%26pid%3D257742%26reason%3D%E4%B8%AA%E4%BA%BA%E6%96%B9%E9%9D%A2%E5%8E%9F%E5%9B%A0_%E4%BD%BF%E7%94%A8%E7%BA%A2%E5%8C%85%E9%87%8D%E6%96%B0%E4%B8%8B%E5%8D%95%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f</span><br></pre></td></tr></table></figure></p><p>需要 urldecode 一次</p><p>而在 js 端的结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderid%3D21111111110002170%26pid%3D257742%26reason%3D%25E4%25B8%25AA%25E4%25BA%25BA%25E6%2596%25B9%25E9%259D%25A2%25E5%258E%259F%25E5%259B%25A0_%25E4%25B8%25AA%25E4%25BA%25BA%25E8%25BA%25AB%25E4%25BD%2593%25E5%258E%259F%25E5%259B%25A0%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f</span><br></pre></td></tr></table></figure></p><p>需要 urldecode 两次</p><p>查阅资料后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在后端是PHP程序的情况下，保持前端Javascript和PHP之间传值的统一编码可以使用以下函数进行处理：</span><br><span class="line"> </span><br><span class="line">WEB前端JavaScript</span><br><span class="line"> </span><br><span class="line">编码：escape(encodeURI(string))</span><br><span class="line"> </span><br><span class="line">解码：unescape(decodeURI(string))</span><br><span class="line"> </span><br><span class="line">WEB后端Php</span><br><span class="line"> </span><br><span class="line">编码：urlencode(string)</span><br><span class="line"> </span><br><span class="line">解码：urldecode(urldecode(string))</span><br></pre></td></tr></table></figure></p><p><a href="https://bbs.csdn.net/topics/330072196" target="_blank" rel="noopener">为什么要encodeURI(url)两次才不会出现乱码？</a></p><h3 id="PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent-的区别"><a href="#PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent-的区别" class="headerlink" title="PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent 的区别"></a>PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent 的区别</h3><p>rawurlencode遵守是94年国际标准备忘录RFC 1738</p><p>urlencode实现的是传统做法，和上者的主要区别是对空格的转义是’+’而不是’%20’<br>javascript的encodeURL也是94年标准，而javascript的escape是另一种用”%xxx”标记unicode编码的方法。<br>推荐在PHP中使用用rawurlencode。弃用urlencode</p><p>样例<br>source:<br>超级无敌的人sadha sajdh数据样本sdls fhejrthcxzb.file.jpeg </p><p>PHP urlencode:<br>%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha+sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls+fhejrthcxzb.file.jpeg </p><p>PHP rawurlencode:<br>%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg</p><p>Javascript encodeURI|encodeURIComponent:<br>%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg </p><p>Javascript escape:<br>%u8D85%u7EA7%u65E0%u654C%u7684%u4EBAsadha%20sajdh%u6570%u636E%u6837%u672Csdls%20fhejrthcxzb.file.jpeg</p><p><a href="https://blog.csdn.net/suofiya2008/article/details/6397168" target="_blank" rel="noopener">帖子原文</a></p><p>在前端还有个问题就是, js 的 <code>encodeURIComponent</code> 和 <code>encodeURI</code> 都不会转换 <code>_-.!~*&#39;()#</code> 这些保留字符, 而在后端的<code>rawurlencode</code> 则是会转换的, 因此需要前端单独把这几个给拎出来, 如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"*"</span>.charCodeAt(<span class="number">0</span>) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">42</span>) <span class="comment">// *</span></span><br></pre></td></tr></table></figure></p><p>这里有张图说的很明白<br><img src="http://blog-image.onlyoneip.com/urlencode.jpeg" alt=""><br><a href="https://www.zhihu.com/question/21861899/answer/91279362" target="_blank" rel="noopener">图片来源</a></p><h3 id="关于出现-lt-U-200B-gt-这种-zero-width-space-字符"><a href="#关于出现-lt-U-200B-gt-这种-zero-width-space-字符" class="headerlink" title="关于出现 &lt;U+200B&gt; 这种 zero-width space 字符"></a>关于出现 &lt;U+200B&gt; 这种 zero-width space 字符</h3><p>如果出现 <code>mb_substr</code> 这类操作的时候, 会出现字数判断错误的问题, 这个有时候很难排查, 因为在 win 上,使用命令行或者 linux 上用<code>cat</code>命令是看不到字符间是有 &lt;U+200B&gt; 的, 如下:<br><img src="http://blog-image.onlyoneip.com/zero-width%20space.png" alt=""></p><p>这玩意儿出现的场景就是: 在前端输入框中输入几个字, 然后复制粘贴.  这样尽管看起来之间没有空格, 但是其中还是插入了这个字符<br>这玩意就叫 <a href="https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%AE%BD%E7%A9%BA%E6%A0%BC" target="_blank" rel="noopener">zero-width space 零宽空格</a>, 处理的办法也很简单, 前端传值之前给过滤一下, 比如 <a href="https://stackoverflow.com/questions/7055600/u200b-zero-width-space-characters-in-my-js-code-where-did-they-come-from" target="_blank" rel="noopener">https://stackoverflow.com/questions/7055600/u200b-zero-width-space-characters-in-my-js-code-where-did-they-come-from</a> 或 <a href="https://codeday.me/bug/20171122/97765.html" target="_blank" rel="noopener">https://codeday.me/bug/20171122/97765.html</a></p><p>后端 php 处理的话和这个不一样, 使用 utf-8 的处理方式, 可以参考这篇文章 <a href="https://blog.csdn.net/qq_28018283/article/details/54136480" target="_blank" rel="noopener">特殊字符<200b><200c><200d>的删除办法与原理</200d></200c></200b></a></p><p>替换这种编码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$value = str_replace(<span class="string">"\xe2\x80\x8b"</span>, <span class="string">''</span>, $value);</span><br><span class="line">$value = str_replace(<span class="string">"\xe2\x80\x8c"</span>, <span class="string">''</span>, $value);</span><br><span class="line">$value = str_replace(<span class="string">"\xe2\x80\x8d"</span>, <span class="string">''</span>, $value);</span><br></pre></td></tr></table></figure></p><p>编码对照如下:<br><img src="http://blog-image.onlyoneip.com/zero-width-space-2.png" alt=""></p><h3 id="mac-设置crontab-e-：-“-usr-bin-vi”-exited-with-status-1"><a href="#mac-设置crontab-e-：-“-usr-bin-vi”-exited-with-status-1" class="headerlink" title="mac 设置crontab -e ： “/usr/bin/vi” exited with status 1"></a>mac 设置crontab -e ： “/usr/bin/vi” exited with status 1</h3><p>输入以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> EDITOR=vim</span><br><span class="line">sudo touch /etc/crontab</span><br><span class="line">crontab -e</span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure></p><p>把默认编辑器从 vi 改成 vim</p><p><a href="https://segmentfault.com/a/1190000013774374" target="_blank" rel="noopener">原文</a></p><h3 id="出现-The-“https-bower-herokuapp-com-packages-jquery-quot-file-could-not-be-downloaded-HTTP-1-1-502-Bad-Gateway"><a href="#出现-The-“https-bower-herokuapp-com-packages-jquery-quot-file-could-not-be-downloaded-HTTP-1-1-502-Bad-Gateway" class="headerlink" title="出现: The “https://bower.herokuapp.com/packages/jquery&quot; file could not be downloaded (HTTP/1.1 502 Bad Gateway)"></a>出现: The “<a href="https://bower.herokuapp.com/packages/jquery&quot;" target="_blank" rel="noopener">https://bower.herokuapp.com/packages/jquery&quot;</a> file could not be downloaded (HTTP/1.1 502 Bad Gateway)</h3><p>yii2 更新的时候静态资源出现问题, 执行 <code>composer global require &quot;fxp/composer-asset-plugin:~1.4.4&quot;</code></p><p><a href="https://stackoverflow.com/questions/51441090/yii2-bower-error-heroku" target="_blank" rel="noopener">问题来源</a></p><h3 id="出现-Jquery-UI-1-11-4-and-jquery-3-0-的版本兼容问题"><a href="#出现-Jquery-UI-1-11-4-and-jquery-3-0-的版本兼容问题" class="headerlink" title="出现: Jquery UI 1.11.4 and jquery 3.0 的版本兼容问题"></a>出现: Jquery UI 1.11.4 and jquery 3.0 的版本兼容问题</h3><p>这个是在部署 adminLTE + rbac 时候遇上的, 打开 <code>/admin/menu/create</code> 会报 <code>Jquery UI error - f.getClientRects is not a function</code> 错误</p><p>解决方法:<br>配置文件: config/web.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="string">'components'</span> =&gt; [</span><br><span class="line">     ...</span><br><span class="line">        <span class="comment">//静态资源</span></span><br><span class="line">        <span class="string">'assetManager'</span> =&gt; [</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">'assetMap'</span> =&gt; [</span><br><span class="line">                <span class="string">'jquery.js'</span> =&gt; <span class="string">'https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js'</span>, <span class="comment">// </span></span><br><span class="line">                <span class="string">'jquery.min.js'</span> =&gt; <span class="string">'https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js'</span>,</span><br><span class="line"><span class="comment">//                'jquery.js' =&gt; '@web/js/jquery/jquery.js',</span></span><br><span class="line"><span class="comment">//                'jquery.min.js' =&gt; '@web/js/jquery/jquery.js',</span></span><br><span class="line">            ],</span><br><span class="line">            ...</span><br><span class="line">        ],</span><br><span class="line">    ...</span><br><span class="line"> ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>把相应的 jquery 替换成 <code>v2.2.4</code> 解决<br><a href="https://stackoverflow.com/questions/37914869/jquery-ui-error-f-getclientrects-is-not-a-function" target="_blank" rel="noopener">问题来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里做一些备注,以防再次碰到&lt;br&gt;
    
    </summary>
    
      <category term="php" scheme="http://blog.justwe.site/categories/php/"/>
    
    
      <category term="php" scheme="http://blog.justwe.site/tags/php/"/>
    
      <category term="debug" scheme="http://blog.justwe.site/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>通过 Docker-Compose 搭建一个 Elk</title>
    <link href="http://blog.justwe.site/2018/08/20/docker-elk/"/>
    <id>http://blog.justwe.site/2018/08/20/docker-elk/</id>
    <published>2018-08-20T06:57:47.000Z</published>
    <updated>2018-08-21T06:24:52.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>找了不少使用 docker-elk 搭建的博客, 英文的阅读吃力不说, 镜像源也是慢的让人头皮发麻, 因此重新编排了一个<code>docker-compose</code>,源都是从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 上找的, 即使拉的国内镜像源应该也能很好的支持了吧?</p></blockquote><a id="more"></a><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Docker          <code>18.06.0-ce</code></li><li>docker-compose  <code>1.22.0</code><br>给每个容器最少分配 1G 的内存</li></ul><h3 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h3><ul><li>logstash:         <code>5.*</code></li><li>elasticsearch:    <code>5.*</code></li><li>kibana:           <code>5.*</code></li></ul><h3 id="启动前的配置"><a href="#启动前的配置" class="headerlink" title="启动前的配置"></a>启动前的配置</h3><p>在各个目录下都有对应的 config 配置, 根据各自的情况自行处理</p><p>拿默认的 logstash/confg/test.conf 中的配置举例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">      file &#123;</span><br><span class="line">          <span class="comment">#这里的路径指的是 logstash 容器中的路径, 外部接入需要使用 volume 进行目录映射 </span></span><br><span class="line">            path =&gt; <span class="string">"/logs/input/*"</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在 logstash 容器中的输入</span></span><br><span class="line">      stdin &#123;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 因为做了本地5000端口和容器5000端口进行绑定, 所以可以用 nc 工具测试一下</span></span><br><span class="line">      <span class="comment"># echo "Test Logstash TCP Input Plugin" | nc localhost 5000</span></span><br><span class="line">      tcp &#123;</span><br><span class="line">            <span class="built_in">type</span> =&gt; <span class="string">"tcp"</span></span><br><span class="line">            port =&gt; 5000</span><br><span class="line">            mode =&gt; <span class="string">"server"</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">      file &#123;</span><br><span class="line">          <span class="comment">#这里的路径指的是 logstash 容器中的路径, 外部接入需要使用 volume 进行目录映射</span></span><br><span class="line">            path =&gt; <span class="string">"/logs/output/%&#123;+yyyy-MM-dd-HH&#125;/%&#123;host&#125;.log"</span></span><br><span class="line">      &#125;</span><br><span class="line">      stdout &#123;</span><br><span class="line">            codec =&gt; rubydebug</span><br><span class="line">      &#125;</span><br><span class="line">      elasticsearch &#123;</span><br><span class="line">    hosts =&gt; <span class="string">"elasticsearch:9200"</span></span><br><span class="line">        <span class="comment"># 这里设置的 index 在 kibana 中会用到</span></span><br><span class="line">            index =&gt; <span class="string">"file-log-%&#123;+YYYY.MM&#125;"</span>  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/gaopengfei123123/docker-elk.git &amp;&amp; cd docker-elk</span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure></p><p>等一会看到执行成功的提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Creating docker-elk_elasticsearch_1 ... done</span><br><span class="line">Creating docker-elk_logstash_1      ... done</span><br><span class="line">Creating docker-elk_kibana_1        ... done</span><br></pre></td></tr></table></figure></p><p>在本地浏览器输入 <code>http://localhost:5601/</code> 进入 kibana 界面</p><p><strong>注意</strong>, 第一次启动时有可能会出现提示 <code>elasticsearch not found</code> 这类的问题, 可以先等个一两分钟刷新一下就好了, 如果还是不行就谷歌或者提 issue 解决一下</p><p>同目录下输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure></p><p>则停止所有服务</p><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>在 <code>logs/input/</code> 目录下新增个 test.log 文件, 然后输入点东西验证一下, 或者命令行执行<code>echo &quot;Test Logstash TCP Input Plugin&quot; | nc localhost 5000</code> 通过 tcp 发送日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><p>查看各容器日志输出</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li>引入 kafka 做缓冲 </li><li>搭建 es 集群</li></ul><p><a href="https://github.com/gaopengfei123123/docker-elk" target="_blank" rel="noopener">github 地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;找了不少使用 docker-elk 搭建的博客, 英文的阅读吃力不说, 镜像源也是慢的让人头皮发麻, 因此重新编排了一个&lt;code&gt;docker-compose&lt;/code&gt;,源都是从 &lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hub.docker.com/&lt;/a&gt; 上找的, 即使拉的国内镜像源应该也能很好的支持了吧?&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="docker" scheme="http://blog.justwe.site/categories/docker/"/>
    
    
      <category term="docker" scheme="http://blog.justwe.site/tags/docker/"/>
    
      <category term="elk" scheme="http://blog.justwe.site/tags/elk/"/>
    
  </entry>
  
  <entry>
    <title>搞定 Git 合并冲突</title>
    <link href="http://blog.justwe.site/2018/08/03/git-merge-conflict/"/>
    <id>http://blog.justwe.site/2018/08/03/git-merge-conflict/</id>
    <published>2018-08-03T10:40:25.000Z</published>
    <updated>2018-08-03T11:03:18.903Z</updated>
    
    <content type="html"><![CDATA[<p>这次说一下通过命令行去批量解决文件冲突的问题, 这个方法适用你清楚的知道自己需要保留哪一个分支, 而不是两个分支里的改动都要一点<br><a id="more"></a></p><h2 id="关键命令"><a href="#关键命令" class="headerlink" title="关键命令"></a>关键命令</h2><p>checkout 是个好方法, 能粗暴的解决很多问题</p><p>针对冲突文件保留自己的分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --ours path/to/conflict_file</span><br></pre></td></tr></table></figure></p><p>想保留别人的分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --theirs path/to/conflict_file</span><br></pre></td></tr></table></figure></p><p>批量的解决:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -lr <span class="string">'&lt;&lt;&lt;&lt;&lt;&lt;&lt;'</span> . | xargs git checkout --ours</span><br></pre></td></tr></table></figure><h2 id="一个鲜活的例子…"><a href="#一个鲜活的例子…" class="headerlink" title="一个鲜活的例子…"></a>一个鲜活的例子…</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> mkdir merge-demo</span><br><span class="line">➜  <span class="built_in">test</span> <span class="built_in">cd</span> merge-demo</span><br><span class="line">➜  merge-demo ls</span><br><span class="line">➜  merge-demo <span class="built_in">echo</span> <span class="string">'first commit'</span> &gt; index.txt</span><br><span class="line">➜  merge-demo cat index.txt</span><br><span class="line">first commit</span><br><span class="line">➜  merge-demo git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/gpf/Documents/<span class="built_in">test</span>/merge-demo/.git/</span><br><span class="line">➜  merge-demo git:(master) ✗ git add -A</span><br><span class="line">➜  merge-demo git:(master) ✗ git commit -m <span class="string">'init'</span></span><br><span class="line">[master (root-commit) e9f17b3] init</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 index.txt</span><br><span class="line">➜  merge-demo git:(master) git checkout -b <span class="built_in">test</span></span><br><span class="line">Switched to a new branch <span class="string">'test'</span></span><br><span class="line">➜  merge-demo git:(<span class="built_in">test</span>) <span class="built_in">echo</span> <span class="string">'second commit by test'</span> &gt; index.txt</span><br><span class="line">➜  merge-demo git:(<span class="built_in">test</span>) ✗ git add -A &amp;&amp; git commit -m <span class="string">'second commit'</span></span><br><span class="line">[<span class="built_in">test</span> 4d20ff3] second commit</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">➜  merge-demo git:(<span class="built_in">test</span>) cat index.txt</span><br><span class="line">second commit by <span class="built_in">test</span></span><br><span class="line">➜  merge-demo git:(<span class="built_in">test</span>) git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">➜  merge-demo git:(master) <span class="built_in">echo</span> <span class="string">'third commit by master'</span> &gt; index.txt</span><br><span class="line">➜  merge-demo git:(master) ✗ git add -A &amp;&amp; git commit -m <span class="string">'third commit'</span></span><br><span class="line">[master 85e520e] third commit</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">➜  merge-demo git:(master) git merge <span class="built_in">test</span></span><br><span class="line">Auto-merging index.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> index.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line">➜  merge-demo git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   index.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">➜  merge-demo git:(master) ✗ cat index.txt</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">third commit by master</span><br><span class="line">=======</span><br><span class="line">second commit by <span class="built_in">test</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">➜  merge-demo git:(master) ✗ git checkout --ours index.txt</span><br><span class="line">➜  merge-demo git:(master) ✗ cat index.txt</span><br><span class="line">third commit by master</span><br><span class="line">➜  merge-demo git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   index.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">➜  merge-demo git:(master) ✗ git add -A &amp;&amp; git commit -m <span class="string">'done'</span></span><br><span class="line">[master d2d2057] <span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次说一下通过命令行去批量解决文件冲突的问题, 这个方法适用你清楚的知道自己需要保留哪一个分支, 而不是两个分支里的改动都要一点&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.justwe.site/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.justwe.site/tags/git/"/>
    
      <category term="merge-conflict" scheme="http://blog.justwe.site/tags/merge-conflict/"/>
    
  </entry>
  
  <entry>
    <title>不正宗 Docker 入门教程-使用 Docker-Compose (3/3)</title>
    <link href="http://blog.justwe.site/2018/07/20/docker-step-3/"/>
    <id>http://blog.justwe.site/2018/07/20/docker-step-3/</id>
    <published>2018-07-20T03:11:07.000Z</published>
    <updated>2018-07-20T05:46:43.453Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章通过一个具体的demo来了解 docker-compose</p></blockquote><a id="more"></a><h4 id="docker-compose-是做什么的"><a href="#docker-compose-是做什么的" class="headerlink" title="docker-compose 是做什么的"></a>docker-compose 是做什么的</h4><p>在构建一个完整的服务时，我们通常启动一个容器， 一旦出现多个容器需要同时启动的时候手打是下下之策， 因为时间一长难免会忘记细节，写脚本也不是不可以，但是大家没有达成共识时脚本也很难维护…</p><p><code>docker-compose</code> 就是来解决这个痛点， 只需要按照统一的格式书写，那么大家生成的容器也都是一致的， 在团队开发的时候扔一个配置好的   <code>docker-compose</code> 能节省很多时间和口水</p><h4 id="配置-docker-compose"><a href="#配置-docker-compose" class="headerlink" title="配置 docker-compose"></a>配置 docker-compose</h4><p>这是我构建的一个开发环境的容器:<a href="https://github.com/gaopengfei123123/dnmp" target="_blank" rel="noopener">dnmp</a></p><p>首先下载下来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gaopengfei123123/dnmp.git &amp;&amp; <span class="built_in">cd</span> dnmp</span><br></pre></td></tr></table></figure></p><p>我们第一件事就是先瞄一眼 <code>.env</code> 文件， 这里设置了很多常量，一会根据个人需求来调整</p><p>第二步才是打开 <code>docker-compose.yml</code> 文件， 看后缀都能猜到这是一个配置文件， 另外 <code>docker-compose.yml</code> <strong>是根据缩进来进行分层的，注意书写格式</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="comment"># 语法版本( 3 和 2 区别有点大, 比如 3 取消了 volume_from 的相关语法)</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  frontend:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;NETWORKS_DRIVER&#125;</span></span><br><span class="line"><span class="attr">  backend:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;NETWORKS_DRIVER&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  mysql_volume:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;VOLUMES_DRIVER&#125;</span></span><br><span class="line"><span class="attr">  redis_volume:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;VOLUMES_DRIVER&#125;</span></span><br><span class="line"><span class="attr">  rabbitmq_volume:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;VOLUMES_DRIVER&#125;</span></span><br><span class="line"><span class="comment"># 服务编排</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># workspace:</span></span><br><span class="line">  <span class="comment">#   image: tianon/true</span></span><br><span class="line">  <span class="comment">#   container_name: dnmp-www</span></span><br><span class="line">  <span class="comment">#   volumes:</span></span><br><span class="line">  <span class="comment">#     - ./www:/usr/share/nginx/html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NGINX #############################################</span></span><br><span class="line"><span class="attr">  nginx:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">dnmp-nginx</span></span><br><span class="line"><span class="attr">    build:</span> </span><br><span class="line"><span class="attr">      context:</span> <span class="string">./nginx</span></span><br><span class="line"><span class="attr">      args:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">PHP_UPSTREAM_CONTAINER=$&#123;NGINX_PHP_UPSTREAM_CONTAINER&#125;</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">PHP_UPSTREAM_PORT=$&#123;NGINX_PHP_UPSTREAM_PORT&#125;</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">php-fpm</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"$&#123;NGINX_HOST_HTTP_PORT&#125;:80"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"$&#123;NGINX_HOST_HTTPS_PORT&#125;:443"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">      <span class="comment"># 没必要把配置文件用卷来挂载, 不然就算配置更新了 nginx 也是要重启的</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 挂载运行代码目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$&#123;APP_CODE_PATH_HOST&#125;:/var/www</span></span><br><span class="line">      <span class="comment"># 挂载日志目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$&#123;NGINX_HOST_LOG_PATH&#125;:/var/log/nginx</span></span><br><span class="line">    <span class="comment"># 使用 networks 取代 links 在同一个网络模式下的服务是互通的</span></span><br><span class="line">    <span class="comment"># 在service 中使用其他的 service 就直接调用 service 名就行, 不用管 ip 地址, docker 会自己维护一套</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">frontend</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">backend</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># PHP-FPM #############################################</span></span><br><span class="line"><span class="attr">  php-fpm:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">dnmp-php-fpm</span></span><br><span class="line">    <span class="comment"># 这里的args 是属于 build 下面的,用于构建./php-fpm/Dockerfile 文件中 ARG 参数指定 php 版本</span></span><br><span class="line"><span class="attr">    build:</span> </span><br><span class="line"><span class="attr">      context:</span> <span class="string">./php-fpm</span></span><br><span class="line"><span class="attr">      args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">PHP_VERSION=$&#123;PHP_VERSION&#125;</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$&#123;APP_CODE_PATH_HOST&#125;:/var/www</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./php-fpm/php$&#123;PHP_VERSION&#125;.ini:/usr/local/etc/php/php.ini</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9000"</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">backend</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">dnmp-redis</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./redis</span></span><br><span class="line"><span class="attr">      args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">REDIS_SET_PASSWORD=$&#123;REDIS_SET_PASSWORD&#125;</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$&#123;REDIS_HOST_PORT&#125;:6379</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">      <span class="comment"># 这里卷挂载的是本地文件</span></span><br><span class="line">      <span class="comment"># - $&#123;DATA_PATH_HOST&#125;/redis:/data</span></span><br><span class="line">      <span class="comment"># 这里创建一个 redis_volume来存放数据</span></span><br><span class="line"><span class="attr">      - redis_volume:</span><span class="string">/data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mysql #############################################</span></span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">dnmp-mysql</span></span><br><span class="line">    <span class="comment"># 镜像来源: https://github.com/docker-library/mysql/blob/fc3e856313423dc2d6a8d74cfd6b678582090fc7/5.7/Dockerfile</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mysql:$&#123;MYSQL_VERSION&#125;</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">      <span class="comment"># - $&#123;DATA_PATH_HOST&#125;/mysql:/var/lib/mysql</span></span><br><span class="line"><span class="attr">      - mysql_volume:</span><span class="string">/var/lib/mysql</span></span><br><span class="line">    <span class="comment"># 容器只要停止就会重启</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    environment:</span> </span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line"><span class="attr">      MYSQL_DATABASE:</span> <span class="string">$&#123;MYSQL_DATABASE&#125;</span></span><br><span class="line"><span class="attr">      MYSQL_USER:</span> <span class="string">$&#123;MYSQL_USER&#125;</span></span><br><span class="line"><span class="attr">      MYSQL_PASSWORD:</span> <span class="string">$&#123;MYSQL_PASSWORD&#125;</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$&#123;MYSQL_HOST_PORT&#125;:3306</span></span><br></pre></td></tr></table></figure><p>接下来看看它的关键词都起着什么作用：</p><h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p>这个规定了文件的版本， 既然有 3 就肯定不用 2 啊， 虽然两者没冲突，但是我喜欢， 2 和 3 版本之间有轻微的变动，具体区别你可以在写配置文件时产生的报错信息来体验一下</p><h5 id="network"><a href="#network" class="headerlink" title="network"></a>network</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  frontend:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;NETWORKS_DRIVER&#125;</span></span><br><span class="line"><span class="attr">  backend:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;NETWORKS_DRIVER&#125;</span></span><br></pre></td></tr></table></figure><p><code>${NETWORKS_DRIVER}</code> 是从 <code>.env</code> 文件中取的值， 下面的同理</p><p>这一块就相当于执行 <code>docker network create -d bridge frontend &amp;&amp; docker network create -d bridge backend</code><br>在本地持久化的建立一个网络配置，稍后方便容器进行连接， 当然这里也不止是一个 <code>driver</code> 参数，具体配置情况还是参考<code>docker network inspect dnmp_frontend</code> 来看一下</p><p>没有设置名字的配置当需要名字的时候会 <code>{当前docker-compose.yml文件名}_{key}</code> 这种格式</p><p>有了 <code>network</code> 配置就极大的简化了老版的 <code>--links</code> 命令， 只要属于同一个 network 就能互相访问到， 而不是每新增一个服务就要把原来的服务都 link 一遍 </p><h5 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  mysql_volume:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;VOLUMES_DRIVER&#125;</span></span><br><span class="line"><span class="attr">  redis_volume:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;VOLUMES_DRIVER&#125;</span></span><br><span class="line"><span class="attr">  rabbitmq_volume:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">$&#123;VOLUMES_DRIVER&#125;</span></span><br></pre></td></tr></table></figure><p>和 <code>network</code> 部分一样， 持久化的创建几个 <code>volume</code>, 相当于命令 <code>docker network create mysql_volume</code>等等</p><p>这算是 v3 的一个新特性， 在 v2 的时候， 为了共享数据大家会创建一个什么镜像都不继承的image， 所有容器的 volume 都会和它连接， 现在有了 <code>volume</code> 就没必要这么搞了</p><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><p>这个是本章的重点， 我们来看下面的例子中的注释， 按序号来<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#1 创建一个服务叫做nginx服务</span></span><br><span class="line"><span class="attr">  nginx:</span></span><br><span class="line">    <span class="comment">#2 为了显得个性化一点，我们指定这个容器的名字叫做 dnmp-nginx</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">dnmp-nginx</span></span><br><span class="line">    <span class="comment">#3 标明这个服务的 Dockerfile 的地址，用相对路径方便项目迁移</span></span><br><span class="line"><span class="attr">    build:</span> </span><br><span class="line">      <span class="comment">#3.1 相当于命令： </span></span><br><span class="line">      <span class="comment"># docker build ./nginx -t dnmp-nginx \</span></span><br><span class="line">      <span class="comment">#     --build-arg PHP_UPSTREAM_CONTAINER=xxx \</span></span><br><span class="line">      <span class="comment">#     --build-arg PHP_UPSTREAM_PORT=zzz</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./nginx</span></span><br><span class="line">      <span class="comment">#3.2 这里 $&#123;NGINX_PHP_UPSTREAM_PORT&#125; 的值是从 .env 文件中取的， args 属于构建时传入的参数</span></span><br><span class="line"><span class="attr">      args:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">PHP_UPSTREAM_CONTAINER=$&#123;NGINX_PHP_UPSTREAM_CONTAINER&#125;</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">PHP_UPSTREAM_PORT=$&#123;NGINX_PHP_UPSTREAM_PORT&#125;</span></span><br><span class="line">    <span class="comment">#4  在启动这个容器之前先启动 php-fpm 这个容器 </span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">php-fpm</span></span><br><span class="line">    <span class="comment">#5 将本地端口和容器端口绑定， 本地哪个端口就看 .env 里怎么写的</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"$&#123;NGINX_HOST_HTTP_PORT&#125;:80"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"$&#123;NGINX_HOST_HTTPS_PORT&#125;:443"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#6 设置需要挂载的卷, 这里时将本地目录和容器绑定， 也可以像 services.redis 那样和创建好的卷绑定 </span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">      <span class="comment"># 没必要把配置文件用卷来挂载, 不然就算配置更新了 nginx 也是要重启的</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 挂载运行代码目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$&#123;APP_CODE_PATH_HOST&#125;:/var/www</span></span><br><span class="line">      <span class="comment"># 挂载日志目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$&#123;NGINX_HOST_LOG_PATH&#125;:/var/log/nginx</span></span><br><span class="line">    <span class="comment"># 使用 networks 取代 links 在同一个网络模式下的服务是互通的</span></span><br><span class="line">    <span class="comment"># 在service 中使用其他的 service 就直接调用 service 名就行, 不用管 ip 地址, docker 会自己维护一套</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#7 设置容器从属的网络， 同一个网络下可互相访问</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">frontend</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">backend</span></span><br></pre></td></tr></table></figure></p><p>在上文的 <code>#3</code> 步骤看其他的service也有直接使用<code>image</code>的， 这是直接从远程获取镜像的方式</p><p>配置文件写完了， 我们看下nginx的构建文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in file ./nginx/Dockerfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1 选择继承的镜像</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.13</span>.<span class="number">1</span>-alpine</span><br><span class="line"><span class="comment">#2 各种标签</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"GPF &lt;5173180@qq.com&gt;"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#3 容器中执行命令， 且把本地的配置文件添加进去</span></span></span><br><span class="line"><span class="bash"><span class="comment">#https://yeasy.gitbooks.io/docker_practice/content/image/build.html</span></span></span><br><span class="line"><span class="bash">RUN mkdir -p /etc/nginx/cert \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /etc/nginx/conf.d \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /etc/nginx/sites</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY ./nginx.conf /etc/ngixn/nginx.conf</span></span><br><span class="line"><span class="bash">COPY ./conf.d/ /etc/nginx/conf.d/</span></span><br><span class="line"><span class="bash">COPY ./cert/ /etc/nginx/cert/</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY ./sites /etc/nginx/sites/</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#4 这里也是设置构建参数， 不过相同 key 值会被 docker-compose 中的给覆盖掉</span></span></span><br><span class="line"><span class="bash">ARG PHP_UPSTREAM_CONTAINER=php-fpm</span></span><br><span class="line"><span class="bash">ARG PHP_UPSTREAM_PORT=9000</span></span><br><span class="line"><span class="bash"><span class="comment">#5 $&#123;PHP_UPSTREAM_CONTAINER&#125; 就在构建时的参数使用方式</span></span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"upstream php-upstream &#123; server <span class="variable">$&#123;PHP_UPSTREAM_CONTAINER&#125;</span>:<span class="variable">$&#123;PHP_UPSTREAM_PORT&#125;</span>; &#125;"</span> &gt; /etc/nginx/conf.d/upstream.conf</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#6 设置挂载的目录， 该目录下文件变化不会影响到容器</span></span></span><br><span class="line"><span class="bash">VOLUME [<span class="string">"/var/log/nginx"</span>, <span class="string">"/var/www"</span>]</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#7 设置目录运行时所处在容器中的目录地址</span></span></span><br><span class="line"><span class="bash">WORKDIR /usr/share/nginx/html</span></span><br></pre></td></tr></table></figure><p><code>#5</code> 就是显示了在 nginx 容器中怎么去访问 php-fpm 这个容器, 直接调用 service 名称就行</p><p>这里需要注意的时 <code>ARG</code> 和 <code>ENV</code> 的区别， 参考这篇文章： <a href="http://blog.justwe.site/2018/06/28/docker-arg-env/">Docker中 Arg 和 Env 的区别</a></p><h4 id="启动docker-compse"><a href="#启动docker-compse" class="headerlink" title="启动docker-compse"></a>启动docker-compse</h4><p>在配置好 <code>.env</code> 文件和 <code>docker-compose.yml</code> 配置文件后就可以启动它了， 命令也很简单，在同级目录下运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p><p>它会自动创建<code>volume</code>，<code>network</code>，<code>services</code>， 而且相关的运行参数都是按着配置文件来的， 这样一来每个完整<code>docker-compose.yml</code>中的service就相当于时一个整体，每个服务又属于各自的容器，这样操控是不是节省了很多代码呢？</p><p>查看这些容器的运行状况也很是简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br><span class="line"><span class="comment"># 或者使用更方便的一个工具： ctop ， github地址： https://github.com/bcicen/ctop</span></span><br></pre></td></tr></table></figure><p>可操控单一容器一样， 但是它会把这一组容器都囊括了进去，操控起来只需要知道操控哪个服务，而一些参数就写在配置文件当中已经默认添加了</p><p>一些常用的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终止整个服务集合</span></span><br><span class="line">docker-compose stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止指定的服务 （这有个点就是启动的时候会先启动 depond_on 中的容器，关闭的时候不会影响到 depond_on 中的）</span></span><br><span class="line">docker-compose stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器的输出日志</span></span><br><span class="line">docker-compose logs -f [services...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建镜像时不使用缓存（能避免很多因为缓存造成的问题）</span></span><br><span class="line">docker-compose build --no-cache --force-rm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定的容器</span></span><br><span class="line">docker-compose rm nginx</span><br></pre></td></tr></table></figure></p><blockquote><p>本来熟悉命令的最好方式就是 用-&gt;犯错-&gt;排错-&gt;用 这种循环, 有什么不懂的 谷歌bing 都能查到, 直接 <code>docker-compose --help</code> 也能猜出命令的大概作用, 这里就不细说了 </p></blockquote><p>还有个很不错的 docker-compose 项目就是 <a href="http://laradock.io/" target="_blank" rel="noopener">laradock</a>, dnmp 就是仿照着它写的， 不过网络不好的情况下别运行 laradock， 它现在做的太臃肿了。。。。 看看它里面的镜像是怎么写的还是很有收获的</p><h4 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h4><ol><li><a href="http://blog.justwe.site/2018/07/06/docker-step-1/">不正宗 Docker 入门教程-启动一个容器(1/3)</a></li><li><a href="http://blog.justwe.site/2018/07/08/docker-step-2/">不正宗 Docker 入门教程-构建一个镜像(2/3)</a></li><li><a href="http://blog.justwe.site/2018/07/20/docker-step-3/">不正宗 Docker 入门教程-使用 Docker-Compose (3/3)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章通过一个具体的demo来了解 docker-compose&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="docker入门" scheme="http://blog.justwe.site/tags/docker%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>不正宗 Docker 入门教程-构建一个镜像(2/3)</title>
    <link href="http://blog.justwe.site/2018/07/08/docker-step-2/"/>
    <id>http://blog.justwe.site/2018/07/08/docker-step-2/</id>
    <published>2018-07-08T14:54:58.000Z</published>
    <updated>2018-07-20T06:19:58.048Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章讲的大概能让你明白虚拟机和 docker 的区别…</p></blockquote><a id="more"></a><p>docker 设置了两种构建镜像的方式:</p><h3 id="通过-docker-commit-构建镜像-不推荐"><a href="#通过-docker-commit-构建镜像-不推荐" class="headerlink" title="通过 docker commit 构建镜像(不推荐)"></a>通过 docker commit 构建镜像(不推荐)</h3><p>这个命令是将先有的容器制作成镜像, 不过建议仅用在排查问题的时候使用, 平时生成容器时最好不要用这种镜像, 因为不知道里面有什么改动, 对于开发者来说完全是一个黑盒</p><p>命令格式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [参数] &lt;容器 ID 或 容器名&gt; [仓库名[:标签]] [flags]</span><br></pre></td></tr></table></figure></p><p>比如(我随便找了一个本地容器 ID):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker commit -m <span class="string">"这是一个测试镜像"</span> -a <span class="string">"GPF"</span> 5ad06ec670eb local_nginx:v1</span><br><span class="line">sha256:134e09cdce58842dea03202aa5b6516ead8268afe78d2203be8595b4f0bc5ebe</span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY              TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">local_nginx             v1                     134e09cdce58        2 seconds ago       109MB</span><br></pre></td></tr></table></figure></p><p>这就把当前的容器转换成了镜像, 提交到远程就是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push local_nginx:v1</span><br></pre></td></tr></table></figure></p><p>和<code>git</code>很像对不对?   不过推送到远程时需要有个 <a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener">dockerhub</a> 的账号</p><p><code>docker history</code> 命令可以查看镜像的构建记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker <span class="built_in">history</span> 134e09cdce58</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">134e09cdce58        12 seconds ago      nginx -g daemon off;                            0B                  这是一个测试镜像</span><br><span class="line">649dcb69b782        4 days ago          /bin/sh -c <span class="comment">#(nop)  CMD ["nginx" "-g" "daemon…   0B</span></span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c <span class="comment">#(nop)  STOPSIGNAL [SIGTERM]         0B</span></span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c <span class="comment">#(nop)  EXPOSE 80/tcp                0B</span></span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c ln -sf /dev/stdout /var/<span class="built_in">log</span>/nginx…   22B</span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c <span class="built_in">set</span> -x  &amp;&amp; apt-get update  &amp;&amp; apt…   53.7MB</span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c <span class="comment">#(nop)  ENV NJS_VERSION=1.15.1.0.…   0B</span></span><br><span class="line">&lt;missing&gt;           4 days ago          /bin/sh -c <span class="comment">#(nop)  ENV NGINX_VERSION=1.15.1-…   0B</span></span><br><span class="line">&lt;missing&gt;           11 days ago         /bin/sh -c <span class="comment">#(nop)  LABEL maintainer=NGINX Do…   0B</span></span><br><span class="line">&lt;missing&gt;           11 days ago         /bin/sh -c <span class="comment">#(nop)  CMD ["bash"]                 0B</span></span><br><span class="line">&lt;missing&gt;           11 days ago         /bin/sh -c <span class="comment">#(nop) ADD file:28fbc9fd012eef727…   55.3MB</span></span><br></pre></td></tr></table></figure></p><h3 id="通过-Dockerfile-构建镜像"><a href="#通过-Dockerfile-构建镜像" class="headerlink" title="通过 Dockerfile 构建镜像"></a>通过 Dockerfile 构建镜像</h3><p>一个 Dockerfile 就是一个构建镜像的脚本, 常用的几个命令也不多, 也就<code>FROM</code>, <code>COPY</code>, <code>RUN</code>, <code>ADD</code>, <code>ARG</code>, <code>ENV</code>, <code>VOLUME</code>, <code>EXPOSE</code>, <code>CMD</code>, <code>LABEL</code>, 其他的一些命令就不再这里说了, 想了解完整的 Dockerfile 的关键词看这个 <a href="https://docs.docker.com/engine/reference/builder/#usage" target="_blank" rel="noopener">Dockerfile reference</a></p><h4 id="一个简单的-demo"><a href="#一个简单的-demo" class="headerlink" title="一个简单的 demo"></a>一个简单的 demo</h4><p>接下来我们就用一个完整的 Dockerfile 来示范一下:</p><p>首先创建一个Dockerfile<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir dockerfile_demo &amp;&amp; <span class="built_in">cd</span> dockerfile_demo</span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dockerfile 内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承的 ubuntu 镜像的版本号</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 将本地 workdir 的文件复制到镜像内部, 另外有个 ADD 指令和这个效果类似, 不过不推荐使用</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./sources.list /etc/apt/sources.list</span></span><br><span class="line"><span class="bash"><span class="comment"># 在镜像内部执行命令, 这里就是更新版本和安装 nginx</span></span></span><br><span class="line"><span class="bash">RUN apt-get update &amp;&amp; apt-get install -y nginx</span></span><br><span class="line"><span class="bash"><span class="comment"># 修改 nginx 默认的 index.html 的内容</span></span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">'Hi, I am in your container'</span>\</span></span><br><span class="line"><span class="bash">    &gt;/var/www/html/index.html</span></span><br><span class="line"><span class="bash"><span class="comment"># 镜像对外暴露80端口</span></span></span><br><span class="line"><span class="bash">EXPOSE 80</span></span><br></pre></td></tr></table></figure><p>然后为了更新速度快一点, 就要换一个国内镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi sources.list</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sources.list 内容</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>然后还是在这个目录下, 运行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build ./ -t local_ubuntu_nginx:v2</span><br></pre></td></tr></table></figure></p><p>执行完毕后就能看到本地多了一个镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Documents docker images</span><br><span class="line">REPOSITORY              TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">local_ubuntu_nginx      v2                     b0f5984c042a        14 minutes ago      214MB</span><br></pre></td></tr></table></figure></p><p>用这个镜像构建一个容器:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Documents docker run -it --rm -p 8088:80 local_ubuntu_nginx:v2 /bin/bash</span><br><span class="line">root@5cb9ff723bee:/<span class="comment"># /usr/sbin/nginx</span></span><br><span class="line">root@5cb9ff723bee:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>保持终端打开, 本地访问 <code>http://localhost:8088/</code> 就能看到欢迎界面了 </p><p>如果这个是关闭交互端口, 这个就访问不到了, 这里要说一个<strong>关键点</strong>了</p><blockquote><p>在 docker 中运行的程序不能使用后台运行的模式, 否则 docker 会任务这个容器不活跃或出现问题而自动关闭<br>但是 docker 容器本身是可以后台运行的: docker run -d ……</p></blockquote><h4 id="关于-docker-build-多说一句"><a href="#关于-docker-build-多说一句" class="headerlink" title="关于 docker build 多说一句"></a>关于 docker build 多说一句</h4><p>之前我们构建时执行的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build ./ -t local_ubuntu_nginx:v2</span><br></pre></td></tr></table></figure></p><p>这个 <code>./</code> 的路径指的是构建文本流(context)的路径, 而不是 <code>Dockerfile</code>的文件路径, 在 <code>Dockerfile</code> 中用的各种相对路径都是基于 <code>context</code> 的,我们完全可以是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build /path/to/context -f /path/to/anywhere/Dockerfile_demo -t local_ubuntu_nginx</span><br></pre></td></tr></table></figure></p><p>你看, Dockerfile 的文件名不就变成 <code>Dockerfile_demo</code> 了, 如果有<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./sources.list /etc/apt/sources.list</span></span><br></pre></td></tr></table></figure></p><p>这样的操作, 那么它的完整路径应该是 <code>/path/to/context/sources.list</code>, 不过默认的情况下就是这两个路径是一起的, 不设置镜像<code>tag</code>的话就拿 Dockerfile 所在的目录名为镜像名,默认<code>latest</code>版本</p><h3 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h3><p>有时候我们的运行环境和编译环境是两回事, 就拿 golang 来举例, 我们只会去维护代码, 而不去管它生成的二进制包是什么, 又因为golang 打包出来的二进制文件几乎是没有依赖, 只要执行这个文件就行, 那么在运行环境中和编译相关的程序就是多余的, 可以看一下官网的示例 <a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank" rel="noopener">Use multi-stage builds</a>, 不能翻墙的看这个</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.7</span>.<span class="number">3</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"><span class="bash">RUN go get -d -v golang.org/x/net/html  </span></span><br><span class="line"><span class="bash">COPY app.go .</span></span><br><span class="line"><span class="bash">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">FROM alpine:latest  </span></span><br><span class="line"><span class="bash">RUN apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="bash">WORKDIR /root/</span></span><br><span class="line"><span class="bash"><span class="comment"># 这个是关键, --from=0 是指从第一个镜像(from)中复制内容, 程序中的1 就是0</span></span></span><br><span class="line"><span class="bash">COPY --from=0 /go/src/github.com/alexellis/href-counter/app .</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t alexellis2/href-counter:latest .</span><br></pre></td></tr></table></figure><p>这是我自己构建镜像时编译 <code>swoole.so</code> 的镜像和运行时的镜像大小<br><img src="http://blog-image.onlyoneip.com/docker-images.png" alt="docker-images"><br>我们只想要一个 <code>swoole.so</code> 像 <code>gcc</code>, <code>make</code> 都是不是代码运行时需要的模块, 因此只是在编译的时候用上, 吐一个<code>swoole.so</code>出来就行, <a href="https://github.com/gayhuber/dnmp/tree/master/php-cli" target="_blank" rel="noopener">相关代码</a></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> php:<span class="number">5.6</span>.<span class="number">36</span>-cli-alpine3.<span class="number">7</span> as builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中国特色</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"http://mirrors.ustc.edu.cn/alpine/v3.7/main/"</span> &gt; /etc/apk/repositories</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 添加编译 swoole 需要的前置插件</span></span></span><br><span class="line"><span class="bash">RUN apk update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk upgrade &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add alpine-sdk linux-headers &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add autoconf gcc make</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN wget https://github.com/swoole/swoole-src/archive/1.8.12-stable.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="bash">    tar zxvf 1.8.12-stable.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> swoole-src-1.8.12-stable &amp;&amp; \</span></span><br><span class="line"><span class="bash">    phpize &amp;&amp; \</span></span><br><span class="line"><span class="bash">    ./configure &amp;&amp; \</span></span><br><span class="line"><span class="bash">    make &amp;&amp; make install</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">FROM php:5.6.36-cli-alpine3.7 as runtimer</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 这里因为给每一个阶段加了别名, 这样更方便一点</span></span></span><br><span class="line"><span class="bash">COPY --from=builder /usr/<span class="built_in">local</span>/lib/php/extensions/no-debug-non-zts-20131226/swoole.so /usr/<span class="built_in">local</span>/lib/php/extensions/no-debug-non-zts-20131226/swoole.so</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY ./swoole.ini /usr/<span class="built_in">local</span>/etc/php/conf.d/swoole.ini</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 通常 run 是构建镜像时用的, 会保存一层缓存, cmd 就是镜像启动后执行的命令</span></span></span><br><span class="line"><span class="bash">RUN [<span class="string">"php"</span>, <span class="string">"-m"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"php"</span>, <span class="string">"-a"</span>]</span></span><br></pre></td></tr></table></figure><h3 id="构建镜像时需要注意的几点"><a href="#构建镜像时需要注意的几点" class="headerlink" title="构建镜像时需要注意的几点"></a>构建镜像时需要注意的几点</h3><ol><li>尽量使用官方镜像, 同时版本选择 <code>alpine &gt; debian &gt; ubuntu &gt; centos</code>, <code>alpine</code>版本的镜像是最小的</li><li>COPY 和 ADD 尽量使用 COPY, COPY 只是单纯的复制, ADD 则会自动执行一些东西, 有可能出现意料外的问题</li><li>CMD 和 ENTERPOINT 这两个可以查一下区别, 我个人习惯用 CMD</li><li>容器中的程序都要前台执行的模式, 使用 daemon 模式会被退出(你想想本身一个后台运行的容器中有个后台运行的程序…)</li><li>每一个 <code>RUN</code> 指令就是一层缓存, 当其中一个步骤发生更改那么这之后的步骤也都重新构建</li><li><p>系统更新最好合成一个 RUN 比如:</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk upgrade &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add alpine-sdk linux-headers &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add autoconf gcc make</span></span><br></pre></td></tr></table></figure><p> 同样还是为了避免因为缓存时出现问题</p></li><li>多看看官方构建的镜像, 收获会很多, 比如 <a href="https://github.com/nginxinc/docker-nginx/tree/e3e35236b2c77e02266955c875b74bdbceb79c44/stable" target="_blank" rel="noopener">docker-nginx</a>, <a href="https://github.com/docker-library/php/tree/4af0a8734a48ab84ee96de513aabc45418b63dc5" target="_blank" rel="noopener">docker-php</a></li></ol><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><ol><li><a href="http://blog.justwe.site/2018/07/06/docker-step-1/">不正宗 Docker 入门教程-启动一个容器(1/3)</a></li><li><a href="http://blog.justwe.site/2018/07/08/docker-step-2/">不正宗 Docker 入门教程-构建一个镜像(2/3)</a></li><li><a href="http://blog.justwe.site/2018/07/20/docker-step-3/">不正宗 Docker 入门教程-使用 Docker-Compose (3/3)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章讲的大概能让你明白虚拟机和 docker 的区别…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="docker入门" scheme="http://blog.justwe.site/tags/docker%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>不正宗 Docker 入门教程-启动一个容器(1/3)</title>
    <link href="http://blog.justwe.site/2018/07/06/docker-step-1/"/>
    <id>http://blog.justwe.site/2018/07/06/docker-step-1/</id>
    <published>2018-07-06T10:25:44.000Z</published>
    <updated>2018-09-30T03:38:29.782Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 从命名上就知道这是一篇简单粗暴的<code>docker</code>新手入门教程， 为什么要简单粗暴？ 我认为有自学能力的人帮他入门就够了， 不能自学的一时半会儿也教不会， 不符合入门教程的初衷， 建议出门左拐去找找视频教程…<br><a id="more"></a></p></blockquote><h3 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h3><ol><li>大概了解 docker 是个什么玩意</li><li>知道常用的 docker 指令参数, 能启动一个容器(不然还想怎么样? 上天吗?)</li></ol><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>强烈推荐使用 <code>Docker for Mac</code> 或 <code>Docker for Windows</code>, 这两个工具已经将 <code>Kitematic</code> 和 <code>docker-compose</code> 集成好了， 至于这两个工具是做什么的咱们后面再说， <code>win10</code> 版本需要专业版的， 不然开启不了<code>Hyper-V</code>， <code>win7</code> 就别想了，会受苦…</p><p>怎么安装在 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云镜像容器服务</a> 里面都说的很清楚了， 连<strong>国内镜像源</strong>都给你安排好了， 咱们就进入下一话题</p><blockquote><p>PS: 如果是 CentOS 6 的就需要升级一下系统内核了， <a href="http://blog.justwe.site/2018/07/06/docker-install-centos65/">centOS6.5 安装docker</a>， 毕竟都 <code>8102</code> 年了， docker 又是个比较新的东西， 对于稍微久一点的系统的支持就不那么友好</p></blockquote><h3 id="运行第一个容器"><a href="#运行第一个容器" class="headerlink" title="运行第一个容器"></a>运行第一个容器</h3><p>安装完环境之后就启动一个镜像开开眼儿<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 --name local_nginx nginx</span><br></pre></td></tr></table></figure></p><p>然后访问 <code>http://localhost:8080/</code> 就能看到 <code>nginx</code> 的初始界面了<br><img src="http://blog-image.onlyoneip.com/run-nginx.png" alt="run-image"></p><p>中间发生了什么呢？ </p><ol><li><code>docker run</code> 运行镜像的起手式， 详情查看 <code>docker run --help</code></li><li><code>-d</code> 启动 <code>docker</code> 守护进程</li><li><code>-p 8080:80</code> 将本地的 <code>8080</code> 端口绑定到容器的 <code>80</code> 端口上</li><li><code>--name local_nginx</code> 分配一个容器名， 不写的话会默认分配要给， 不过这个还是很有用的</li><li><code>nginx</code> 指定运行的镜像名，如果没有指定标签则默认是 <code>latest</code>， 这里其实是启动<code>nginx:latest</code>镜像</li></ol><p>现在可以查看一下本机都在运行着什么镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS D:\docker_study&gt; docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">6732fa239270        nginx              <span class="string">"nginx -g 'daemon of…"</span>   18 minutes ago      Up 18 minutes       0.0.0.0:8080-&gt;80/tcp   local_nginx</span><br></pre></td></tr></table></figure></p><p><code>docker ps</code> 只能看到正在运行中的容器， 想看到全部的就是 <code>docker ps -a</code></p><p><strong>进入这个容器的命令:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 6732fa239270 /bin/bash</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">docker <span class="built_in">exec</span> -it local_nginx /bin/bash</span><br></pre></td></tr></table></figure></p><p>解释一下:</p><ol><li><code>docker exec</code>    在容器中执行命令</li><li><code>-i</code>             保持stdin打开</li><li><code>-t</code>             分配一个伪终端(tty)</li><li><code>6732fa239270 或 local_nginx</code>    这里你也发现了， 可以是通过 <code>CONTAINER ID</code> 也可以是 <code>NAMES</code> 这里的 <code>CONTAINER ID</code>分为128位长ID和32位短ID， 不过作用都是一样的</li><li><code>/bin/bash</code>      运行容器中的 <code>/bin/bash</code> 脚本</li></ol><p>进入容器中感觉其实和进入一个虚拟机一样， 但是容器和虚拟机有点区别， 这个我们下一小节会讲到</p><p><strong>关闭容器</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 6732fa239270 或 local_nginx</span><br></pre></td></tr></table></figure></p><h3 id="什么是容器？什么是镜像？"><a href="#什么是容器？什么是镜像？" class="headerlink" title="什么是容器？什么是镜像？"></a>什么是容器？什么是镜像？</h3><p><img src="http://blog-image.onlyoneip.com/image-container.jpg" alt="image-container"></p><p>之前我们使用 <code>VirtualBox</code> 装虚拟机的时候有装盘镜像, 但是启动后就是一个个的虚拟机了, 不过在 docker 中和虚拟机还是有点区别</p><p>就拿上图来说, <code>container</code>就是镜像的实例化, <code>image</code> 是容器的底层支撑, 其实他们的关系用代码中的类<code>Class</code>来比喻是最合适的:</p><ul><li>Class 就是我们实际开发中写的一个代码集合, Object 是 Class 实例化之后生成的一种资源变量</li><li>Image 也是预先写好的逻辑, 并存在一个地方, Container 是 Image 启动之后生成的一个虚拟系统</li><li>实例化出来的 Object 不会影响到 Class 中的内容</li><li>已经启动的 Container 也不会影响到 Image 中的逻辑</li><li>Class 可以继承别的 Class, 从而继承它的特性</li><li>Image 也是可以继承别的 Image, 并在它的基础上构建新的镜像</li><li>一个 Object 对应着一个 Class, 但是 一个 Class 可以实例化无数个 Object</li><li>同理, 一份 Image 可以生成无数个 Container, 这就是方便集群化部署的所在</li></ul><p>简单的说 Container 就是 Image 的儿子, 模样和 Image 预想的一样, 但是 Container 运行之后会发生一些改变, 而且这种改变是可以保存的</p><p>7-11补充: 这位大佬讲的 image 和 虚拟机 之前的很清晰 -&gt; <a href="https://mp.weixin.qq.com/s/sACsDZNjPa2vSidWUMB14g" target="_blank" rel="noopener">宋宝华：Docker 最初的2小时(Docker从入门到入门)</a>, 不过推荐是先敲几个实际的例子运行一下再看, 工具先跑起来再去了解它嘛!</p><h3 id="常用的运行参数和命令"><a href="#常用的运行参数和命令" class="headerlink" title="常用的运行参数和命令"></a>常用的运行参数和命令</h3><p>咱们先不说构建镜像的事儿(那是下一章的话题), 这里先了解一下 <code>docker run</code> 命令中比较常用的参数:</p><h4 id="it-建立一个可在终端交互的容器"><a href="#it-建立一个可在终端交互的容器" class="headerlink" title="-it  建立一个可在终端交互的容器"></a><code>-it</code>  建立一个可在终端交互的容器</h4><p>比如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name local_nginx nginx:latest /bin/bash</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">docker <span class="built_in">exec</span> -it local_nginx bin/bash</span><br></pre></td></tr></table></figure></p><h4 id="p-用于宿主机和容器的端口绑定"><a href="#p-用于宿主机和容器的端口绑定" class="headerlink" title="-p    用于宿主机和容器的端口绑定"></a><code>-p</code>    用于宿主机和容器的端口绑定</h4><p>绑定多个端口就设置多个映射<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:80 -p 4433:443 nginx:latest</span><br><span class="line"><span class="comment"># 或    不写本地端口, docker 将帮你自动分配</span></span><br><span class="line">docker run -d -p :80 -p :443 nginx:latest</span><br><span class="line"><span class="comment"># 或    加上 ip 就绑本地指定的 ip</span></span><br><span class="line">docker run -d -p 127.0.0.1:8088:80 -p :443 nginx:latest</span><br><span class="line"><span class="comment"># 或    照样不写本地端口就随机分配</span></span><br><span class="line">docker run -d -p 127.0.0.1::80 -p :443 nginx:latest</span><br></pre></td></tr></table></figure></p><p>通过 <code>docker ps</code> 可以看一下上面两行命令的执行状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                           NAMES</span><br><span class="line">57f65b46bd87        nginx:latest        <span class="string">"nginx -g 'daemon of…"</span>   1 second ago         Up 3 seconds        0.0.0.0:32769-&gt;80/tcp, 0.0.0.0:32768-&gt;443/tcp   happy_zhukovsky</span><br><span class="line">0c035ebabe44        nginx:latest        <span class="string">"nginx -g 'daemon of…"</span>   About a minute ago   Up About a minute   0.0.0.0:8088-&gt;80/tcp, 0.0.0.0:4433-&gt;443/tcp     ecstatic_haibt</span><br></pre></td></tr></table></figure></p><h4 id="v-将宿主机的卷挂载到容器中的指定目录"><a href="#v-将宿主机的卷挂载到容器中的指定目录" class="headerlink" title="-v 将宿主机的卷挂载到容器中的指定目录"></a><code>-v</code> 将宿主机的卷挂载到容器中的指定目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:80 -v /Users/gpf/Documents/docker_study/docker_test/www/:/usr/share/nginx/html/ nginx:latest</span><br></pre></td></tr></table></figure><p>这里本地的目录要写绝对路径, 不然会报错, 这样一来, 本地的<code>/Users/gpf/Documents/docker_study/docker_test/www/</code> 就是容器中的<code>/usr/share/nginx/html/</code>, 就可以本地更改代码, 然后容器中运行</p><h4 id="d-后台运行"><a href="#d-后台运行" class="headerlink" title="-d 后台运行"></a><code>-d</code> 后台运行</h4><p>想查看日志的话就 <code>docker logs [containerID]</code> 就行</p><h4 id="docker-exec-执行-docker-容器中的命令"><a href="#docker-exec-执行-docker-容器中的命令" class="headerlink" title="docker exec 执行 docker 容器中的命令"></a><code>docker exec</code> 执行 docker 容器中的命令</h4><p>通常就是用来进入容器中搞七搞八的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 57f65b46bd87 /bin/bash</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">docker exsec -it local_nginx /bin/bash</span><br></pre></td></tr></table></figure></p><p>这里注意两点:</p><ul><li><code>containerID</code> 在很多情况下都可以用 <code>container Name</code> 来代替, 很多情况是等价的</li><li>命令最后的 <code>/bin/bash</code> 不是必须这么填, 而是执行的容器中的脚本, 如果你的镜像是 <code>alpine</code>版的就是 <code>sh</code>, 因为这个版本中就没有 bash 这个命令</li></ul><h4 id="docker-ps-容器的运行状态"><a href="#docker-ps-容器的运行状态" class="headerlink" title="docker ps 容器的运行状态"></a><code>docker ps</code> 容器的运行状态</h4><h4 id="docker-stop-containerID-或-name-停止容器"><a href="#docker-stop-containerID-或-name-停止容器" class="headerlink" title="docker stop [containerID 或 name] 停止容器"></a><code>docker stop [containerID 或 name]</code> 停止容器</h4><p>目前版本也增加了 <code>docker container stop [containerID 或 name]</code> 其实作用是一样的, 不过 <code>docker container</code> 命令底下还有很多别的命令, docker 给各模块的命令做了细分</p><h4 id="docker-rm-containerID-或-name-删除指定未运行的容器-一个或多个"><a href="#docker-rm-containerID-或-name-删除指定未运行的容器-一个或多个" class="headerlink" title="docker rm [containerID 或 name] 删除指定未运行的容器, 一个或多个"></a><code>docker rm [containerID 或 name]</code> 删除指定未运行的容器, 一个或多个</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 6dee0a9b5232 582f708af9d3</span><br></pre></td></tr></table></figure><h4 id="docker-rmi-imageID-或-tag-删除宿主机指定的镜像"><a href="#docker-rmi-imageID-或-tag-删除宿主机指定的镜像" class="headerlink" title="docker rmi [imageID 或 tag] 删除宿主机指定的镜像"></a><code>docker rmi [imageID 或 tag]</code> 删除宿主机指定的镜像</h4><p>这里要注意如果这个镜像还有容器在使用就不能删除掉, 这个时候要先把对应的容器删掉才行<br>删除指定镜像的容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps | grep <span class="string">'这里写imageName'</span> | awk <span class="string">'&#123; print $1&#125;'</span>)</span><br><span class="line">docker rm $(docker ps | grep <span class="string">'这里写imageName'</span> | awk <span class="string">'&#123; print $1&#125;'</span>)</span><br></pre></td></tr></table></figure></p><p>删除临时构建的镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | grep <span class="string">'&lt;none&gt;'</span> | awk <span class="string">'&#123; print $3&#125;'</span>)</span><br></pre></td></tr></table></figure></p><h4 id="prune-大杀器"><a href="#prune-大杀器" class="headerlink" title="prune 大杀器"></a>prune 大杀器</h4><p>这一手还是慎用,一些情况下可造成 <code>rm -rf /*</code> 的效果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除所有未使用的镜像</span></span><br><span class="line">docker image prune</span><br><span class="line"><span class="comment">#移除所有未运行的容器</span></span><br><span class="line">docker container prune</span><br><span class="line"><span class="comment">#移除所有未使用的本地卷</span></span><br><span class="line">docker volume prune</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>PS: 因为有这一手, 所以可以看出官方的态度, 他们貌似也许可能没准大概差不多不建议把容器当成虚拟机一样把所有的东西都堆在一个镜像里面, 那样搞不止构建出来的镜像臃肿, 而且维护性移植性很差, 从目前网上的 docker 镜像资源来说, 基础镜像 alpine &gt; debian &gt; ubuntu &gt; centos, 优先使用最小的基础构建, 然后整个 image 只为一个服务而构建, 比如 redis 镜像里只要 redis, 没有什么 MySQL, memcache 什么的, 多个独立的 service 才组成一个 APP, 里面各个组件替换的话不用考虑其他组件的环境依赖什么的, 当然, 这个也是看业务的实际需要, 不能为了拆分而拆分, 在这之间能找到最合适自己的才是工具给我们带来的便利</p></blockquote><h4 id="docker-network-容器之间的互联"><a href="#docker-network-容器之间的互联" class="headerlink" title="docker network 容器之间的互联"></a><code>docker network</code> 容器之间的互联</h4><p>如果只是在一个容器里搞来搞去就真的是虚拟机了, docker 的强大之处就是它内部维护一个网络, 处在相同网络的容器是可以互通的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个 docker 网络, -d bridge 是指定网络模式, 当前是桥接网络</span></span><br><span class="line">docker network create -d bridge nginx_swarm</span><br><span class="line"><span class="comment"># 启动两个 nginx 容器, 分别命名 nginx_swarm_a nginx_swarm_b , 两者都加入了 nginx_swarm 这个网络  --rm 是当容器停止后自动删除</span></span><br><span class="line">docker run -it --rm  --name nginx_swarm_a --network nginx_swarm  nginx /bin/bash</span><br><span class="line">docker run -it --rm  --name nginx_swarm_b --network nginx_swarm  nginx /bin/bash</span><br></pre></td></tr></table></figure></p><p>注意, 我们并没把接口暴露出去, 现在随便在一个容器中 <code>ping</code> 另一个容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是在 nginx_swarm_a 中</span></span><br><span class="line"><span class="comment"># 没有 ping 命令的先装一个 ping</span></span><br><span class="line"><span class="comment"># apt-get update &amp;&amp; apt-get install -y iputils-ping</span></span><br><span class="line">root@73d04107780f:/<span class="comment"># ping -c 3 nginx_swarm_b</span></span><br><span class="line">PING nginx_swarm_b (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from nginx_swarm_b.nginx_swarm (172.18.0.3): icmp_seq=1 ttl=64 time=0.084 ms</span><br><span class="line">64 bytes from nginx_swarm_b.nginx_swarm (172.18.0.3): icmp_seq=2 ttl=64 time=0.161 ms</span><br><span class="line">64 bytes from nginx_swarm_b.nginx_swarm (172.18.0.3): icmp_seq=3 ttl=64 time=0.146 ms</span><br><span class="line"></span><br><span class="line">--- nginx_swarm_b ping statistics ---</span><br></pre></td></tr></table></figure></p><p>docker 能自动的把 server name 转换成 ip, 我们只需要标明请求的是哪个容器, 而不是还要记住它的 ip 地址(当然 ip 地址也能设置)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>弄明白以下几点启动一个容器应该是没什么问题了:</p><ol><li>国内一定要使用国内镜像源, 不然会痛不欲生, <a href="https://ieevee.com/tech/2016/09/28/docker-mirror.html#%E9%80%89%E6%8B%A9%E9%9B%B6%E7%BD%91%E6%98%93163-docker%E9%95%9C%E5%83%8F" target="_blank" rel="noopener">国内 docker 仓库镜像对比</a></li><li>分清镜像和容器的概念, 容器就是基于镜像构建出来的一个实例</li><li>不要往容器中保存数据, 容器应该是无状态的, 需要持久化保存的就<code>docker run -v xx:xx</code> 或者 <code>docker create volume ...</code> 用独立的卷来保存</li><li>docker 不是虚拟机</li><li>分清楚宿主机端口和容器端口</li><li>处在相同<code>network</code>下的容器才能通过容器明互相访问</li></ol><p>参考资料:<br><a href="https://github.com/yeasy/docker_practice/blob/master/SUMMARY.md" target="_blank" rel="noopener">Docker — 从入门到实践</a><br><a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener">nginx 官方镜像</a></p><h4 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h4><ol><li><a href="http://blog.justwe.site/2018/07/06/docker-step-1/">不正宗 Docker 入门教程-启动一个容器(1/3)</a></li><li><a href="http://blog.justwe.site/2018/07/08/docker-step-2/">不正宗 Docker 入门教程-构建一个镜像(2/3)</a></li><li><a href="http://blog.justwe.site/2018/07/20/docker-step-3/">不正宗 Docker 入门教程-使用 Docker-Compose (3/3)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 从命名上就知道这是一篇简单粗暴的&lt;code&gt;docker&lt;/code&gt;新手入门教程， 为什么要简单粗暴？ 我认为有自学能力的人帮他入门就够了， 不能自学的一时半会儿也教不会， 不符合入门教程的初衷， 建议出门左拐去找找视频教程…&lt;br&gt;
    
    </summary>
    
    
      <category term="docker入门" scheme="http://blog.justwe.site/tags/docker%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
