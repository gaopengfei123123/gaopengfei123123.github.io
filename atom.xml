<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>&lt;hello-world/&gt;</title>
  
  <subtitle>代码改变世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.justwe.site/"/>
  <updated>2019-11-14T08:48:02.000Z</updated>
  <id>http://blog.justwe.site/</id>
  
  <author>
    <name>GPF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github-Webhook 小工具</title>
    <link href="http://blog.justwe.site/2019/11/14/tool-github-webhook/"/>
    <id>http://blog.justwe.site/2019/11/14/tool-github-webhook/</id>
    <published>2019-11-14T08:44:42.000Z</published>
    <updated>2019-11-14T08:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写了一个小工具, 用来接收github webhook消息, 以在服务器上自动执行脚本</p><p><a href="https://github.com/gaopengfei123123/hook" target="_blank" rel="noopener">gaopengfei123123/hook</a></p><a id="more"></a><h2 id="github-hook-server"><a href="#github-hook-server" class="headerlink" title="github hook server"></a>github hook server</h2><p>一个用来接收webhook的server</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>golang v1.11+ (因为用到了go mod)</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gaopengfei123123/hook</span><br></pre></td></tr></table></figure></p><p>创建文件 <code>main.go</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gaopengfei123123/hook"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hook.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o app main.go</span><br></pre></td></tr></table></figure></p><p><code>app</code> 这个二进制文件就是本体了, 放到合适的地方, 执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./app start -d</span><br></pre></td></tr></table></figure></p><p>后台启动, app 同目录下会创建 <code>scripts</code>, <code>logs</code> 两个目录, 和一个 <code>hook.pid</code> 保存pid</p><p>检测是否启动:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx]# curl localhost:<span class="number">8080</span>/<span class="built_in">ping</span></span><br><span class="line">&#123;"message":"pong v5"&#125;</span><br></pre></td></tr></table></figure></p><p>说明服务已经启动成功, 服务地址为<code>0.0.0.0:8080</code></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><code>0.0.0.0:8080/ping</code>   检测接口</li><li><code>0.0.0.0:8080/push</code>   接受github webhook请求, 根据 Repository.Name 去判断执行什么脚本</li></ul><h3 id="可用指令"><a href="#可用指令" class="headerlink" title="可用指令"></a>可用指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reload      重新加载日志, 以及平滑重启</span><br><span class="line">start       启动命令, -d 后台运行</span><br><span class="line">stop        终止命令</span><br><span class="line">version     程序版本</span><br></pre></td></tr></table></figure><h3 id="目录功能"><a href="#目录功能" class="headerlink" title="目录功能:"></a>目录功能:</h3><ul><li>logs 存放请求日志</li><li>scripts 存放hook脚本, 当有对应库名的请求进来, 将执行配置好的脚本</li><li>hook.pid 存放进程pid</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "github_hook": &#123;        // 以请求消息中的 repository.name 字段来做key</span><br><span class="line">        "secret": "xxxxxx", // 如果设置了secret则会用这个进行验证, 为空则不验证</span><br><span class="line">        "script_path": "",  // 脚本所在绝对目录, 为空就是当前的script目录</span><br><span class="line">        "event": &#123;</span><br><span class="line">            "push": "test"  // 推送事件执行的脚本</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>一键初始化</li><li>平滑重启, 信号通信</li><li>支持secret验证</li><li>异步执行脚本</li><li>规避重放</li><li>脚本传递参数(TODO)</li><li>事件钩子(TODO)</li></ul><h3 id="依赖组件"><a href="#依赖组件" class="headerlink" title="依赖组件"></a>依赖组件</h3><ul><li>http框架 <a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin</a></li><li>日志组件 <a href="https://github.com/sirupsen/logrus" target="_blank" rel="noopener">logrus</a></li><li>命令行组件 <a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">cobra</a></li></ul><h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/gaopengfei123123/hook" target="_blank" rel="noopener">gaopengfei123123/hook</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写了一个小工具, 用来接收github webhook消息, 以在服务器上自动执行脚本&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gaopengfei123123/hook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gaopengfei123123/hook&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.justwe.site/categories/tools/"/>
    
    
      <category term="tools" scheme="http://blog.justwe.site/tags/tools/"/>
    
      <category term="github" scheme="http://blog.justwe.site/tags/github/"/>
    
      <category term="hook" scheme="http://blog.justwe.site/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>转 Go 模仿Unix 管道操作</title>
    <link href="http://blog.justwe.site/2019/11/14/go-pipe-pattern/"/>
    <id>http://blog.justwe.site/2019/11/14/go-pipe-pattern/</id>
    <published>2019-11-14T03:29:20.000Z</published>
    <updated>2019-11-14T03:41:25.668Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘录了许式伟 <a href="https://www.infoq.cn/article/go-based-on-connection-combination-language-1/" target="_blank" rel="noopener">《Go，基于连接与组合的语言》</a>部分内容，为了便于理解，我在其后端写了个完整的示例程序帮助理解，这篇文章 一是展示go在并行编程中的伟大，也是理解和学习闭包的活的教科书</p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>让我们从Unix谈起。Go语言与Unix、C语言有着极深的渊源。Go语言的领袖们参与甚至主导了Unix和C语言的设计。Ken Thompson 甚至算得上Unix和C语言的鼻祖。Go语言亦深受Unix和C语言的设计哲学影响。</p><p>在Unix世界里，组件就是应用程序（app），每个app可大体抽象为：</p><ul><li>输入：stdin（标准输入）, params（命令行参数）</li><li>输出：stdout（标准输出）</li><li>协议：text (data stream)</li></ul><p>不同的应用程序（app）如何连接？答案是：管道（pipeline）。在Unix世界中大家对这样的东西已经很熟悉了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app1 params1 | app2 params2</span><br></pre></td></tr></table></figure></p><p>通过管道（pipeline），可以将一个应用程序的输出（stdout）转换为另一个应用程序的输入（stdin）。更为神奇的一点，是这些应用程序是并行执行的。app1每产生一段输出，立即会被app2所处理。所以管道（pipeline）称得上是最古老，同时也是极其优秀的并行设施，简单而强大。</p><p>需要注意的是，Unix世界中不同应用程序直接是松散耦合的。上游app的输出是xml还是json，下游app需要知晓，但并无任何强制的约束。同一输出，不同的下游app，对协议的理解甚至都可能并不相同。例如，上游app输出一段xml文本，对于某个下游app来说，是一颗dom树，但对linecount程序来说只是一个多行的文本，对于英文单词词频统计程序来说，是一篇英文文章。</p><p>为了方便理解，我们先尝试在Go语言中模拟整个Unix的管道（pipeline）机制。首先是应用程序（app），我们抽象为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(in io.Reader, out io.Writer, args []string)</span><br></pre></td></tr></table></figure></p><p>也就是说，Unix 中的</p><p>app1 params1 | app2 params2<br>对应Go语言中是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe( bind(app1, params1), bind(app2, params2) )</span><br></pre></td></tr></table></figure></p><p>其中，bind 函数实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    app <span class="keyword">func</span>(in io.Reader, out io.Writer, args []<span class="keyword">string</span>)</span>,</span></span><br><span class="line"><span class="function">    <span class="title">args</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function">) <span class="title">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line">        app(in, out, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要理解bind函数，需要先理解“闭包”。Go语言中，应用程序以一个闭包的形式体现。如果你熟悉函数式编程，不难发现，这个bind函数其实就是所谓的柯里化（currying）。</p><p>pipe函数如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pipe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    app1 <span class="keyword">func</span>(in io.Reader, out io.Writer)</span>,</span></span><br><span class="line"><span class="function">    <span class="title">app2</span> <span class="title">func</span><span class="params">(in io.Reader, out io.Writer)</span></span></span><br><span class="line"><span class="function">) <span class="title">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line">        pr, pw := io.Pipe()</span><br><span class="line">        <span class="keyword">defer</span> pw.Close()</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> pr.Close()</span><br><span class="line">            app2(pr, out)</span><br><span class="line">        &#125;()</span><br><span class="line">        app1(in, pw)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要理解pipe函数，除了“闭包”外，需要知晓defer关键字和goroutine（go关键字）。defer语句会在函数退出时执行（无论是否发生了异常），通常用于资源的清理操作（比如关闭文件句柄等）。有了defer语句，Go语言中的错误处理代码显得非常优雅。在一个正常的函数调用前加上go关键字，就会使得该函数在新的goroutine中并行执行。理解了这些背景，这个pipe函数不难理解，无非是：先创建一个管道，让app1读入数据（in），并向管道的写入端（pw）输出，启动一个新goroutine，让app2从管道的读入端读取数据，并将处理结果输出（out）。这样得到的app就是app1和app2的组合了。</p><p>你甚至可以对多个app进行组合：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pipe</span><span class="params">(apps ...<span class="keyword">func</span>(in io.Reader, out io.Writer)</span>) <span class="title">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(apps) == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    app := apps[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(apps); i++ &#123;</span><br><span class="line">        app1, app2 := app, apps[i]</span><br><span class="line">        app = <span class="function"><span class="keyword">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line">            pr, pw := io.Pipe()</span><br><span class="line">            <span class="keyword">defer</span> pw.Close()</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> pr.Close()</span><br><span class="line">                app2(pr, out)</span><br><span class="line">            &#125;()</span><br><span class="line">            app1(in, pw)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们举个比较实际的例子，假设我们有2个应用程序tar（打包）、gzip（压缩）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tar</span><span class="params">(io.Reader, out io.Writer, files []<span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">gzip</span><span class="params">(in io.Reader, out io.Writer)</span></span></span><br></pre></td></tr></table></figure></p><p>那么打包并压缩的代码是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe( bind(tar, files), gzip )(<span class="literal">nil</span>, out)</span><br></pre></td></tr></table></figure></p><p>通过对管道（pipeline）的模拟我们可以看出，Go语言对并行支持是非常强大的，这主要得益于Go的轻量级进程（goroutine）。</p><p>实例程序，帮助理解管道：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind函数主要是用来为pipe函数整合用的，通过将闭包将函数签名变成pipe所需的样子</span></span><br><span class="line"><span class="comment">//返回一个函数闭包，将一个函数字面量app和字符串slice 传入其中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bind</span><span class="params">(app <span class="keyword">func</span>(in io.Reader, out io.Writer, args []<span class="keyword">string</span>)</span>, <span class="title">args</span> []<span class="title">string</span>) <span class="title">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line">app(in, out, args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个函数插入到管道的中间，调用者只需调用pipe返回的函数字面量，并传入管道的首尾两端，即可实现管道</span></span><br><span class="line"><span class="comment">//返回一个新的函数闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pipe</span><span class="params">(app1 <span class="keyword">func</span>(in io.Reader, out io.Writer)</span>, <span class="title">app2</span> <span class="title">func</span><span class="params">(in io.Reader, out io.Writer)</span>) <span class="title">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line">pr, pw := io.Pipe()</span><br><span class="line"><span class="keyword">defer</span> pw.Close()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> pr.Close()</span><br><span class="line">app2(pr, out)</span><br><span class="line">&#125;()</span><br><span class="line">app1(in, pw)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取args slice的每个字符串，将其作为文件名，读取文件,并在文件的每一行首部加上行号，写入到out中</span></span><br><span class="line"><span class="comment">//此处in没有使用到，主要是为了保证管道定义的一致性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">app1</span><span class="params">(in io.Reader, out io.Writer, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line"><span class="comment">//fmt.Println(v)</span></span><br><span class="line">file, err := os.Open(v)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">buf := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; ;i++&#123;</span><br><span class="line">line, err := buf.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">linenum := strconv.Itoa(i)</span><br><span class="line">nline := []<span class="keyword">byte</span>(linenum + <span class="string">" "</span>)</span><br><span class="line">nline = <span class="built_in">append</span>(nline, line...)</span><br><span class="line">out.Write(nline)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app2 主要是将字节流转化为大写,中文可能会有点问题，不过主要是演示用，重在理解思想</span></span><br><span class="line"><span class="comment">//read from in, convert byte to Upper ,write the result to out</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">app2</span><span class="params">(in io.Reader, out io.Writer)</span></span> &#123;</span><br><span class="line">rd := bufio.NewReader(in)</span><br><span class="line">p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, _ := rd.Read(p)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">t := bytes.ToUpper(p[:n])</span><br><span class="line">out.Write(t)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">args := os.Args[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">    p := pipe(bind(app1, args), app2)</span><br><span class="line">p(os.Stdin, os.Stdout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/hittata/article/details/44067343?utm_campaign=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com" target="_blank" rel="noopener">文章原文-golang 并发设计模式(二)–管道模式1</a><br><a href="https://www.infoq.cn/article/go-based-on-connection-combination-language-1/" target="_blank" rel="noopener">Go，基于连接与组合的语言（上）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文摘录了许式伟 &lt;a href=&quot;https://www.infoq.cn/article/go-based-on-connection-combination-language-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Go，基于连接与组合的语言》&lt;/a&gt;部分内容，为了便于理解，我在其后端写了个完整的示例程序帮助理解，这篇文章 一是展示go在并行编程中的伟大，也是理解和学习闭包的活的教科书&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="pipe" scheme="http://blog.justwe.site/tags/pipe/"/>
    
  </entry>
  
  <entry>
    <title>是用脚本分割Csv文件</title>
    <link href="http://blog.justwe.site/2019/11/11/python-csv-split/"/>
    <id>http://blog.justwe.site/2019/11/11/python-csv-split/</id>
    <published>2019-11-11T08:28:55.000Z</published>
    <updated>2019-11-11T08:35:07.044Z</updated>
    
    <content type="html"><![CDATA[<p>首先安装panda</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure><p>创建脚本:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line">rows = pd.read_csv(<span class="string">"csvfile.csv"</span>, chunksize=<span class="number">5000000</span>) <span class="comment"># 每个文件的尺寸, 以及导入文件名</span></span><br><span class="line"><span class="keyword">for</span> i, chuck <span class="keyword">in</span> enumerate(rows): </span><br><span class="line">    chuck.to_csv(<span class="string">'out&#123;&#125;.csv'</span>.format(i)) <span class="comment"># 输出文件名</span></span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python demo.py</span><br></pre></td></tr></table></figure></p><p>py挽救了我半小时的<del>摸鱼时光</del>生命</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先安装panda&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
      <category term="tools" scheme="http://blog.justwe.site/categories/tools/"/>
    
    
      <category term="csv" scheme="http://blog.justwe.site/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>转 Golang Http平滑重启实现</title>
    <link href="http://blog.justwe.site/2019/11/04/go-http-grace-restart/"/>
    <id>http://blog.justwe.site/2019/11/04/go-http-grace-restart/</id>
    <published>2019-11-04T09:11:54.000Z</published>
    <updated>2019-11-04T09:15:40.920Z</updated>
    
    <content type="html"><![CDATA[<p>服务端代码经常需要升级，对于线上系统的升级常用的做法是，通过前端的负载均衡（如nginx）来保证升级时至少有一个服务可用，依次（灰度）升级。</p><p>而另一种更方便的方法是在应用上做热重启，直接升级应用而不停服务。</p><a id="more"></a><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><ol><li>监听信号（USR2）</li><li>收到信号时fork子进程（使用相同的启动命令），将服务监听的socket文件描述符传递给子进程</li><li>子进程监听父进程的socket，这个时候父进程和子进程都可以接收请求</li><li>子进程启动成功之后，父进程停止接收新的连接，等待旧连接处理完成（或超时）</li><li>父进程退出，升级完成</li></ol><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>父进程将socket文件描述符传递给子进程可以通过命令行，或者环境变量等</li><li>子进程启动时使用和父进程一样的命令行，对于golang来说用更新的可执行程序覆盖旧程序</li><li>server.Shutdown()优雅关闭方法是go1.8的新特性</li><li>server.Serve(l)方法在Shutdown时立即返回，Shutdown方法则阻塞至context完成，所以Shutdown的方法要写在主goroutine中</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/exec"</span></span><br><span class="line"><span class="string">"os/signal"</span></span><br><span class="line"><span class="string">"syscall"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">server   *http.Server</span><br><span class="line">listener net.Listener</span><br><span class="line">graceful = flag.Bool(<span class="string">"graceful"</span>, <span class="literal">false</span>, <span class="string">"listen on fd open 3 (internal use only)"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world233333!!!!"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/hello"</span>, handler)</span><br><span class="line">server = &amp;http.Server&#123;Addr: <span class="string">":9999"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> *graceful &#123;</span><br><span class="line">log.Print(<span class="string">"main: Listening to existing file descriptor 3."</span>)</span><br><span class="line"><span class="comment">// cmd.ExtraFiles: If non-nil, entry i becomes file descriptor 3+i.</span></span><br><span class="line"><span class="comment">// when we put socket FD at the first entry, it will always be 3(0+3)</span></span><br><span class="line">f := os.NewFile(<span class="number">3</span>, <span class="string">""</span>)</span><br><span class="line">listener, err = net.FileListener(f)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Print(<span class="string">"main: Listening on a new file descriptor."</span>)</span><br><span class="line">listener, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"listener error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// server.Shutdown() stops Serve() immediately, thus server.Serve() should not be in main goroutine</span></span><br><span class="line">err = server.Serve(listener)</span><br><span class="line">log.Printf(<span class="string">"server.Serve err: %v\n"</span>, err)</span><br><span class="line">&#125;()</span><br><span class="line">signalHandler()</span><br><span class="line">log.Printf(<span class="string">"signal end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reload</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">tl, ok := listener.(*net.TCPListener)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"listener is not tcp listener"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f, err := tl.File()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">args := []<span class="keyword">string</span>&#123;<span class="string">"-graceful"</span>&#125;</span><br><span class="line">log.Printf(<span class="string">"exec Command: %s %v"</span>, os.Args[<span class="number">0</span>], args)</span><br><span class="line">cmd := exec.Command(os.Args[<span class="number">0</span>], args...)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line"><span class="comment">// put socket FD at the first entry</span></span><br><span class="line">cmd.ExtraFiles = []*os.File&#123;f&#125;</span><br><span class="line"><span class="keyword">return</span> cmd.Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">signalHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM, syscall.SIGUSR2)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sig := &lt;-ch</span><br><span class="line">log.Printf(<span class="string">"signal: %v"</span>, sig)</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout context for shutdown</span></span><br><span class="line">ctx, _ := context.WithTimeout(context.Background(), <span class="number">20</span>*time.Second)</span><br><span class="line"><span class="keyword">switch</span> sig &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SIGINT, syscall.SIGTERM:</span><br><span class="line"><span class="comment">// stop</span></span><br><span class="line">log.Printf(<span class="string">"stop"</span>)</span><br><span class="line">signal.Stop(ch)</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">log.Printf(<span class="string">"graceful shutdown"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> syscall.SIGUSR2:</span><br><span class="line"><span class="comment">// reload</span></span><br><span class="line">log.Printf(<span class="string">"reload"</span>)</span><br><span class="line">err := reload()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"graceful restart error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">server.Shutdown(ctx)</span><br><span class="line">log.Printf(<span class="string">"graceful reload"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://kuangchanglang.com/golang/2017/04/27/golang-graceful-restart" target="_blank" rel="noopener">文章原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务端代码经常需要升级，对于线上系统的升级常用的做法是，通过前端的负载均衡（如nginx）来保证升级时至少有一个服务可用，依次（灰度）升级。&lt;/p&gt;
&lt;p&gt;而另一种更方便的方法是在应用上做热重启，直接升级应用而不停服务。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="http" scheme="http://blog.justwe.site/tags/http/"/>
    
      <category term="grace" scheme="http://blog.justwe.site/tags/grace/"/>
    
  </entry>
  
  <entry>
    <title>Golang 通过 Context 控制并发的应用场景</title>
    <link href="http://blog.justwe.site/2019/10/25/go-context/"/>
    <id>http://blog.justwe.site/2019/10/25/go-context/</id>
    <published>2019-10-25T06:13:43.000Z</published>
    <updated>2019-10-25T08:35:31.912Z</updated>
    
    <content type="html"><![CDATA[<p>golang 里出现多 goroutine 的场景很常见, 最常用的两种方式就是 <code>WaitGroup</code> 和 <code>Context</code>, 今天我们了解一下 <code>Context</code> 的应用场景</p><a id="more"></a><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="场景一-多goroutine执行超时通知"><a href="#场景一-多goroutine执行超时通知" class="headerlink" title="场景一: 多goroutine执行超时通知"></a>场景一: 多goroutine执行超时通知</h4><p>并发执行的业务中最常见的就是有协程执行超时, 如果不做超时处理就会出现一个僵尸进程, 这累计的多了就会有一阵手忙脚乱了, 所以我们要在源头上就避免它们</p><p>看下面这个示例:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">同一个content可以控制多个goroutine, 确保线程可控, 而不是每新建一个goroutine就要有一个chan去通知他关闭</span></span><br><span class="line"><span class="comment">有了他代码更加简洁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"run demo \n\n\n"</span>)</span><br><span class="line">demo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">9</span>*time.Second)</span><br><span class="line"><span class="keyword">go</span> watch(ctx, <span class="string">"[线程1]"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(ctx, <span class="string">"[线程2]"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(ctx, <span class="string">"[线程3]"</span>)</span><br><span class="line"></span><br><span class="line">index := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">index++</span><br><span class="line">fmt.Printf(<span class="string">"%d 秒过去了 \n"</span>, index)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">if</span> index &gt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"通知停止监控"</span>)</span><br><span class="line">    <span class="comment">// 其实此时已经超时, 协程已经提前退出</span></span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止主进程提前退出</span></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Printf(<span class="string">"%s  监控退出, 停止了...\n"</span>, name)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%s goroutine监控中... \n"</span>, name)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 <code>context.WithTimeout()</code> 给文本流设置一个时间上限, 结合 <code>for+select</code> 去接收消息. 当执行超时,或手动关闭都会给 <code>&lt;-ctx.Done()</code> 发送消息,<br>而且<strong>所有</strong>使用同一个 context 都会收到这个通知, 免去了一个一个通知的繁琐代码</p><h4 id="场景二-类似web服务器中的session"><a href="#场景二-类似web服务器中的session" class="headerlink" title="场景二: 类似web服务器中的session"></a>场景二: 类似web服务器中的session</h4><p>比如在php中(没用swoole扩展), 一个请求进来, 从 <code>$_REQUEST</code> <code>$_SERVER</code> 能获取到的是有关这一条请求的所有信息, 哪怕是使用全局变量也是给这一个请求来服务的, 是线程安全的</p><p>但是 golang 就不一样了, 因为程序本身就能起一个 web sever, 因此就不能随便使用全局变量了, 不然就是内存泄露警告. 但是实际业务当中需要有一个类似session 的东西来承载单次请求的信息, 举一个具体的例子就是: <strong>给每次请求加一个 uniqueID 该如何处理?</strong> 有了这个 uniqueID, 请求的所有日志都能带上它, 这样排查问题的时候方便追踪一次请求发生了什么</p><p>如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">pCtx, pCancel := context.WithCancel(context.Background())</span><br><span class="line">pCtx = context.WithValue(pCtx, <span class="string">"parentKey"</span>, <span class="string">"parentVale"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(pCtx, <span class="string">"[父进程1]"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(pCtx, <span class="string">"[父进程2]"</span>)</span><br><span class="line"></span><br><span class="line">cCtx, cCancel := context.WithCancel(pCtx)</span><br><span class="line"><span class="keyword">go</span> watch(cCtx, <span class="string">"[子进程1]"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(cCtx, <span class="string">"[子进程2]"</span>)</span><br><span class="line">fmt.Println(pCtx.Value(<span class="string">"parentKey"</span>))</span><br><span class="line">fmt.Println(cCtx.Value(<span class="string">"parentKey"</span>))</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"子进程关闭"</span>)</span><br><span class="line">cCancel()</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"父进程关闭"</span>)</span><br><span class="line">pCancel()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最开始的 <code>context.WithCancel(context.Background())</code> 中 <code>context.Background()</code> 就是一个新建的 context, 利用 context 能继承的特性,<br>可以将自己的程序构建出一个 context 树, context 执行 <code>cancel()</code> 将影响到当前 context 和子 context, 不会影响到父级. </p><p>同时 <code>context.WithValue</code> 也会给 context 带上自定义的值, 这样 uniqueID 就能轻松的传递了下去, 而不是一层层的传递参数, 改func什么的</p><p>对于 context 很值得参考的应用有:</p><ul><li><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">Gin</a></li><li><a href="https://github.com/sirupsen/logrus" target="_blank" rel="noopener">logrus</a></li></ul><h3 id="Context-相关-func-和接口"><a href="#Context-相关-func-和接口" class="headerlink" title="Context 相关 func 和接口"></a>Context 相关 func 和接口</h3><p>继承 context 需要实现如下四个接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Err() error</span><br><span class="line"></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用的时候不需要实现接口, 因为官方包里已经基于 <code>emptyCtx</code> 实现了一个, 调用方法有 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最初始的ctx, 之后的子ctx都是继承自它</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不清楚context要干嘛, 但是就得有一个ctx的用这个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承用的函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure></p><ul><li><code>WithCancel</code> 返回一个带 cancel 函数的ctx,</li><li><code>WithDeadline</code>  在到达指定时间时自动执行 cancel()</li><li><p><code>WithTimeout</code> 是 <code>WithDeadline</code>的壳子, 区别就是这个函数是多少时间过后执行 cancel </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) &#123;</span><br><span class="line">return WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>WithValue</code> 继承父类ctx时顺便带上一个值</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang 里出现多 goroutine 的场景很常见, 最常用的两种方式就是 &lt;code&gt;WaitGroup&lt;/code&gt; 和 &lt;code&gt;Context&lt;/code&gt;, 今天我们了解一下 &lt;code&gt;Context&lt;/code&gt; 的应用场景&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="context" scheme="http://blog.justwe.site/tags/context/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 部署 K8s</title>
    <link href="http://blog.justwe.site/2019/06/17/k8s-install-centos7/"/>
    <id>http://blog.justwe.site/2019/06/17/k8s-install-centos7/</id>
    <published>2019-06-17T03:59:54.000Z</published>
    <updated>2019-06-18T02:36:30.567Z</updated>
    
    <content type="html"><![CDATA[<p>都是走的国内镜像源</p><a id="more"></a><h3 id="关闭-selinux"><a href="#关闭-selinux" class="headerlink" title="关闭 selinux"></a>关闭 selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0 #实时动态关闭 selinux</span><br><span class="line">sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/&apos; /etc/selinux/config #禁止重启后自动开启</span><br></pre></td></tr></table></figure><h3 id="关闭交换分区"><a href="#关闭交换分区" class="headerlink" title="关闭交换分区"></a>关闭交换分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a #实时动态关闭交换分区</span><br><span class="line">sed -i &apos;/ swap / s/^/#/&apos; /etc/fstab #禁止重启后自动开启</span><br></pre></td></tr></table></figure><h3 id="网络配置文件"><a href="#网络配置文件" class="headerlink" title="网络配置文件"></a>网络配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">vm.swappiness=0</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">modprobe br_netfilter  #执行该命令 如果不执行就会在应用k8s.conf时出现加载错误</span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf #应用配置文件</span><br></pre></td></tr></table></figure><h3 id="yum换国内源"><a href="#yum换国内源" class="headerlink" title="yum换国内源"></a>yum换国内源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d  &amp;&amp; \</span><br><span class="line">sudo mv CentOS-Base.repo CentOS-Base.repo.bak &amp;&amp; \</span><br><span class="line">sudo wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo &amp;&amp; \</span><br><span class="line">yum clean all &amp;&amp; \</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h3 id="配置k8s资源的下载地址"><a href="#配置k8s资源的下载地址" class="headerlink" title="配置k8s资源的下载地址"></a>配置k8s资源的下载地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line"></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h3 id="docker换源"><a href="#docker换源" class="headerlink" title="docker换源"></a>docker换源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld.service  &amp;&amp; systemctl stop firewalld.service </span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><h3 id="下载k8s依赖镜像"><a href="#下载k8s依赖镜像" class="headerlink" title="下载k8s依赖镜像"></a>下载k8s依赖镜像</h3><p>获取依赖的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images list</span><br></pre></td></tr></table></figure></p><p>国内用户通过阿里云镜像下载k8s依赖组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images list |sed -e &apos;s/^/docker pull /g&apos; -e &apos;s#k8s.gcr.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g&apos; |sh -x</span><br><span class="line"></span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk &apos;&#123;print &quot;docker tag &quot;,$1&quot;:&quot;$2,$1&quot;:&quot;$2&#125;&apos; |sed -e &apos;s#registry.cn-hangzhou.aliyuncs.com/google_containers#k8s.gcr.io#2&apos; |sh -x</span><br><span class="line"></span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk &apos;&#123;print &quot;docker rmi &quot;, $1&quot;:&quot;$2&#125;&apos; |sh -x</span><br></pre></td></tr></table></figure></p><h3 id="主节点初始化"><a href="#主节点初始化" class="headerlink" title="主节点初始化"></a>主节点初始化</h3><p>Kubernetes v1.14.3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=1.14.3</span><br></pre></td></tr></table></figure></p><p>执行成功后出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.31.120:6443 --token 6nelb5.lrc5qbs0k3v64eln \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:c55a113114d664133685430a86f2e39f40e9df6b12ad3f4d65462fd372079e97</span><br></pre></td></tr></table></figure></p><h3 id="node节点启动"><a href="#node节点启动" class="headerlink" title="node节点启动"></a>node节点启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.31.120:6443 --token 6nelb5.lrc5qbs0k3v64eln \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:c55a113114d664133685430a86f2e39f40e9df6b12ad3f4d65462fd372079e97</span><br></pre></td></tr></table></figure><p>就是初始化后的最后一条命令</p><p>主节点执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kubectl get nodes</span><br><span class="line">NAME                    STATUS     ROLES    AGE     VERSION</span><br><span class="line">localhost.localdomain   NotReady   master   40m     v1.14.3</span><br><span class="line">miwifi-r3-srv           NotReady   &lt;none&gt;   3m48s   v1.14.3</span><br></pre></td></tr></table></figure></p><p>状态还是notReady</p><p>查看文档 <a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a> </p><p>这里选了 weave 插件文档： <a href="https://www.weave.works/docs/net/latest/kubernetes/kube-addon/" target="_blank" rel="noopener">https://www.weave.works/docs/net/latest/kubernetes/kube-addon/</a><br>执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &apos;\n&apos;)&quot;</span><br></pre></td></tr></table></figure></p><p>稍微等几分钟就可以看到正常了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kubectl get nodes</span><br><span class="line">NAME                    STATUS     ROLES    AGE   VERSION</span><br><span class="line">localhost.localdomain   Ready      master   49m   v1.14.3</span><br><span class="line">miwifi-r3-srv           Ready      &lt;none&gt;   12m   v1.14.3</span><br></pre></td></tr></table></figure></p><h4 id="kubeadm-token-过期的情况"><a href="#kubeadm-token-过期的情况" class="headerlink" title="kubeadm token 过期的情况"></a>kubeadm token 过期的情况</h4><p><code>kubeadm join</code> 用到的token有效期是24h</p><p>生成 token, 查看token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm token create</span><br><span class="line">rugi2c.bb97e7ney91bogbg</span><br><span class="line">$ kubeadm token list</span><br><span class="line">TOKEN                     TTL       EXPIRES                     USAGES                   DESCRIPTION   EXTRA GROUPS</span><br><span class="line">rugi2c.bb97e7ney91bogbg   23h       2019-06-18T22:28:11+08:00   authentication,signing   &lt;none&gt;        system:bootstrappers:kubeadm:default-node-token</span><br></pre></td></tr></table></figure><p>生成证书<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed &apos;s/^.* //&apos;</span><br></pre></td></tr></table></figure></p><p>新token加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.31.120:6443 --token rugi2c.bb97e7ney91bogbg \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:c55a113114d664133685430a86f2e39f40e9df6b12ad3f4d65462fd372079e97</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/pekkle/p/10545145.html" target="_blank" rel="noopener">搭建教程</a><br><a href="https://jimmysong.io/kubernetes-handbook/practice/node-installation.html" target="_blank" rel="noopener">部署node节点</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都是走的国内镜像源&lt;/p&gt;
    
    </summary>
    
      <category term="k8s" scheme="http://blog.justwe.site/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://blog.justwe.site/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>K8s 安装 Minikube</title>
    <link href="http://blog.justwe.site/2019/05/14/k8s-minikube/"/>
    <id>http://blog.justwe.site/2019/05/14/k8s-minikube/</id>
    <published>2019-05-14T03:04:46.000Z</published>
    <updated>2019-05-14T03:07:30.227Z</updated>
    
    <content type="html"><![CDATA[<p>本地快速装一个微型的kubernetes环境, 翻墙的苦谁能懂?</p><a id="more"></a><h4 id="mac-本地安装minikube环境"><a href="#mac-本地安装minikube环境" class="headerlink" title="mac 本地安装minikube环境"></a>mac 本地安装minikube环境</h4><p>环境需求:</p><ul><li>kubectl       本地做命令行控制用, 所有的命令操作都是通过它</li><li>vittualBox    v5.1 +  更新到最新版本就对了</li><li>minikube      在本地搭建测试环境</li></ul><p>翻墙有困难的可以参考一下这个 <a href="https://yq.aliyun.com/articles/221687" target="_blank" rel="noopener">https://yq.aliyun.com/articles/221687</a></p><p>安装 <code>kubectl</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜   brew install kubectl</span><br></pre></td></tr></table></figure></p><p>下载最新 <code>minikube</code> 不建议使用brew安装,  首先版本不会是最新, 再者会出现莫名其妙的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜   curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 &amp;&amp; \</span><br><span class="line">  chmod +x minikube &amp;&amp; \</span><br><span class="line">  sudo mv minikube /usr/local/bin/</span><br></pre></td></tr></table></figure></p><p>默认 start 时运行的virtualBox 去官网下个最新的就行</p><p>启动, 最好把docker镜像指定到国内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ minikube start --registry-mirror=https://registry.docker-cn.com</span><br><span class="line">😄  minikube v1.0.1 on darwin (amd64)</span><br><span class="line">💿  Downloading Minikube ISO ...</span><br><span class="line"> 142.88 MB / 142.88 MB [============================================] 100.00% 0s</span><br><span class="line">🤹  Downloading Kubernetes v1.14.1 images in the background ...</span><br><span class="line">🔥  Creating virtualbox VM (CPUs=2, Memory=2048MB, Disk=20000MB) ...</span><br><span class="line">📶  &quot;minikube&quot; IP address is 192.168.99.103</span><br><span class="line">🐳  Configuring Docker as the container runtime ...</span><br><span class="line">🐳  Version of container runtime is 18.06.3-ce</span><br><span class="line">⌛  Waiting for image downloads to complete ...</span><br><span class="line">✨  Preparing Kubernetes environment ...</span><br><span class="line">💾  Downloading kubeadm v1.14.1</span><br><span class="line">💾  Downloading kubelet v1.14.1</span><br><span class="line">🚜  Pulling images required by Kubernetes v1.14.1 ...</span><br><span class="line">🚀  Launching Kubernetes v1.14.1 using kubeadm ...</span><br><span class="line">⌛  Waiting for pods: apiserver proxy etcd scheduler controller dns</span><br><span class="line">🔑  Configuring cluster permissions ...</span><br><span class="line">🤔  Verifying component health .....</span><br><span class="line">💗  kubectl is now configured to use &quot;minikube&quot;</span><br><span class="line">🏄  Done! Thank you for using minikube!</span><br><span class="line">➜  ~ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https://192.168.99.103:8443</span><br><span class="line">KubeDNS is running at https://192.168.99.103:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &apos;kubectl cluster-info dump&apos;.</span><br></pre></td></tr></table></figure></p><p>如果<code>Minikube ISO</code>存在墙的问题, 就把iso下载后放到 <code>~/.minikube/cache/iso/</code>下</p><p>这时Mac上的docker不能用docker for Mac提供的了, 而是宿主机里面的docker, 切换命令为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜   eval $(minikube docker-env)</span><br></pre></td></tr></table></figure></p><p>撤销更改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜   eval $(minikube docker-env -u)</span><br></pre></td></tr></table></figure></p><p>加载后台控制面板, 稍等一会, 自动打卡后台界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜   minikube dashboard</span><br></pre></td></tr></table></figure></p><h4 id="部署第一个应用"><a href="#部署第一个应用" class="headerlink" title="部署第一个应用"></a>部署第一个应用</h4><h5 id="命令行部署"><a href="#命令行部署" class="headerlink" title="命令行部署"></a>命令行部署</h5><h6 id="创建node-js-应用"><a href="#创建node-js-应用" class="headerlink" title="创建node.js 应用"></a>创建node.js 应用</h6><p>创建文件 <code>server.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handleRequest = <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received request for URL: '</span> + request.url);</span><br><span class="line">  response.writeHead(<span class="number">200</span>);</span><br><span class="line">  response.end(<span class="string">'Hello World! V1'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> www = http.createServer(handleRequest);</span><br><span class="line">www.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js   // 访问地址  http://localhost:3000</span><br></pre></td></tr></table></figure></p><h6 id="创建docker镜像"><a href="#创建docker镜像" class="headerlink" title="创建docker镜像"></a>创建docker镜像</h6><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.10</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> server.js .</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"node"</span>, <span class="string">"server.js"</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ docker build -t hello-node:v1 .</span><br></pre></td></tr></table></figure></p><p>如果出现<code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code> 说明你忘了执行 <code>eval $(minikube docker-env)</code><br><strong>kube用的 docker 和你本地用的 docker 是两个位置, kube的在虚拟机里运行</strong></p><h6 id="创建-deployment"><a href="#创建-deployment" class="headerlink" title="创建 deployment"></a>创建 deployment</h6><p>有了镜像就具备创建pod的条件, 通常来说不用直接创建 <code>pod</code>, 而是创建 <code>deployment</code> 或者 <code>replication controller</code>, 由他们来负责管理服务的运行, 规模缩放, 自动重启等等这些操作, 就单个<code>pod</code>来说是可以随时被销毁的, 不能作为稳定服务的保证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl run hello-node --image=hello-node:v1 --port=3000</span><br><span class="line">或</span><br><span class="line">➜ kubectl create deployment hello-node --image=hello-node:v1</span><br></pre></td></tr></table></figure><p>查看当前<code>deployment</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get deployments </span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">hello-node     1/1     1            1           8m8s</span><br></pre></td></tr></table></figure></p><p><code>ready 1/1</code> 说明已经准备就绪了 </p><p>查看 <code>pod</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  hellonode git:(master) ✗ kubectl get pods</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">hello-node-5c58cb6dd4-h65fx     1/1     Running   0          8m40s</span><br></pre></td></tr></table></figure></p><p>从这两条信息就能看出来, 每个pod都是带随机字符串的, 并不打算给人去操作, 我们主要专注在<code>deployment</code>和 <code>service</code> 的搭建</p><p>查看 <code>deployment</code> 描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl describe deployments/hello-node</span><br><span class="line"></span><br><span class="line">Name:                   hello-node</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Mon, 13 May 2019 14:17:03 +0800</span><br><span class="line">Labels:                 run=hello-node</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               run=hello-node</span><br><span class="line">Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  run=hello-node</span><br><span class="line">  Containers:</span><br><span class="line">   hello-node:</span><br><span class="line">    Image:        hello-node:v1</span><br><span class="line">    Port:         3000/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">  Progressing    True    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   hello-node-5c58cb6dd4 (1/1 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  11m   deployment-controller  Scaled up replica set hello-node-5c58cb6dd4 to 1</span><br></pre></td></tr></table></figure></p><p>这里是对<code>deployment</code>的概览, <code>Pod Template:</code> 下就是每个pods的配置, 之后对部署的扩容都是基于这个去复制</p><p>到目前为止我们创建了<code>deployment</code> 而且也自动生成<code>pod</code>了, 可是服务并不能被访问到, 为什么? 因为端口没有对外暴露出来, 所以有了下一步</p><h6 id="创建service"><a href="#创建service" class="headerlink" title="创建service"></a>创建service</h6><p><code>service</code> 就是用来对我暴露服务的东西, 所有的 <code>pod</code> 都是在内网通信, 外部访问就得让 <code>service</code> 这层代理去转发过去, <code>--type=LoadBalancer</code> 就是指定转发为负载均衡模式, <code>kubectl create service -h</code> 查看更多, 这里不细讲</p><p>创建service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl expose deployment hello-node --type=LoadBalancer</span><br><span class="line">或</span><br><span class="line">➜ kubectl expose deployment hello-node --type=LoadBalancer --port=3000 // 这里指定端口</span><br></pre></td></tr></table></figure></p><p>查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl get service                                     </span><br><span class="line">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">hello-node   LoadBalancer   10.111.18.151   &lt;pending&gt;     3000:31349/TCP   3s</span><br><span class="line">kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          3d</span><br></pre></td></tr></table></figure></p><p>详细信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl describe services hello-node </span><br><span class="line">Name:                     hello-node</span><br><span class="line">Namespace:                default</span><br><span class="line">Labels:                   run=hello-node</span><br><span class="line">Annotations:              &lt;none&gt;</span><br><span class="line">Selector:                 run=hello-node</span><br><span class="line">Type:                     LoadBalancer</span><br><span class="line">IP:                       10.111.18.151</span><br><span class="line">Port:                     &lt;unset&gt;  3000/TCP</span><br><span class="line">TargetPort:               3000/TCP</span><br><span class="line">NodePort:                 &lt;unset&gt;  31349/TCP</span><br><span class="line">Endpoints:                172.17.0.7:3000</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p><code>NodePort</code> 就是绑定在节点的那个端口上, 直接访问节点ip就行, 也可以用minikube命令 <code>minikube service hello-node</code> 自动帮你打开本地地址</p><h6 id="扩展示例"><a href="#扩展示例" class="headerlink" title="扩展示例"></a>扩展示例</h6><p>线上肯定是有这种动态扩容的情况, 而且多实例之间滚动升级也不会停止服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl scale deployments/hello-node --replicas=4</span><br><span class="line">deployment.extensions/hello-node scaled</span><br><span class="line">➜  hellonode git:(master) ✗ kubectl get pods</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">hello-node-5c58cb6dd4-d2qq9   1/1     Running   0          18s</span><br><span class="line">hello-node-5c58cb6dd4-h65fx   1/1     Running   0          51m</span><br><span class="line">hello-node-5c58cb6dd4-jlzjw   1/1     Running   0          18s</span><br><span class="line">hello-node-5c58cb6dd4-vmx4f   1/1     Running   0          18s</span><br></pre></td></tr></table></figure></p><h6 id="更新应用"><a href="#更新应用" class="headerlink" title="更新应用"></a>更新应用</h6><p>重新构建一个node的镜像<br>service.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handleRequest = <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received request for URL: '</span> + request.url);</span><br><span class="line">  response.writeHead(<span class="number">200</span>);</span><br><span class="line">  response.end(<span class="string">'Hello World! V2'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> www = http.createServer(handleRequest);</span><br><span class="line">www.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ docker build -t hello-node:v2 .</span><br></pre></td></tr></table></figure><p>设置 <code>deployment</code> 使用新镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl set image deployment/hello-node hello-node=hello-node:v2</span><br></pre></td></tr></table></figure></p><p>查看每个pod的具体情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl describe pods</span><br></pre></td></tr></table></figure></p><p>再访问刚才的地址就能看到改变了</p><h6 id="清除资源"><a href="#清除资源" class="headerlink" title="清除资源"></a>清除资源</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl delete service hello-node</span><br><span class="line">➜ kubectl delete deployments hello-node</span><br></pre></td></tr></table></figure><p>经过上面一套操作下来, 应该也对k8s有了一个大致的印象了, 毕竟光看实践才是检验真理的唯一标准, 但是如果部署一个服务这样一个命令一个命令的敲是很要命的, 而且服务器这玩意, 轻易不会动, 时间一长就容易忘, 因此用配置文件去启动更加合理</p><h5 id="通过-yaml-启动"><a href="#通过-yaml-启动" class="headerlink" title="通过 yaml 启动"></a>通过 yaml 启动</h5><p>如下: test-service.yaml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-service</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">v2</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">hello-node</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">test-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">3001</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">test-service</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-service</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">test-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">test-service</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">test-service</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">node-pod</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">hello-node:v2</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">        ports:</span> </span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl create -f test-service.yaml</span><br><span class="line">➜ minikube service test-service</span><br></pre></td></tr></table></figure></p><p>这样通过配置文件就能启动了, 配置文件里里的字段后续我们再详细的讲一下</p><p>删除<code>kubectl delete -f test-service.yaml</code></p><p><a href="https://github.com/gaopengfei123123/k8s_study/tree/master/demo/hellonode" target="_blank" rel="noopener">代码地址</a></p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><p><a href="https://segmentfault.com/a/1190000014116698#articleHeader16" target="_blank" rel="noopener">带你理解Kubernetes，部署一个Node应用</a><br><a href="http://dockone.io/article/4884" target="_blank" rel="noopener">Kubernetes的三种外部访问方式：NodePort、LoadBalancer 和 Ingress</a><br><a href="https://yq.aliyun.com/articles/221687" target="_blank" rel="noopener">Minikube - Kubernetes本地实验环境</a><br><a href="https://blog.csdn.net/cc1949/article/details/78842291" target="_blank" rel="noopener">Kubernetes之kubectl常用命令</a><br><a href="https://www.cnblogs.com/boshen-hzb/p/7097811.html" target="_blank" rel="noopener">replication controller与deployment的区别</a><br><a href="https://blog.csdn.net/weixin_33979203/article/details/89613400" target="_blank" rel="noopener">Kubenetes里pod和service绑定的实现方式</a><br><a href="https://www.jianshu.com/p/bf3fb3a6e688" target="_blank" rel="noopener">Kubernetes创建资源对象yaml文件例子</a><br><a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">kubernetes/minikube github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地快速装一个微型的kubernetes环境, 翻墙的苦谁能懂?&lt;/p&gt;
    
    </summary>
    
      <category term="k8s" scheme="http://blog.justwe.site/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://blog.justwe.site/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Docker for Mac 部署 Kubernetes</title>
    <link href="http://blog.justwe.site/2019/05/06/k8s-install-docker/"/>
    <id>http://blog.justwe.site/2019/05/06/k8s-install-docker/</id>
    <published>2019-05-06T07:58:16.000Z</published>
    <updated>2019-05-14T03:06:11.150Z</updated>
    
    <content type="html"><![CDATA[<p><code>docker for mac</code> 安装kubernetes本来是很方便的, 但是国内玩家要折腾一下, 因为 <code>gcr.io</code> 这个域被墙了…</p><p>目前来看前辈们已经把坑给淌的差不多了, 我老早的时候也被折腾的头秃, 这里就做个总结<br><a id="more"></a></p><h4 id="通过代理翻墙下载镜像"><a href="#通过代理翻墙下载镜像" class="headerlink" title="通过代理翻墙下载镜像"></a>通过代理翻墙下载镜像</h4><p>这个方法相对来说一劳永逸, 缺点是每个月有vpn的花费, 我代理用的shadowsockets, 就拿这个来举例:</p><p>首先安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install privoxy</span><br></pre></td></tr></table></figure></p><p>添加配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/etc/privoxy/config</span><br></pre></td></tr></table></figure><p>配置内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen-address 0.0.0.0:8118</span><br><span class="line">forward-socks5 / localhost:1080 .</span><br></pre></td></tr></table></figure></p><p>监听本地8118端口, 转发到 localhost:1080, 这也是ss的客户端的转发端口</p><p>启动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start privoxy</span><br></pre></td></tr></table></figure></p><p>转发部分完成, 接下来在 <code>docker for mac</code>配置</p><p><code>docker for mac</code> &gt; <code>preferences</code> &gt; <code>Proxies</code> &gt; 点击 <code>Manual proxy configuration</code></p><p><code>Web Server(HTTP)</code> 和 <code>Secure Web Server (HTTPS)</code> 都填入 <code>http://{你机器IP}:8118</code> 比如: ‘<a href="http://192.168.110.203:8118&#39;" target="_blank" rel="noopener">http://192.168.110.203:8118&#39;</a></p><p>不能用 127.0.0.1, 因为 docker for mac 启动后, docker 是运行在一个虚拟机中,而不是macOS下, 因此这个地址代表的意义不一样</p><p>点保存, 这样就能正常安装k8s了, 可以通过活动监视器看一下他们的流量是否正常</p><p><a href="https://juejin.im/post/58dcd8dd44d904006dfe148b" target="_blank" rel="noopener">教程来源</a></p><h4 id="自己预先加载一套镜像来"><a href="#自己预先加载一套镜像来" class="headerlink" title="自己预先加载一套镜像来"></a>自己预先加载一套镜像来</h4><p>找个目录, 新建 <code>images.properties</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/pause-amd64:3.1=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.10.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.10.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.10.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.10.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver-amd64:v1.10.3</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.1.12=registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.12</span><br><span class="line">k8s.gcr.io/k8s-dns-sidecar-amd64:1.14.8=registry.cn-hangzhou.aliyuncs.com/google_containers/k8s-dns-sidecar-amd64:1.14.8</span><br><span class="line">k8s.gcr.io/k8s-dns-kube-dns-amd64:1.14.8=registry.cn-hangzhou.aliyuncs.com/google_containers/k8s-dns-kube-dns-amd64:1.14.8</span><br><span class="line">k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64:1.14.8=registry.cn-hangzhou.aliyuncs.com/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.8</span><br><span class="line">k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3=registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64:v1.8.3</span><br></pre></td></tr></table></figure></p><p>新建脚本: <code>kubernetes.sh</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"></span><br><span class="line">file=<span class="string">"./images.properties"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$file</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> found."</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> IFS=<span class="string">'='</span> <span class="built_in">read</span> -r key value</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="comment">#echo "$&#123;key&#125;=$&#123;value&#125;"</span></span><br><span class="line">    docker pull <span class="variable">$&#123;value&#125;</span></span><br><span class="line">    docker tag <span class="variable">$&#123;value&#125;</span> <span class="variable">$&#123;key&#125;</span></span><br><span class="line">    docker rmi <span class="variable">$&#123;value&#125;</span></span><br><span class="line">  <span class="keyword">done</span> &lt; <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> not found."</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>运行就行</p><p><a href="https://my.oschina.net/wubiaowpBlogShare/blog/1921180" target="_blank" rel="noopener">教程来源</a><br><a href="https://github.com/maguowei/k8s-docker-for-mac/tree/master/image" target="_blank" rel="noopener">k8s-docker-for-mac</a></p><h4 id="找个gcr-io的国内镜像"><a href="#找个gcr-io的国内镜像" class="headerlink" title="找个gcr.io的国内镜像"></a>找个gcr.io的国内镜像</h4><p>这个是利用了<code>dockerHub</code> 因为都是国外的, 先让<code>dockerHub</code>给build一下, 然后直接拉<code>dockerHub</code>的镜像来迂回一下</p><p><a href="https://anjia0532.github.io/2017/11/15/gcr-io-image-mirror/" target="_blank" rel="noopener">Google Container Registry(gcr.io) 中国可用镜像(长期维护)</a><br><a href="https://github.com/anjia0532/gcr.io_mirror" target="_blank" rel="noopener">gcr.io_mirror</a><br><a href="https://jeremyxu2010.github.io/2018/05/%E5%9F%BA%E4%BA%8Edocker-for-macos%E7%9A%84kubernetes%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/" target="_blank" rel="noopener">基于Docker for macOS的Kubernetes本地环境搭建与应用部署</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;docker for mac&lt;/code&gt; 安装kubernetes本来是很方便的, 但是国内玩家要折腾一下, 因为 &lt;code&gt;gcr.io&lt;/code&gt; 这个域被墙了…&lt;/p&gt;
&lt;p&gt;目前来看前辈们已经把坑给淌的差不多了, 我老早的时候也被折腾的头秃, 这里就做个总结&lt;br&gt;
    
    </summary>
    
      <category term="k8s" scheme="http://blog.justwe.site/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://blog.justwe.site/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter 对Tcp进行压测</title>
    <link href="http://blog.justwe.site/2019/04/30/tools-jmeter/"/>
    <id>http://blog.justwe.site/2019/04/30/tools-jmeter/</id>
    <published>2019-04-30T09:45:59.000Z</published>
    <updated>2019-04-30T10:35:17.847Z</updated>
    
    <content type="html"><![CDATA[<p>jmeter是个好工具, 跨平台, 有GUI, 简单易用, 扩展多</p><a id="more"></a><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>本地环境为macOS Mojave 10.14.4</p><p><strong>本地需要安装java8</strong><br><a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">jmeter官方下载地址</a><br><a href="https://jmeter-plugins.org/install/Install/" target="_blank" rel="noopener">jmeter插件下载</a></p><p>当前下载的jmeter版本为 5.1.1<br>解压下载之后, 运行命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ~/Downloads/apache-jmeter-5.1.1/bin/jmeter</span><br></pre></td></tr></table></figure></p><p>就运行起来了</p><h4 id="进行tcp压测"><a href="#进行tcp压测" class="headerlink" title="进行tcp压测"></a>进行tcp压测</h4><h5 id="首先创建Thread-Group"><a href="#首先创建Thread-Group" class="headerlink" title="首先创建Thread Group"></a>首先创建Thread Group</h5><p><img src="/images/jmeter/jmeter_1.jpg" alt="img"></p><p>注意几个关键点:</p><ul><li>Number of Threads (users)     创建进程组, 相当于多少并发</li><li>Ramp-Up Period (in seconds)   设定的并发值在多少秒内到达预期, 模拟自然流量</li><li>Loop Count   每个进程组循环多少次             </li></ul><p><code>Loop Count</code> * <code>Number of Threads</code> 就是整体请求数量了</p><h5 id="创建tcp-Sampler"><a href="#创建tcp-Sampler" class="headerlink" title="创建tcp Sampler"></a>创建tcp Sampler</h5><p><img src="/images/jmeter/jmeter_2.jpg" alt="img"></p><p>这篇文章是使用最基本的文字tcp传输</p><p><img src="/images/jmeter/jmeter_3.jpg" alt="img"></p><p>看图说话, TCP classname默认为: <code>org.apache.jmeter.protocol.tcp.sampler.TCPClientImpl</code>, 可以直接从 <code>Text to send</code> 中传入文本<br>传文本的时候<strong>一定</strong>要输入之后加一个回车,写<code>\n</code>都不管用, <strong>必须</strong> 是回车, 它是自动转换的, 不然会造成数据找不到终止断点</p><p>如果使用 <code>org.apache.jmeter.protocol.tcp.sampler.BinaryTCPClientImpl</code> 则需要在 <code>End of line byte value</code> 里面传值, 通常是<code>10</code><br>且  <code>Text to send</code> 传的是16进制数据</p><h4 id="创建-summary-report"><a href="#创建-summary-report" class="headerlink" title="创建 summary report"></a>创建 summary report</h4><p><img src="/images/jmeter/jmeter_4.jpg" alt="img"></p><p>用于做统计表格</p><h4 id="创建-view-results-tree"><a href="#创建-view-results-tree" class="headerlink" title="创建 view results tree"></a>创建 view results tree</h4><p><img src="/images/jmeter/jmeter_5.jpg" alt="img"></p><p>用于查看请求数据返回数据</p><h4 id="安装cpu-内存监控插件"><a href="#安装cpu-内存监控插件" class="headerlink" title="安装cpu/内存监控插件"></a>安装cpu/内存监控插件</h4><p>5.1.1 版本的和之前搜的有些不一样, 现在有了一个内置的扩展商店</p><p><a href="https://jmeter-plugins.org/install/Install/" target="_blank" rel="noopener">扩展下载地址</a></p><p><code>Download plugins-manager.jar and put it into lib/ext directory, then restart JMeter.</code></p><p>看到这句话没?  点就行了, 然后把它放到jmeter目录 <code>lib/ext</code>下,重启jmeter就能看到了</p><p><img src="/images/jmeter/jmeter_6.jpg" alt="img"></p><ol><li>点进去搜索 <code>PerfMon</code> ,就是我们要找的了, 点击安装 , 从插件简介里也能看到<a href="https://jmeter-plugins.org/wiki/PerfMon/" target="_blank" rel="noopener">文档地址</a></li><li>在文档中找到 <code>Server Agent</code>的<a href="https://github.com/undera/perfmon-agent/blob/master/README.md" target="_blank" rel="noopener">下载地址</a></li><li>在被测服务器中安装 Server Agent , linux 直接运行 <code>serverAgent.sh</code> 默认端口为 4444</li></ol><p>添加监控:<br><img src="/images/jmeter/jmeter_7.jpg" alt="img"><br>点 <code>Add Row</code> 添加目标服务器的ip和端口就行, 端口默认4444</p><p>以上就是一套简单的tcp压测测试了</p><p><a href="/2019/04/30/tools-jmeter/">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jmeter是个好工具, 跨平台, 有GUI, 简单易用, 扩展多&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.justwe.site/categories/tools/"/>
    
    
      <category term="jmeter" scheme="http://blog.justwe.site/tags/jmeter/"/>
    
  </entry>
  
  <entry>
    <title>Php开发过程中不常碰到的error (2.28更新)</title>
    <link href="http://blog.justwe.site/2019/02/28/php-unsual-mistakes/"/>
    <id>http://blog.justwe.site/2019/02/28/php-unsual-mistakes/</id>
    <published>2019-02-28T02:30:23.000Z</published>
    <updated>2019-02-28T06:25:49.384Z</updated>
    
    <content type="html"><![CDATA[<p>这里做一些备注,以防再次碰到<br><a id="more"></a></p><h3 id="url-当中的参数有-amp-timestamp-1234567890这样的字段会被转义成xtamp-1234567890"><a href="#url-当中的参数有-amp-timestamp-1234567890这样的字段会被转义成xtamp-1234567890" class="headerlink" title="url 当中的参数有 &amp;timestamp=1234567890这样的字段会被转义成xtamp=1234567890"></a>url 当中的参数有 <code>&amp;timestamp=1234567890</code>这样的字段会被转义成<code>xtamp=1234567890</code></h3><p>这个不仅存在于页面解析当中,当使用 curl 请求时拼接的参数有这种格式的也会发生转义<br>解决方法有两个:</p><ol><li>把 timestamp 这个参数放在 urlQuery 的最前面, <code>?timestamp=1234567890</code> 这样避免出现 <code>&amp;time</code>发生转义的情况</li><li>将<code>&amp;</code>用<code>&amp;amp;</code>来代替</li></ol><h3 id="Automatically-populating-HTTP-RAW-POST-DATA-is-deprecated-and-will-be-removed-in-a-future-version"><a href="#Automatically-populating-HTTP-RAW-POST-DATA-is-deprecated-and-will-be-removed-in-a-future-version" class="headerlink" title="Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version."></a>Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.</h3><p>出现这句话通常说明你在用的 php 版本是5.6.而且在<code>php&lt;=5.6</code>的时候,进行 <code>application/json</code>格式的 post 提交会把数据放在<code>$HTTP_RAW_POST_DATA</code>这个系统变量里面,在<code>php&gt;=7</code>的时候这个变量被移除了,统统归总到<code>php://input</code>这里<br>解决方法:</p><ol><li><p>根据系统提示的走:</p><blockquote><p>Although that indeed would be technically impossible (as $HTTP_RAW_POST_DATA is populated in the bootstrapping phase of the PHP process) allow one to override the setting by means of calling ini_set.</p></blockquote><p> 要确保自己的系统中没有使用 <code>HTTP_RAW_POST_DATA</code>这个变量,直接在<code>php.ini</code>里面禁掉它的设置,但是容易出现系统中又打开的情况(在框架中很常见)</p></li><li>改一下自己的提交方式, 使用 <code>application/form-data</code>或者<code>application/x-www-form-urlencoded</code>这种格式的提交, 然后在后端接收数据的时候再转成自己需要的格式(通常是数组)<br> <a href="https://www.bram.us/2014/10/26/php-5-6-automatically-populating-http_raw_post_data-is-deprecated-and-will-be-removed-in-a-future-version/" target="_blank" rel="noopener">参考资料</a></li></ol><h3 id="Exception-‘yii-db-Exception’-with-message-‘SQLSTATE-HY000-2002-No-such-file-or-directory’"><a href="#Exception-‘yii-db-Exception’-with-message-‘SQLSTATE-HY000-2002-No-such-file-or-directory’" class="headerlink" title="Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’"></a>Exception ‘yii\db\Exception’ with message ‘SQLSTATE[HY000] [2002] No such file or directory’</h3><p>这种情况出现在平时运行的好好的, 但是突然换 cli 模式后这个配置就出问题了,原因在当 <code>host=localhost</code>时走的是 unix:socket 链接, 当<code>host=127.0.0.1</code>走的是 tcp 链接,这在<code>php-fpm</code>和<code>php-cli</code>中有点区别,尤其是本地没有安装 mysql 的时候<br>解决方法有三种:</p><ol><li>将本地链接配置统一成 <code>127.0.0.1</code></li><li>查看 MySQL 中的<code>user</code>表, <code>host=localhost</code>和<code>host=127.0.0.1</code>是不是用的同一个账号密码</li><li>配置<code>php.ini</code>文件中的<code>pdo_mysql.default_socket=</code> 写上完整的 socket 路径<br>以上三种方法都可以试一下<br><a href="http://www.cnblogs.com/mengdeep/p/7487910.html" target="_blank" rel="noopener">参考资料</a></li></ol><h3 id="常驻内存时发生的事情"><a href="#常驻内存时发生的事情" class="headerlink" title="常驻内存时发生的事情"></a>常驻内存时发生的事情</h3><p>这个是 phper 很少碰到但是很常见的情况, 比如用 swoole 启动了一个常驻进程的服务, 那么就一定要小心使用静态变量,在同步模式下会发生变量污染, 还有就是 redis,mysql 这类的链接,你会发现长时间静置以后就会出现一些摸不着头脑的问题, 这种情况不妨想一下是不是 server 端回收了这个 socket,因此在 client 端怎么都写入不进去.  还有就是 php 在读取消息的时候,出现消息过长的情况,那么就要考虑EOF终止符的问题了… 单次 http 每一次请求都是全新的代码, 不用自己考虑 gc 的问题, 但是在常驻内存的时候,这些就是一个个的大坑了</p><h3 id="mysql-has-gone-away"><a href="#mysql-has-gone-away" class="headerlink" title="mysql has gone away"></a>mysql has gone away</h3><p>产生这个错误的主要原因是 mysql server 端断开了链接, client 端还拿着这个句柄去请求,解决方式有两种:</p><ol><li><p><code>show global variables like &#39;%timeout&#39;;</code> 查看 wait_timeout 的时长,适当的调长一点, 这种方法治标不治本,而且有隐患</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global wait_timeout=10;</span><br><span class="line">mysql&gt; show global variables like <span class="string">'wait_timeout'</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 mysql 之前需要 mysql_ping() 一下, 如果出现断开的错误就启动重连机制</p></li></ol><h3 id="js-和-php-交互传中文参数的编解码问题"><a href="#js-和-php-交互传中文参数的编解码问题" class="headerlink" title="js 和 php 交互传中文参数的编解码问题"></a>js 和 php 交互传中文参数的编解码问题</h3><p>之前碰到了问题是:<br>在 php 端 urlencode 的值为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderid%3D21111111110001954%26pid%3D257742%26reason%3D%E4%B8%AA%E4%BA%BA%E6%96%B9%E9%9D%A2%E5%8E%9F%E5%9B%A0_%E4%BD%BF%E7%94%A8%E7%BA%A2%E5%8C%85%E9%87%8D%E6%96%B0%E4%B8%8B%E5%8D%95%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f</span><br></pre></td></tr></table></figure></p><p>需要 urldecode 一次</p><p>而在 js 端的结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderid%3D21111111110002170%26pid%3D257742%26reason%3D%25E4%25B8%25AA%25E4%25BA%25BA%25E6%2596%25B9%25E9%259D%25A2%25E5%258E%259F%25E5%259B%25A0_%25E4%25B8%25AA%25E4%25BA%25BA%25E8%25BA%25AB%25E4%25BD%2593%25E5%258E%259F%25E5%259B%25A0%26token%3D041d9e5575f480b7bfd58b09bd14ab1c7ee9e9594f2fcdb9f0e3e39fc634b48f</span><br></pre></td></tr></table></figure></p><p>需要 urldecode 两次</p><p>查阅资料后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在后端是PHP程序的情况下，保持前端Javascript和PHP之间传值的统一编码可以使用以下函数进行处理：</span><br><span class="line"> </span><br><span class="line">WEB前端JavaScript</span><br><span class="line"> </span><br><span class="line">编码：escape(encodeURI(string))</span><br><span class="line"> </span><br><span class="line">解码：unescape(decodeURI(string))</span><br><span class="line"> </span><br><span class="line">WEB后端Php</span><br><span class="line"> </span><br><span class="line">编码：urlencode(string)</span><br><span class="line"> </span><br><span class="line">解码：urldecode(urldecode(string))</span><br></pre></td></tr></table></figure></p><p><a href="https://bbs.csdn.net/topics/330072196" target="_blank" rel="noopener">为什么要encodeURI(url)两次才不会出现乱码？</a></p><h3 id="PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent-的区别"><a href="#PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent-的区别" class="headerlink" title="PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent 的区别"></a>PHP中rawurlencode和urlencode、JS中encodeURI与encodeURIComponent 的区别</h3><p>rawurlencode遵守是94年国际标准备忘录RFC 1738</p><p>urlencode实现的是传统做法，和上者的主要区别是对空格的转义是’+’而不是’%20’<br>javascript的encodeURL也是94年标准，而javascript的escape是另一种用”%xxx”标记unicode编码的方法。<br>推荐在PHP中使用用rawurlencode。弃用urlencode</p><p>样例<br>source:<br>超级无敌的人sadha sajdh数据样本sdls fhejrthcxzb.file.jpeg </p><p>PHP urlencode:<br>%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha+sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls+fhejrthcxzb.file.jpeg </p><p>PHP rawurlencode:<br>%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg</p><p>Javascript encodeURI|encodeURIComponent:<br>%E8%B6%85%E7%BA%A7%E6%97%A0%E6%95%8C%E7%9A%84%E4%BA%BAsadha%20sajdh%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%ACsdls%20fhejrthcxzb.file.jpeg </p><p>Javascript escape:<br>%u8D85%u7EA7%u65E0%u654C%u7684%u4EBAsadha%20sajdh%u6570%u636E%u6837%u672Csdls%20fhejrthcxzb.file.jpeg</p><p><a href="https://blog.csdn.net/suofiya2008/article/details/6397168" target="_blank" rel="noopener">帖子原文</a></p><p>在前端还有个问题就是, js 的 <code>encodeURIComponent</code> 和 <code>encodeURI</code> 都不会转换 <code>_-.!~*&#39;()#</code> 这些保留字符, 而在后端的<code>rawurlencode</code> 则是会转换的, 因此需要前端单独把这几个给拎出来, 如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"*"</span>.charCodeAt(<span class="number">0</span>) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">42</span>) <span class="comment">// *</span></span><br></pre></td></tr></table></figure></p><p>这里有张图说的很明白<br><img src="http://blog-image.onlyoneip.com/urlencode.jpeg" alt=""><br><a href="https://www.zhihu.com/question/21861899/answer/91279362" target="_blank" rel="noopener">图片来源</a></p><h3 id="关于出现-lt-U-200B-gt-这种-zero-width-space-字符"><a href="#关于出现-lt-U-200B-gt-这种-zero-width-space-字符" class="headerlink" title="关于出现 &lt;U+200B&gt; 这种 zero-width space 字符"></a>关于出现 &lt;U+200B&gt; 这种 zero-width space 字符</h3><p>如果出现 <code>mb_substr</code> 这类操作的时候, 会出现字数判断错误的问题, 这个有时候很难排查, 因为在 win 上,使用命令行或者 linux 上用<code>cat</code>命令是看不到字符间是有 &lt;U+200B&gt; 的, 如下:<br><img src="http://blog-image.onlyoneip.com/zero-width%20space.png" alt=""></p><p>这玩意儿出现的场景就是: 在前端输入框中输入几个字, 然后复制粘贴.  这样尽管看起来之间没有空格, 但是其中还是插入了这个字符<br>这个就是 <a href="https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%AE%BD%E7%A9%BA%E6%A0%BC" target="_blank" rel="noopener">zero-width space 零宽空格</a>, 处理的办法也很简单, 前端传值之前给过滤一下, 比如 <a href="https://stackoverflow.com/questions/7055600/u200b-zero-width-space-characters-in-my-js-code-where-did-they-come-from" target="_blank" rel="noopener">https://stackoverflow.com/questions/7055600/u200b-zero-width-space-characters-in-my-js-code-where-did-they-come-from</a> 或 <a href="https://codeday.me/bug/20171122/97765.html" target="_blank" rel="noopener">https://codeday.me/bug/20171122/97765.html</a></p><p>后端 php 处理的话和这个不一样, 使用 utf-8 的处理方式, 可以参考这篇文章 <a href="https://blog.csdn.net/qq_28018283/article/details/54136480" target="_blank" rel="noopener">特殊字符<200b><200c><200d>的删除办法与原理</200d></200c></200b></a></p><p>替换这种编码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$value = str_replace(<span class="string">"\xe2\x80\x8b"</span>, <span class="string">''</span>, $value);</span><br><span class="line">$value = str_replace(<span class="string">"\xe2\x80\x8c"</span>, <span class="string">''</span>, $value);</span><br><span class="line">$value = str_replace(<span class="string">"\xe2\x80\x8d"</span>, <span class="string">''</span>, $value);</span><br></pre></td></tr></table></figure></p><p>编码对照如下:<br><img src="http://blog-image.onlyoneip.com/zero-width-space-2.png" alt=""></p><h3 id="mac-设置crontab-e-：-“-usr-bin-vi”-exited-with-status-1"><a href="#mac-设置crontab-e-：-“-usr-bin-vi”-exited-with-status-1" class="headerlink" title="mac 设置crontab -e ： “/usr/bin/vi” exited with status 1"></a>mac 设置crontab -e ： “/usr/bin/vi” exited with status 1</h3><p>输入以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> EDITOR=vim</span><br><span class="line">sudo touch /etc/crontab</span><br><span class="line">crontab -e</span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure></p><p>把默认编辑器从 vi 改成 vim</p><p><a href="https://segmentfault.com/a/1190000013774374" target="_blank" rel="noopener">原文</a></p><h3 id="出现-The-“https-bower-herokuapp-com-packages-jquery-quot-file-could-not-be-downloaded-HTTP-1-1-502-Bad-Gateway"><a href="#出现-The-“https-bower-herokuapp-com-packages-jquery-quot-file-could-not-be-downloaded-HTTP-1-1-502-Bad-Gateway" class="headerlink" title="出现: The “https://bower.herokuapp.com/packages/jquery&quot; file could not be downloaded (HTTP/1.1 502 Bad Gateway)"></a>出现: The “<a href="https://bower.herokuapp.com/packages/jquery&quot;" target="_blank" rel="noopener">https://bower.herokuapp.com/packages/jquery&quot;</a> file could not be downloaded (HTTP/1.1 502 Bad Gateway)</h3><p>yii2 更新的时候静态资源出现问题, 执行 <code>composer global require &quot;fxp/composer-asset-plugin:~1.4.4&quot;</code></p><p><a href="https://stackoverflow.com/questions/51441090/yii2-bower-error-heroku" target="_blank" rel="noopener">问题来源</a></p><h3 id="出现-Jquery-UI-1-11-4-and-jquery-3-0-的版本兼容问题"><a href="#出现-Jquery-UI-1-11-4-and-jquery-3-0-的版本兼容问题" class="headerlink" title="出现: Jquery UI 1.11.4 and jquery 3.0 的版本兼容问题"></a>出现: Jquery UI 1.11.4 and jquery 3.0 的版本兼容问题</h3><p>这个是在部署 adminLTE + rbac 时候遇上的, 打开 <code>/admin/menu/create</code> 会报 <code>Jquery UI error - f.getClientRects is not a function</code> 错误</p><p>解决方法:<br>配置文件: config/web.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="string">'components'</span> =&gt; [</span><br><span class="line">     ...</span><br><span class="line">        <span class="comment">//静态资源</span></span><br><span class="line">        <span class="string">'assetManager'</span> =&gt; [</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">'assetMap'</span> =&gt; [</span><br><span class="line">                <span class="string">'jquery.js'</span> =&gt; <span class="string">'https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js'</span>, <span class="comment">// </span></span><br><span class="line">                <span class="string">'jquery.min.js'</span> =&gt; <span class="string">'https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js'</span>,</span><br><span class="line"><span class="comment">//                'jquery.js' =&gt; '@web/js/jquery/jquery.js',</span></span><br><span class="line"><span class="comment">//                'jquery.min.js' =&gt; '@web/js/jquery/jquery.js',</span></span><br><span class="line">            ],</span><br><span class="line">            ...</span><br><span class="line">        ],</span><br><span class="line">    ...</span><br><span class="line"> ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>把相应的 jquery 替换成 <code>v2.2.4</code> 解决<br><a href="https://stackoverflow.com/questions/37914869/jquery-ui-error-f-getclientrects-is-not-a-function" target="_blank" rel="noopener">问题来源</a></p><h3 id="macOS-brew安装php7-1-以及swoole扩展"><a href="#macOS-brew安装php7-1-以及swoole扩展" class="headerlink" title="macOS brew安装php7.1 以及swoole扩展"></a>macOS brew安装php7.1 以及swoole扩展</h3><p>brew改版后内核集成了php, 所以可以直接安装<br>安装php<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install php@7.1</span><br></pre></td></tr></table></figure></p><p>按提示把<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/php@7.1/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/php@7.1/sbin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>这些放到你本地命令行配置里面, 然后生成一个软链<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew link php@7.1 --force</span><br></pre></td></tr></table></figure></p><p>安装扩展就得使用pecl工具了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/opt/php@7.1       <span class="comment"># 执行完 brew link 之后就按软链的来, 这样的好处就是不用记小版本号, 路径短</span></span><br><span class="line">pecl install swoole             <span class="comment"># 提示 'openssl/ssl.h' file not found 就是你安装的时候别选 ssl支持就行</span></span><br></pre></td></tr></table></figure></p><p>如果提示 <code>No releases available for package “pecl.php.net/swoole”</code><br>参考 <a href="https://blog.joefom.com/archives/137" target="_blank" rel="noopener">执行 ‘pecl install swoole’之后，遇到的一些坑</a> , 按提示一步步走应该没问题</p><p>安装完毕之后需要变一下配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php -i | grep .ini</span><br><span class="line">...</span><br><span class="line">Loaded Configuration File =&gt; /usr/<span class="built_in">local</span>/etc/php/7.1/php.ini     //当前加载的配置文件路径</span><br><span class="line">...</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/etc/php/7.1</span><br></pre></td></tr></table></figure></p><p>先删除 php.ini 里面第一行的 <code>extension=swoole.so</code> 改成这个so文件的真实路径, 推荐放到隔壁的 conf.d 目录底下<br>然后<code>php -m | grep sw</code> 可以看一下了<br>安装其他扩展也是按这个路数来</p><h3 id="出现-Connection-reset-by-peer-报错"><a href="#出现-Connection-reset-by-peer-报错" class="headerlink" title="出现 Connection reset by peer 报错"></a>出现 Connection reset by peer 报错</h3><p>这是个tcp链接上的错误, 意味着 <code>链接过程中读或者写出现异常</code>, 出现的原因:</p><ol><li>AB两端, A端关闭了链接, B端仍在发送, 则抛异常</li><li>AB两端, A退出但没关闭链接, 则B在读的时候抛异常</li></ol><p>排查:</p><ol><li>先看看server端是不是对包大小进行了限制, buffer分配是否足够</li><li>是不是程序链接到上限了, 被服务器误杀</li><li>防火墙问题</li></ol><h3 id="Warning-preg-match-function-preg-match-Compilation-failed-PCRE-does-not-support-L-l-N-U-or-u-at"><a href="#Warning-preg-match-function-preg-match-Compilation-failed-PCRE-does-not-support-L-l-N-U-or-u-at" class="headerlink" title="Warning: preg_match() [function.preg-match]: Compilation failed: PCRE does not support \L, \l, \N, \U, or \u at"></a>Warning: preg_match() [function.preg-match]: Compilation failed: PCRE does not support \L, \l, \N, \U, or \u at</h3><p>php正则匹配中文字符的时候, 使用 <code>/^[\u4e00-\u9fa5]+$/</code> 这一条就会报上面的错误, 正确的写法应该是:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$str = <span class="string">"php编程"</span>;</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">"/^[\x&#123;4e00&#125;-\x&#123;9fa5&#125;]+$/u"</span>,$str)) &#123;</span><br><span class="line"><span class="keyword">print</span>(<span class="string">"该字符串全部是中文"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">print</span>(<span class="string">"该字符串不全部是中文"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/seanxyh/archive/2013/04/03/2998596.html" target="_blank" rel="noopener">php preg_match 正则匹配中文</a></p><h3 id="php匹配-UTF-8-with-DOM-的字符"><a href="#php匹配-UTF-8-with-DOM-的字符" class="headerlink" title="php匹配 UTF-8 with DOM 的字符"></a>php匹配 UTF-8 with DOM 的字符</h3><p>这个和上面的匹配中文是一起出现的, win上使用 UTF-8 格式的txt文件在linux上打开就会变成  <code>UTF-8 with DOM</code> 这个类型, 文件内容中会存在dom头, 从而干扰到一些判断, 比如正则匹配<br>解决办法也简单, 去掉就行<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的将win上的txt文件转成utf-8格式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUTF8</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">        $type = mb_detect_encoding($str, <span class="keyword">array</span>(<span class="string">"ASCII"</span>,<span class="string">"UTF-8"</span>,<span class="string">"GB2312"</span>,<span class="string">"GBK"</span>,<span class="string">"BIG5"</span>));</span><br><span class="line">        $result = iconv($type, <span class="string">'UTF-8//IGNORE'</span>, $str);</span><br><span class="line">        <span class="comment">// 防止UTF-8 with BOM 的情况</span></span><br><span class="line">        <span class="keyword">return</span> trim($result, <span class="string">"\xEF\xBB\xBF"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过 <code>utf-8 with dom</code> 对php来说是个隐患, 因为php没有对这块的处理, 会出现<code>ZERO WIDTH NO-BREAK SPACE</code>这样的问题, 有数据但是不会在页面输出</p><p>参考:<br><a href="https://blog.csdn.net/wb_ustc/article/details/3575768" target="_blank" rel="noopener">PHP UTF-8的 BOM 问题解决</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里做一些备注,以防再次碰到&lt;br&gt;
    
    </summary>
    
      <category term="php" scheme="http://blog.justwe.site/categories/php/"/>
    
    
      <category term="php" scheme="http://blog.justwe.site/tags/php/"/>
    
      <category term="debug" scheme="http://blog.justwe.site/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>转 Golang 需要避免踩的 50 个坑</title>
    <link href="http://blog.justwe.site/2019/01/31/go-50-tips/"/>
    <id>http://blog.justwe.site/2019/01/31/go-50-tips/</id>
    <published>2019-01-31T02:18:33.000Z</published>
    <updated>2019-01-31T02:51:52.195Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/wuYin/blog/blob/master/50-shades-of-golang-traps-gotchas-mistakes.md" target="_blank" rel="noopener">Golang 需要避免踩的 50 个坑</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/wuYin/blog/blob/master/50-shades-of-golang-traps-gotchas-mistakes.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Golang 需
      
    
    </summary>
    
      <category term="精选转载" scheme="http://blog.justwe.site/categories/%E7%B2%BE%E9%80%89%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>关于 Go 的 for Range 上的一个坑</title>
    <link href="http://blog.justwe.site/2019/01/30/go-for-range-error/"/>
    <id>http://blog.justwe.site/2019/01/30/go-for-range-error/</id>
    <published>2019-01-30T08:22:57.000Z</published>
    <updated>2019-01-30T10:12:38.839Z</updated>
    
    <content type="html"><![CDATA[<p><code>range</code>作为go的一个语法糖在进行迭代的时候是很方便的, 但6是传址赋值的时候需要小心一点</p><a id="more"></a><h5 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h5><p>直接上代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">fmt.Printf(<span class="string">"value's memery address: %v | value's value: %v \n"</span>, &amp;value, value)</span><br><span class="line">myMap[index] = &amp;value</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"=====new map by range====="</span>)</span><br><span class="line">fmt.Printf(<span class="string">"result: %v \n"</span>, myMap)</span><br><span class="line">prtMap(myMap)</span><br><span class="line"></span><br><span class="line">myMap2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">myMap2[i] = &amp;slice[i]</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"=====new map by for====="</span>)</span><br><span class="line">fmt.Printf(<span class="string">"result: %v \n"</span>, myMap2)</span><br><span class="line">prtMap(myMap2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prtMap</span><span class="params">(myMap <span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">fmt.Printf(<span class="string">"map[%v]=%v\n"</span>, key, *value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">value<span class="string">'s memery address: 0xc0000160a8 | value'</span>s value: 0</span><br><span class="line">value<span class="string">'s memery address: 0xc0000160a8 | value'</span>s value: 1</span><br><span class="line">value<span class="string">'s memery address: 0xc0000160a8 | value'</span>s value: 2</span><br><span class="line">value<span class="string">'s memery address: 0xc0000160a8 | value'</span>s value: 3</span><br><span class="line">=====new map by range=====</span><br><span class="line">result: map[0:0xc0000160a8 1:0xc0000160a8 2:0xc0000160a8 3:0xc0000160a8]</span><br><span class="line">map[1]=3</span><br><span class="line">map[2]=3</span><br><span class="line">map[3]=3</span><br><span class="line">map[0]=3</span><br><span class="line">i<span class="string">'s memery address: 0xc000016120 | value: 0</span></span><br><span class="line"><span class="string">i'</span>s memery address: 0xc000016120 | value: 1</span><br><span class="line">i<span class="string">'s memery address: 0xc000016120 | value: 2</span></span><br><span class="line"><span class="string">i'</span>s memery address: 0xc000016120 | value: 3</span><br><span class="line">=====new map by <span class="keyword">for</span>=====</span><br><span class="line">result: map[2:0xc00001c110 3:0xc00001c118 0:0xc00001c100 1:0xc00001c108]</span><br><span class="line">map[2]=2</span><br><span class="line">map[3]=3</span><br><span class="line">map[0]=0</span><br><span class="line">map[1]=1</span><br></pre></td></tr></table></figure></p><h5 id="猜测原因"><a href="#猜测原因" class="headerlink" title="猜测原因"></a>猜测原因</h5><p><code>range</code> 和 <code>for</code>  进行赋值操作<strong>只执行了一次</strong>, 因此在上面那个例子中 <code>value</code>和<code>i</code>的内存地址在循环的时候都没变过, 在进行值拷贝的时候是没问题的, 但是一旦加上 <code>&amp;</code> 的时候就变得很危险了, 造成的结果就是上面那个例子中的问题, 新数组存的都是同一个内存地址, 在 for 循环的时候因为只是利用的索引, 没有直接用到切片的值而不会引发这些问题, 在 range 的时候会出现 key,value 同时出现,那么就要小心处理了, 因为这里的value并不是切片中的原值, 而是一个拷贝出来的</p><p><a href="https://www.jianshu.com/p/35c2662b5b57" target="_blank" rel="noopener">Go Range 内部实现</a><br><a href="https://studygolang.com/articles/9701" target="_blank" rel="noopener">go语言坑之for range</a></p><h5 id="类似的问题"><a href="#类似的问题" class="headerlink" title="类似的问题"></a>类似的问题</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"i is %d \n"</span>, i)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出 4,4,4,4</span><br></pre></td></tr></table></figure><p>这个和上一个的问题还不一样, 这个就是闭包的执行顺序以及变量作用域的问题, 在执行闭包的时候for循环已经执行完毕,此时i=4, 接下来才会执行闭包内的函数, 规避这个问题也简单, 把变量的作用域改一下就行, 还有就是函数参数的值拷贝特点<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"i is %d \n"</span>, i)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://studygolang.com/articles/4313" target="_blank" rel="noopener">闭包和变量作用域</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;range&lt;/code&gt;作为go的一个语法糖在进行迭代的时候是很方便的, 但6是传址赋值的时候需要小心一点&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="range" scheme="http://blog.justwe.site/tags/range/"/>
    
  </entry>
  
  <entry>
    <title>转 Mac上一些好玩的命令行工具</title>
    <link href="http://blog.justwe.site/2019/01/18/tool-mac-terminal-awesome/"/>
    <id>http://blog.justwe.site/2019/01/18/tool-mac-terminal-awesome/</id>
    <published>2019-01-18T10:26:42.000Z</published>
    <updated>2019-01-21T09:55:22.514Z</updated>
    
    <content type="html"><![CDATA[<p>mac上一些有意思的命令行小工具</p><a id="more"></a><h3 id="asciinema-和-svg-term"><a href="#asciinema-和-svg-term" class="headerlink" title="asciinema 和  svg-term"></a>asciinema 和  svg-term</h3><p>assiiname 是用来命令行录屏的, svg-term 将文件转换成svg动图, 这个做截屏很方便</p><p>安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install asciinema</span><br><span class="line">npm install -g svg-term</span><br></pre></td></tr></table></figure></p><p>使用方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asciinema rec cast.json   // 开始录制, 数据保存在cast.json, 按 ctrl+d 保存</span><br><span class="line">cat cast.json | svg-term-cli   //输出svg文件</span><br></pre></td></tr></table></figure></p><p>比如下图<br><img src="/images/terminal/demo.svg" alt="图片"><br>缺点就是如果文件特别大帧率受到严重的影响</p><h4 id="sl-和-cmatrix-小特效玩具"><a href="#sl-和-cmatrix-小特效玩具" class="headerlink" title="sl 和 cmatrix 小特效玩具"></a>sl 和 cmatrix 小特效玩具</h4><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install sl</span><br><span class="line">brew install cmatrix</span><br></pre></td></tr></table></figure></p><p>平时装哔用的</p><h4 id="bat"><a href="#bat" class="headerlink" title="bat"></a>bat</h4><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install bat</span><br></pre></td></tr></table></figure></p><p>替代 <code>cat</code> 命令, 支持代码高亮</p><h4 id="ncdu-清理磁盘"><a href="#ncdu-清理磁盘" class="headerlink" title="ncdu 清理磁盘"></a>ncdu 清理磁盘</h4><p>如标题, 清理磁盘, 直接运行就行</p><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ncdu</span><br></pre></td></tr></table></figure></p><p>收藏链接:<br><a href="https://juejin.im/post/5c3dcecef265da6163024b1c" target="_blank" rel="noopener">优秀的命令行工具整理（一）</a><br><a href="https://juejin.im/post/5c418e2df265da616501d461" target="_blank" rel="noopener">优秀的命令行工具整理（二）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac上一些有意思的命令行小工具&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.justwe.site/categories/tools/"/>
    
    
      <category term="tools" scheme="http://blog.justwe.site/tags/tools/"/>
    
      <category term="mac" scheme="http://blog.justwe.site/tags/mac/"/>
    
      <category term="terminal" scheme="http://blog.justwe.site/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>用Gorilla Websocket 搞一个聊天室</title>
    <link href="http://blog.justwe.site/2019/01/15/go-chat/"/>
    <id>http://blog.justwe.site/2019/01/15/go-chat/</id>
    <published>2019-01-15T03:27:36.000Z</published>
    <updated>2019-01-15T05:47:41.682Z</updated>
    
    <content type="html"><![CDATA[<p>这个demo实现了:</p><ol><li>消息广播</li><li>心跳检测</li></ol><p>提供了一个通过命令行来进行聊天的例子</p><a id="more"></a><p>具体逻辑都在 websocket.go 这个文件里</p><p>这里的核心就是 <code>aliveList</code> 这个全局变量, 负责把消息分发给各客户端, 事件用channel来传递,  减少阻塞</p><p>单个链接会在 <code>aliveList</code> 中注册, ConnList 就是所有活跃的链接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AliveList 当前在线列表</span></span><br><span class="line"><span class="keyword">type</span> AliveList <span class="keyword">struct</span> &#123;</span><br><span class="line">ConnList  <span class="keyword">map</span>[<span class="keyword">string</span>]*Client</span><br><span class="line">register  <span class="keyword">chan</span> *Client</span><br><span class="line">destroy   <span class="keyword">chan</span> *Client</span><br><span class="line">broadcast <span class="keyword">chan</span> Message</span><br><span class="line">cancel    <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">Len       <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client socket客户端</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">string</span></span><br><span class="line">conn   *websocket.Conn</span><br><span class="line">cancel <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务启动后会执行事件监听循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(al *AliveList)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"开始监听注册事件"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> client := &lt;-al.register:</span><br><span class="line">log.Println(<span class="string">"注册事件:"</span>, client.ID)</span><br><span class="line">al.ConnList[client.ID] = client</span><br><span class="line">al.Len++</span><br><span class="line">al.SysBroadcast(ConnectedMessage, Message&#123;</span><br><span class="line">ID:      client.ID,</span><br><span class="line">Content: <span class="string">"connected"</span>,</span><br><span class="line">SentAt:  time.Now().Unix(),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> client := &lt;-al.destroy:</span><br><span class="line">log.Println(<span class="string">"销毁事件:"</span>, client.ID)</span><br><span class="line">err := client.conn.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"destroy Error: %v \n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(al.ConnList, client.ID)</span><br><span class="line">al.Len--</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> message := &lt;-al.broadcast:</span><br><span class="line">log.Printf(<span class="string">"广播事件: %s %s %d \n"</span>, message.ID, message.Content, message.Type)</span><br><span class="line"><span class="keyword">for</span> id := <span class="keyword">range</span> al.ConnList &#123;</span><br><span class="line"><span class="keyword">if</span> id != message.ID &#123;</span><br><span class="line"></span><br><span class="line">err := al.sendMessage(id, message)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">"broadcastError: "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> sign := &lt;-al.cancel:</span><br><span class="line">log.Println(<span class="string">"终止事件: "</span>, sign)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为消息的类型比较多, 单纯字符串无法满足需求, 就选用了比较常用的json格式去传递, 消息目前分:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// SystemMessage 系统消息</span></span><br><span class="line">SystemMessage = <span class="literal">iota</span></span><br><span class="line"><span class="comment">// BroadcastMessage 广播消息(正常的消息)</span></span><br><span class="line">BroadcastMessage</span><br><span class="line"><span class="comment">// HeartBeatMessage 心跳消息</span></span><br><span class="line">HeartBeatMessage</span><br><span class="line"><span class="comment">// ConnectedMessage 上线通知</span></span><br><span class="line">ConnectedMessage</span><br><span class="line"><span class="comment">// DisconnectedMessage 下线通知</span></span><br><span class="line">DisconnectedMessage</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Message 消息体结构</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">string</span></span><br><span class="line">Content <span class="keyword">string</span></span><br><span class="line">SentAt  <span class="keyword">int64</span></span><br><span class="line">Type    <span class="keyword">int</span>     <span class="comment">// &lt;- SystemMessage 等类型就是这里了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有空闲时间就再搞搞多聊天室的实现, 以及优化一下目前的事件循环逻辑<br><del>如果还有更多的余力, 就搞一个好看点的客户端?</del></p><p><a href="https://github.com/gaopengfei123123/chat" target="_blank" rel="noopener">demo地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个demo实现了:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息广播&lt;/li&gt;
&lt;li&gt;心跳检测&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;提供了一个通过命令行来进行聊天的例子&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="websocket" scheme="http://blog.justwe.site/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>转 Yii2 断线重连问题</title>
    <link href="http://blog.justwe.site/2018/12/19/yii-mysql/"/>
    <id>http://blog.justwe.site/2018/12/19/yii-mysql/</id>
    <published>2018-12-19T03:31:00.000Z</published>
    <updated>2018-12-19T03:40:02.627Z</updated>
    
    <content type="html"><![CDATA[<p>yii2 + swoole 的模式下因为使用swoole做的常驻内存服务, 那么之前的设计思路会有一点偏差, 不是第一眼能看到的就是 <code>mysql has gone away</code>的问题</p><p>目前解决思路就是当sql命令报错<code>mysql has gone away</code>的时候就断开重连再重新执行一次</p><a id="more"></a><p>参考 <a href="https://www.yiichina.com/topic/7296" target="_blank" rel="noopener">Yii2实现mysql断线重连</a></p><p>重写一个command类</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">common</span>\<span class="title">components</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> <span class="title">Yii</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增加执行sql时断开重连</span></span><br><span class="line"><span class="comment">     * 数据库连接断开异常</span></span><br><span class="line"><span class="comment">     * errorInfo = [''HY000',2006,'错误信息']</span></span><br><span class="line"><span class="comment">     * Class Command</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@package</span> common\components</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Command</span> <span class="keyword">extends</span> \<span class="title">yii</span>\<span class="title">db</span>\<span class="title">Command</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> EVENT_DISCONNECT = <span class="string">'disconnect'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理修改类型sql的断线重连问题</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> \Exception</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> \yii\db\Exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">parent</span>::execute();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(\<span class="keyword">Exception</span> $e)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;handleException($e))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">parent</span>::execute();</span><br><span class="line">                <span class="keyword">throw</span> $e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理查询类sql断线重连问题</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> string $method</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> null $fetchMode</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> \Exception</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> \yii\db\Exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">queryInternal</span><span class="params">($method, $fetchMode = null)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">parent</span>::queryInternal($method, $fetchMode);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(\<span class="keyword">Exception</span> $e)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;handleException($e))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">parent</span>::queryInternal($method, $fetchMode);</span><br><span class="line">                <span class="keyword">throw</span> $e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理执行sql时捕获的异常信息</span></span><br><span class="line"><span class="comment">         * 并且根据异常信息来决定是否需要重新连接数据库</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> \Exception $e</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> bool true: 需要重新执行sql false: 不需要重新执行sql</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">handleException</span><span class="params">(\Exception $e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//如果不是yii\db\Exception异常抛出该异常或者不是MySQL server has gone away</span></span><br><span class="line">            $offset = stripos($e-&gt;getMessage(),<span class="string">'MySQL server has gone away'</span>);</span><br><span class="line">            <span class="keyword">if</span>(($e <span class="keyword">instanceof</span> \yii\db\<span class="keyword">Exception</span>) == <span class="keyword">false</span> <span class="keyword">OR</span> $offset === <span class="keyword">false</span>)</span><br><span class="line">                <span class="comment">//OR $e-&gt;errorInfo[0] != 'HY000' OR $e-&gt;errorInfo[1] != 2006)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">$this</span>-&gt;trigger(<span class="keyword">static</span>::EVENT_DISCONNECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将pdo设置从null</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;pdoStatement = <span class="keyword">NULL</span>;</span><br><span class="line">            <span class="comment">//$this-&gt;db-&gt;resetPdo();</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;db-&gt;close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在配置文件中关于db的配置给加上指定的class<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'components'</span> =&gt; [</span><br><span class="line">            <span class="string">'db'</span> =&gt; [</span><br><span class="line">                <span class="string">'class'</span>   =&gt; <span class="string">'yii\db\Connection'</span>,</span><br><span class="line">                <span class="string">'commandClass'</span> =&gt; <span class="string">'common\components\Command'</span>,<span class="comment">// 加上这个</span></span><br><span class="line">                <span class="string">'username'</span> =&gt; <span class="string">'XXX'</span>,</span><br><span class="line">                <span class="string">'password'</span> =&gt; <span class="string">'XXX'</span>,</span><br><span class="line">                <span class="string">'dsn'</span> =&gt; <span class="string">'mysql:host=XXX;dbname=XXX;port=3306'</span>,</span><br><span class="line">            ],</span><br><span class="line">        ],</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure></p><p>相关文章:<br><a href="https://www.yiichina.com/topic/7296" target="_blank" rel="noopener">Yii2实现mysql断线重连</a><br><a href="https://blog.csdn.net/cenfei78325747/article/details/7854611" target="_blank" rel="noopener">在mysql中connection设置和wait-timeout的设置</a><br><a href="https://blog.csdn.net/csCrazybing/article/details/53303807" target="_blank" rel="noopener">查看mysql连接情况，以及连接超时时间设置</a><br><a href="https://blog.csdn.net/cor_twi/article/details/53098740" target="_blank" rel="noopener">源码剖析Yii错误 Invalid parameter number: no parameters were bound</a><br><a href="https://blog.csdn.net/cor_twi/article/details/52884730" target="_blank" rel="noopener">Yii 数据库重连告别General error: 2006 MySQL server has gone away</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yii2 + swoole 的模式下因为使用swoole做的常驻内存服务, 那么之前的设计思路会有一点偏差, 不是第一眼能看到的就是 &lt;code&gt;mysql has gone away&lt;/code&gt;的问题&lt;/p&gt;
&lt;p&gt;目前解决思路就是当sql命令报错&lt;code&gt;mysql has gone away&lt;/code&gt;的时候就断开重连再重新执行一次&lt;/p&gt;
    
    </summary>
    
      <category term="yii2" scheme="http://blog.justwe.site/categories/yii2/"/>
    
    
      <category term="yii2" scheme="http://blog.justwe.site/tags/yii2/"/>
    
  </entry>
  
  <entry>
    <title>Go Mysql数据库连接池的使用</title>
    <link href="http://blog.justwe.site/2018/12/17/go-mysql-pool/"/>
    <id>http://blog.justwe.site/2018/12/17/go-mysql-pool/</id>
    <published>2018-12-17T06:48:26.000Z</published>
    <updated>2018-12-17T07:28:32.770Z</updated>
    
    <content type="html"><![CDATA[<p>建立一个mysql连接池将极大的缩短应用的响应时间, 减少频繁的io开销以及gc, 这在golang里面也是很容易就实现的</p><a id="more"></a><p>示例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">_ <span class="string">"github.com/GO-SQL-Driver/MySQL"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, _ = sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123123@tcp(localhost:33060)/go?charset=utf8"</span>)</span><br><span class="line"><span class="comment">// 设置最大连接数</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">300</span>)</span><br><span class="line"><span class="comment">// 设置最大空闲连接数</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// 设置每个链接的过期时间</span></span><br><span class="line">db.SetConnMaxLifetime(time.Second * <span class="number">5</span>)</span><br><span class="line">err := db.Ping()</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">startServer(<span class="string">":9999"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(port <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">record := doSomething()</span><br><span class="line">fmt.Fprintln(w, record)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"listening http://localhost%s\n"</span>, port)</span><br><span class="line">err := http.ListenAndServe(port, <span class="literal">nil</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">rows, err := db.Query(<span class="string">"SELECT * FROM test LIMIT 1"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">columns, _ := rows.Columns()</span><br><span class="line">scanArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line">values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> values &#123;</span><br><span class="line">scanArgs[j] = &amp;values[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="comment">//将行数据保存到record字典</span></span><br><span class="line">err = rows.Scan(scanArgs...)</span><br><span class="line"><span class="keyword">for</span> i, col := <span class="keyword">range</span> values &#123;</span><br><span class="line"><span class="keyword">if</span> col != <span class="literal">nil</span> &#123;</span><br><span class="line">record[columns[i]] = <span class="keyword">string</span>(col.([]<span class="keyword">byte</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Println(record)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> record</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething2</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">dbConn, _ := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123123@tcp(localhost:33060)/go?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">defer</span> dbConn.Close()</span><br><span class="line"></span><br><span class="line">rows, err := dbConn.Query(<span class="string">"SELECT * FROM test LIMIT 1"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">columns, _ := rows.Columns()</span><br><span class="line">scanArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line">values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> values &#123;</span><br><span class="line">scanArgs[j] = &amp;values[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="comment">//将行数据保存到record字典</span></span><br><span class="line">err = rows.Scan(scanArgs...)</span><br><span class="line"><span class="keyword">for</span> i, col := <span class="keyword">range</span> values &#123;</span><br><span class="line"><span class="keyword">if</span> col != <span class="literal">nil</span> &#123;</span><br><span class="line">record[columns[i]] = <span class="keyword">string</span>(col.([]<span class="keyword">byte</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Println(record)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> record</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDoSomething</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">record := doSomething()</span><br><span class="line"></span><br><span class="line">t.Log(record)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDoSomething</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">doSomething()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDoSomethingParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">doSomething()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDoSomethingWithoutPoll</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">doSomething2()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDoSomethingWithoutPollParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">doSomething2()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出对比:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> --bench=.</span><br><span class="line"></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkDoSomething-4                             20000             67898 ns/op</span><br><span class="line">BenchmarkDoSomethingParallel-4                     50000             29347 ns/op</span><br><span class="line">BenchmarkDoSomethingWithoutPoll-4                   1000           8400516 ns/op</span><br><span class="line">BenchmarkDoSomethingWithoutPollParallel-4           2000           8167164 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      _/Users/gpf/Documents/go/code/mysql_curd/pool   28.857s</span><br></pre></td></tr></table></figure></p><p>关键就是这几个方法:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db, _ = sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123123@tcp(localhost:33060)/go?charset=utf8"</span>)</span><br><span class="line"><span class="comment">// 设置最大连接数</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">300</span>)</span><br><span class="line"><span class="comment">// 设置最大空闲连接数</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// 设置每个链接的过期时间</span></span><br><span class="line">db.SetConnMaxLifetime(time.Second * <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>设置超时时间很有必要, 避免出现server端主动关闭的情况 <code>mysql has gone away...</code></p><p><a href="http://www.01happy.com/golang-go-sql-drive-mysql-connection-pooling/" target="_blank" rel="noopener">代码来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建立一个mysql连接池将极大的缩短应用的响应时间, 减少频繁的io开销以及gc, 这在golang里面也是很容易就实现的&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="mysql" scheme="http://blog.justwe.site/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Go里的点点点语法</title>
    <link href="http://blog.justwe.site/2018/12/14/go-dotdotdot/"/>
    <id>http://blog.justwe.site/2018/12/14/go-dotdotdot/</id>
    <published>2018-12-14T02:37:32.000Z</published>
    <updated>2018-12-14T02:49:03.449Z</updated>
    
    <content type="html"><![CDATA[<p>golang 代码里面有时会出现 <code>...</code> 这个操作, 初次看到也是摸不到头脑,<br>其实他是用来做数组的析构用的</p><a id="more"></a><p>举个例子就明白了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pm := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">test(<span class="string">"abc"</span>, pm...) <span class="comment">// 相当于 test("abc", "a", "b", "c")</span></span><br><span class="line"></span><br><span class="line">ap := []<span class="keyword">string</span>&#123;<span class="string">"f"</span>, <span class="string">"g"</span>&#125;</span><br><span class="line">rs := <span class="built_in">append</span>(pm, ap...)  <span class="comment">// 相当于 append(pm, ap[0], ap[1], 以此类推)</span></span><br><span class="line">fmt.Println(<span class="string">"rs:"</span>, rs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(name <span class="keyword">string</span>, pms ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"output name:"</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> pms &#123;</span><br><span class="line">fmt.Printf(<span class="string">"k: %v, v: %v \n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output name: abc</span><br><span class="line">k: 0, v: a</span><br><span class="line">k: 1, v: b</span><br><span class="line">k: 2, v: c</span><br><span class="line">rs: [a b c f g]</span><br></pre></td></tr></table></figure><p>这里做了两个示例: </p><ol><li><p>在func中的 <code>...</code> eg: <code>func test(name string, pms ...string)</code><br>代表着不限参数数量, 而多出的参数都放在了 <code>var pms []string</code> 这个数组当中, 在go中典型的使用例子就是 <code>fmt.Print</code> 这一系列的方法</p></li><li><p>在传参的时候使用<code>...</code> 是用来表示将数组中每个元素单独传入函数中<br>较长用的就是出现数组合并的时候, 使用<code>append()</code> 方法时:<br>这样写正确</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ap := []<span class="keyword">string</span>&#123;<span class="string">"f"</span>, <span class="string">"g"</span>&#125;</span><br><span class="line">   rs := <span class="built_in">append</span>(pm, ap...)  <span class="comment">// 相当于 append(pm, ap[0], ap[1], 以此类推)</span></span><br></pre></td></tr></table></figure></li></ol><p>这样写就报错<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ap := []<span class="keyword">string</span>&#123;<span class="string">"f"</span>, <span class="string">"g"</span>&#125;</span><br><span class="line">rs := <span class="built_in">append</span>(pm, ap)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang 代码里面有时会出现 &lt;code&gt;...&lt;/code&gt; 这个操作, 初次看到也是摸不到头脑,&lt;br&gt;其实他是用来做数组的析构用的&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Crontab 设置一小时执行一次</title>
    <link href="http://blog.justwe.site/2018/12/11/linux-crontab/"/>
    <id>http://blog.justwe.site/2018/12/11/linux-crontab/</id>
    <published>2018-12-11T02:55:47.000Z</published>
    <updated>2018-12-11T03:21:59.706Z</updated>
    
    <content type="html"><![CDATA[<p>如果主管给你个任务, 让你每小时执行一次脚本, 是不是就是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * xxxxx.bash</span><br></pre></td></tr></table></figure></p><p>这样就错了呦~</p><a id="more"></a><p>以上产生的结果是每分钟执行一次, 因为从匹配角度来看每分钟都符合规则, 继而执行命令</p><p>因此对于整点定时任务有两种写法:</p><p>每<strong>整点</strong>执行一次:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 */1 * * * xxxxx.bash</span><br></pre></td></tr></table></figure></p><p>每<strong>隔60分钟</strong>执行一次:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/60 * * * * xxxxx.bash</span><br></pre></td></tr></table></figure></p><p>注意我的描述啊, 整点和隔60分钟其实是两个东西, 根据具体业务要求去使用它</p><p><img src="/images/crontab.png" alt=""></p><p>关于定时器这里有三个示例:</p><ol><li><p>在上午8点到11点的第3和第15分钟执行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每隔两天的上午8点到11点的第3和第15分钟执行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 */2 * * <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li><li><p>每个星期一的上午8点到11点的第3和第15分钟执行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li></ol><p>详细的crontab操作可以参考这篇博客:<br><a href="https://blog.csdn.net/u014726937/article/details/51182666" target="_blank" rel="noopener">crontab–定时器命令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果主管给你个任务, 让你每小时执行一次脚本, 是不是就是这样:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* */1 * * * xxxxx.bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样就错了呦~&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://blog.justwe.site/categories/tools/"/>
    
    
      <category term="linux" scheme="http://blog.justwe.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>通过Channel控制并发数量</title>
    <link href="http://blog.justwe.site/2018/12/04/go-channel-waitgroup/"/>
    <id>http://blog.justwe.site/2018/12/04/go-channel-waitgroup/</id>
    <published>2018-12-04T06:14:30.000Z</published>
    <updated>2018-12-04T06:26:24.991Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>go</code> 关键字有时候需要控制一下并发的数量, 但不至于去修改 <code>runtime.GOMAXPROCS</code> 这个数值, 这里就用到了缓冲<code>channel</code>的特性</p><a id="more"></a><p>demo:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WaitGroup 一个异步结构体</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">workChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">wg       sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPool 生成一个工作池, coreNum 限制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">(coreNum <span class="keyword">int</span>)</span> *<span class="title">WaitGroup</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, coreNum)</span><br><span class="line"><span class="keyword">return</span> &amp;WaitGroup&#123;</span><br><span class="line">workChan: ch,</span><br><span class="line">wg:       sync.WaitGroup&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ap *WaitGroup)</span> <span class="title">Add</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">ap.workChan &lt;- i</span><br><span class="line">ap.wg.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done 完结</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ap *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ap.workChan:</span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ap.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ap *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">ap.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRun</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">work := NewPool(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">work.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> testFunc(i, work)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"waiting..."</span>)</span><br><span class="line">work.Wait()</span><br><span class="line">t.Log(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFunc</span><span class="params">(i <span class="keyword">int</span>, wg *WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">"2006-01-02T15:04:05Z07:00"</span>), <span class="string">"output: "</span>, i)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">"2006-01-02T15:04:05Z07:00"</span>), <span class="string">"output: "</span>, i, <span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2018-12-04T14:22:27+08:00 output:  3</span><br><span class="line">2018-12-04T14:22:27+08:00 output:  1</span><br><span class="line">2018-12-04T14:22:27+08:00 output:  0</span><br><span class="line">2018-12-04T14:22:27+08:00 output:  2</span><br><span class="line">2018-12-04T14:22:28+08:00 output:  3 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:28+08:00 output:  0 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:28+08:00 output:  1 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:28+08:00 output:  5</span><br><span class="line">2018-12-04T14:22:28+08:00 output:  6</span><br><span class="line">2018-12-04T14:22:28+08:00 output:  2 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:28+08:00 output:  7</span><br><span class="line">2018-12-04T14:22:28+08:00 output:  4</span><br><span class="line">2018-12-04T14:22:29+08:00 output:  4 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:29+08:00 output:  8</span><br><span class="line">2018-12-04T14:22:29+08:00 output:  7 <span class="keyword">done</span></span><br><span class="line">2018-12-04T14:22:29+08:00 output:  6 <span class="keyword">done</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>这里还是要带上 <code>sync.WaitGroup</code>, 保证最后一次循环时携程不会过早退出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;code&gt;go&lt;/code&gt; 关键字有时候需要控制一下并发的数量, 但不至于去修改 &lt;code&gt;runtime.GOMAXPROCS&lt;/code&gt; 这个数值, 这里就用到了缓冲&lt;code&gt;channel&lt;/code&gt;的特性&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Nginx转发到go服务当中</title>
    <link href="http://blog.justwe.site/2018/11/25/go-nginx-docker/"/>
    <id>http://blog.justwe.site/2018/11/25/go-nginx-docker/</id>
    <published>2018-11-25T07:39:36.000Z</published>
    <updated>2018-11-25T07:52:38.746Z</updated>
    
    <content type="html"><![CDATA[<p>通过docker-compose编排的容器总是有一些奇怪的问题</p><a id="more"></a><p>问题核心就是go-server和nginx所属不同的容器, 需要外界能访问到go的服务就需要进行转发了</p><p>如果是在同一个容器中只需要:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  .a.com;</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    access_log  /home/a.com.access.log;</span><br><span class="line"></span><br><span class="line">    location /(css|js|fonts|img)/ &#123;</span><br><span class="line">        access_log off;</span><br><span class="line">        expires 1d;</span><br><span class="line"></span><br><span class="line">        root &quot;/path/to/app_a/static&quot;;</span><br><span class="line">        try_files $uri @backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files /_not_exists_ @backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @backend &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_set_header Host            $http_host;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://beego.me/docs/deploy/nginx.md" target="_blank" rel="noopener">beego-nginx部署</a></p><p>那么如果是两个容器当中呢? 基于上面的例子, 我们需要用到<code>upstream</code>, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">upstream go_server_proxy &#123;</span><br><span class="line">    # 这里的server 需要用到 容器名:端口 的形式</span><br><span class="line">    server go_server:9090;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    root /var/www;</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    access_log  /var/log/nginx/def.access.log;</span><br><span class="line"></span><br><span class="line">    location /(css|js|fonts|img)/ &#123;</span><br><span class="line">        access_log off;</span><br><span class="line">        expires 1d;</span><br><span class="line"></span><br><span class="line">        root &quot;/var/www/static&quot;;</span><br><span class="line">        try_files $uri @backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files /_not_exists_ @backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @backend &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_set_header Host            $http_host;</span><br><span class="line">        proxy_pass  http://go_server_proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的原因是容器之间的ip并不固定, 使用容器名做host地址是更简单的选择</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过docker-compose编排的容器总是有一些奇怪的问题&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.justwe.site/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.justwe.site/tags/go/"/>
    
      <category term="docker" scheme="http://blog.justwe.site/tags/docker/"/>
    
      <category term="nginx" scheme="http://blog.justwe.site/tags/nginx/"/>
    
  </entry>
  
</feed>
